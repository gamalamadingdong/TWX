import os
import json
import sqlite3
import pandas as pd
import time

class VulnerabilityDatabase:
    """SQLite-based database for storing and querying vulnerability data."""
    
    def __init__(self, db_path="data_processing/data/twx_vulnerabilities.db", create_tables=True):
        """Initialize the database connection."""
        os.makedirs(os.path.dirname(db_path), exist_ok=True)
        self.db_path = db_path
        self.conn = None
        if create_tables:
            self.create_tables()

    def optimize_database(self):
        """Run analysis and optimizations on the database."""
        conn = self.connect()
        cursor = conn.cursor()
        
        print("Running ANALYZE to update statistics...")
        cursor.execute("ANALYZE")
        
        print("Running VACUUM to defragment database...")
        cursor.execute("VACUUM")
        
        print("Database optimization complete.")
        
        # Return some statistics
        stats = {}
        cursor.execute("PRAGMA page_count")
        stats['page_count'] = cursor.fetchone()[0]
        
        cursor.execute("PRAGMA page_size")
        stats['page_size'] = cursor.fetchone()[0]
        
        stats['db_size_mb'] = (stats['page_count'] * stats['page_size']) / (1024 * 1024)
        
        # Count records in main tables
        for table in ['vulnerabilities', 'products', 'weaknesses', 'vuln_references']:
            cursor.execute(f"SELECT COUNT(*) FROM {table}")
            stats[f'{table}_count'] = cursor.fetchone()[0]
        
        return stats

    def connect(self):
        """Create an optimized connection to the SQLite database."""
        if self.conn is None:
            self.conn = sqlite3.connect(self.db_path)
            # Performance optimizations
            self.conn.execute("PRAGMA journal_mode = WAL")  # Write-Ahead Logging for better concurrency
            self.conn.execute("PRAGMA synchronous = NORMAL")  # Less waiting for disk writes
            self.conn.execute("PRAGMA cache_size = 100000")  # Larger cache (in pages)
            self.conn.execute("PRAGMA temp_store = MEMORY")  # Store temp tables in memory
            self.conn.execute("PRAGMA mmap_size = 30000000000")  # Use memory-mapped I/O when possible
            self.conn.execute("PRAGMA page_size = 4096")  # Optimal page size for most systems
            # Enable foreign keys
            self.conn.execute("PRAGMA foreign_keys = ON")
        return self.conn

    def close(self):
        """Close the database connection."""
        if self.conn:
            self.conn.close()
            self.conn = None

    def column_exists(self, table, column):
        """Check if a column exists in a table."""
        conn = self.connect()
        cursor = conn.cursor()
        cursor.execute(f"PRAGMA table_info({table})")
        columns = [info[1] for info in cursor.fetchall()]
        return column in columns

    def create_tables(self):
        """Create the necessary tables if they don't exist."""
        conn = self.connect()
        cursor = conn.cursor()
           
        # Create vulnerabilities table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS vulnerabilities (
            id TEXT PRIMARY KEY,
            description TEXT,
            published_date TEXT,
            modified_date TEXT,
            known_exploited INTEGER DEFAULT 0,
            has_exploit INTEGER DEFAULT 0,
            has_cisa_advisory INTEGER DEFAULT 0,
            has_vendor_advisory INTEGER DEFAULT 0,
            epss_score REAL,
            epss_percentile REAL,
            kev_date_added TEXT,
            kev_vendor_project TEXT,
            kev_product TEXT,
            kev_notes TEXT,
            kev_required_action TEXT,
            kev_due_date TEXT
        )
        ''')
        
        # Create weaknesses (CWE) table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS weaknesses (
            cwe_id TEXT PRIMARY KEY,
            name TEXT,
            description TEXT
        )
        ''')
        
        # Add new columns to weaknesses table if they don't exist
        if not self.column_exists("weaknesses", "category"):
            cursor.execute('ALTER TABLE weaknesses ADD COLUMN category TEXT;')
        
        if not self.column_exists("weaknesses", "extended_description"):
            cursor.execute('ALTER TABLE weaknesses ADD COLUMN extended_description TEXT;')
        
        if not self.column_exists("weaknesses", "mitigations"):
            cursor.execute('ALTER TABLE weaknesses ADD COLUMN mitigations TEXT;')
        
        # Create products table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS products (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            vendor TEXT,
            product TEXT,
            version TEXT,
            platform TEXT,
            version_start_including TEXT,
            version_start_excluding TEXT,
            version_end_including TEXT,
            version_end_excluding TEXT,
            UNIQUE(vendor, product, version)
        )
        ''')
        
        # Create vulnerability_weaknesses (many-to-many) table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS vulnerability_weaknesses (
            vuln_id TEXT,
            cwe_id TEXT,
            PRIMARY KEY (vuln_id, cwe_id),
            FOREIGN KEY (vuln_id) REFERENCES vulnerabilities(id),
            FOREIGN KEY (cwe_id) REFERENCES weaknesses(cwe_id)
        )
        ''')
        
        # Create vulnerability_products (many-to-many) table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS vulnerability_products (
            vuln_id TEXT,
            product_id INTEGER,
            PRIMARY KEY (vuln_id, product_id),
            FOREIGN KEY (vuln_id) REFERENCES vulnerabilities(id),
            FOREIGN KEY (product_id) REFERENCES products(id)
        )
        ''')
        
        # Create metrics table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS metrics (
            vuln_id TEXT PRIMARY KEY,
            cvss_version TEXT,
            base_score REAL,
            vector TEXT,
            attack_vector TEXT,
            attack_complexity TEXT,
            privileges_required TEXT,
            user_interaction TEXT,
            scope TEXT,
            confidentiality TEXT,
            integrity TEXT,
            availability TEXT,
            exploitability_score REAL,
            impact_score REAL,
            FOREIGN KEY (vuln_id) REFERENCES vulnerabilities(id)
        )
        ''')
        
        # Create vuln_references table - change the table name
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS vuln_references (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            vuln_id TEXT,
            url TEXT,
            reference_type TEXT,
            FOREIGN KEY (vuln_id) REFERENCES vulnerabilities(id)
        )
        ''')
        
        # Create attack techniques table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS attack_techniques (
            technique_id TEXT PRIMARY KEY,
            name TEXT,
            tactic TEXT,
            description TEXT
        )
        ''')
        
        # Create vulnerability_techniques (many-to-many) table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS vulnerability_techniques (
            vuln_id TEXT,
            technique_id TEXT,
            PRIMARY KEY (vuln_id, technique_id),
            FOREIGN KEY (vuln_id) REFERENCES vulnerabilities(id),
            FOREIGN KEY (technique_id) REFERENCES attack_techniques(technique_id)
        )
        ''')

        # Create vulnerability_attack_mappings table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS vulnerability_attack_mappings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            vuln_id TEXT,
            technique_id TEXT,
            mapping_type TEXT,
            confidence REAL,
            FOREIGN KEY (vuln_id) REFERENCES vulnerabilities(id),
            FOREIGN KEY (technique_id) REFERENCES attack_techniques(technique_id)
        )
        ''')

        cursor.execute("CREATE INDEX IF NOT EXISTS idx_vuln_weaknesses_vuln_id ON vulnerability_weaknesses (vuln_id)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_vuln_weaknesses_cwe_id ON vulnerability_weaknesses (cwe_id)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_vuln_products_vuln_id ON vulnerability_products (vuln_id)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_vuln_products_product_id ON vulnerability_products (product_id)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_vuln_references_vuln_id ON vuln_references (vuln_id)")

        
        conn.commit()
    
    
    def insert_vulnerability(self, vulnerability_data):
        """
        Insert a vulnerability record and its related data.
        
        Args:
            vulnerability_data: Dictionary containing normalized vulnerability data
        """
        conn = self.connect()
        cursor = conn.cursor()
        
        try:
            # Start a transaction
            conn.execute("BEGIN TRANSACTION")
            
            # Insert into vulnerabilities table
            vuln_id = vulnerability_data['id']
            cursor.execute('''
            INSERT OR REPLACE INTO vulnerabilities 
            (id, description, published_date, modified_date, 
             known_exploited, has_exploit, has_cisa_advisory, has_vendor_advisory,
             epss_score, epss_percentile,
             kev_date_added, kev_vendor_project, kev_product, kev_notes, kev_required_action, kev_due_date)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                vuln_id, 
                vulnerability_data.get('description', ''),
                vulnerability_data.get('other', {}).get('published', ''),
                vulnerability_data.get('other', {}).get('modified', ''),
                1 if vulnerability_data.get('known_exploited') else 0,
                1 if vulnerability_data.get('has_exploit') else 0,
                1 if vulnerability_data.get('has_cisa_advisory') else 0,
                1 if vulnerability_data.get('has_vendor_advisory') else 0,
                vulnerability_data.get('epss_score'),
                vulnerability_data.get('epss_percentile'),
                vulnerability_data.get('cisa_fields', {}).get('kev_date_added', ''),
                vulnerability_data.get('cisa_fields', {}).get('kev_vendor_project', ''),
                vulnerability_data.get('cisa_fields', {}).get('kev_product', ''),
                vulnerability_data.get('cisa_fields', {}).get('kev_notes', ''),
                vulnerability_data.get('cisa_fields', {}).get('kev_required_action', ''),
                vulnerability_data.get('cisa_fields', {}).get('kev_due_date', '')
            ))
            
            # Insert CVSS metrics
            if 'cvss' in vulnerability_data and vulnerability_data['cvss']:
                cvss = vulnerability_data['cvss']
                # Parse CVSS vector
                vector_parts = {}
                if 'vector' in cvss:
                    parts = cvss['vector'].split('/')
                    for part in parts:
                        if ':' in part:
                            key, value = part.split(':')
                            vector_parts[key] = value
                
                cursor.execute('''
                INSERT OR REPLACE INTO metrics
                (vuln_id, cvss_version, base_score, vector, 
                attack_vector, attack_complexity, privileges_required, user_interaction,
                scope, confidentiality, integrity, availability,
                exploitability_score, impact_score)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    vuln_id,
                    cvss.get('version', ''),
                    cvss.get('base_score', 0.0),
                    cvss.get('vector', ''),
                    vector_parts.get('AV', ''),
                    vector_parts.get('AC', ''),
                    vector_parts.get('PR', ''),
                    vector_parts.get('UI', ''),
                    vector_parts.get('S', ''),
                    vector_parts.get('C', ''),
                    vector_parts.get('I', ''),
                    vector_parts.get('A', ''),
                    cvss.get('exploitability_score', 0.0),
                    cvss.get('impact_score', 0.0)
                ))
            
            # Insert CWE weaknesses
            if 'cwe' in vulnerability_data and vulnerability_data['cwe']:
                for cwe_id in vulnerability_data['cwe']:
                    # First insert into weaknesses table (if not exists)
                    cursor.execute('''
                    INSERT OR IGNORE INTO weaknesses (cwe_id, name, description)
                    VALUES (?, ?, ?)
                    ''', (cwe_id, '', ''))  # Name and description would come from a separate CWE dictionary
                    
                    # Then insert into the relationship table
                    cursor.execute('''
                    INSERT OR IGNORE INTO vulnerability_weaknesses (vuln_id, cwe_id)
                    VALUES (?, ?)
                    ''', (vuln_id, cwe_id))
            
            # Insert affected products
            if 'products' in vulnerability_data and vulnerability_data['products']:
                for product in vulnerability_data['products']:
                    vendor = product.get('vendor', '')
                    product_name = product.get('product', '')
                    version = product.get('version', '')
                    
                    # Insert product and get its ID
                    cursor.execute('''
                    INSERT OR IGNORE INTO products (vendor, product, version)
                    VALUES (?, ?, ?)
                    ''', (vendor, product_name, version))
                    
                    # Get the product ID
                    cursor.execute('''
                    SELECT id FROM products WHERE vendor=? AND product=? AND version=?
                    ''', (vendor, product_name, version))
                    product_id = cursor.fetchone()[0]
                    
                    # Insert relationship
                    cursor.execute('''
                    INSERT OR IGNORE INTO vulnerability_products (vuln_id, product_id)
                    VALUES (?, ?)
                    ''', (vuln_id, product_id))
            
            # Insert references - check for 'references' key but insert into vuln_references table
            if 'references' in vulnerability_data and vulnerability_data['references']:
                for ref in vulnerability_data['references']:
                    if isinstance(ref, str):
                        url = ref
                        ref_type = ''
                    else:
                        # Handle if reference is a dictionary with more info
                        url = ref.get('url', '')
                        ref_type = ref.get('type', '')
                    
                    cursor.execute('''
                    INSERT INTO vuln_references (vuln_id, url, reference_type)
                    VALUES (?, ?, ?)
                    ''', (vuln_id, url, ref_type))
            
            # Insert attack techniques (if available)
            if 'attack_technique' in vulnerability_data and vulnerability_data['attack_technique']:
                for technique in vulnerability_data['attack_technique']:
                    technique_id = technique
                    # In a full implementation, you'd insert technique details from ATT&CK
                    cursor.execute('''
                    INSERT OR IGNORE INTO attack_techniques (technique_id, name, tactic, description)
                    VALUES (?, ?, ?, ?)
                    ''', (technique_id, '', '', ''))
                    
                    cursor.execute('''
                    INSERT OR IGNORE INTO vulnerability_techniques (vuln_id, technique_id)
                    VALUES (?, ?)
                    ''', (vuln_id, technique_id))
            
            # Commit the transaction
            conn.commit()
            return True
            
        except Exception as e:
            conn.rollback()
            print(f"Error inserting vulnerability {vulnerability_data.get('id')}: {e}")
            return False
    
    def get_all_attack_techniques(self):
        conn = self.connect()
        query = "SELECT technique_id, name, tactic, description FROM attack_techniques"
        
        try:
            df = pd.read_sql_query(query, conn)
            return df.to_dict('records')
        except Exception as e:
            print(f"Error retrieving ATT&CK techniques: {e}")
            return []
    
    def insert_vulnerability_attack_mapping(self, mapping):
        """
        Insert a mapping between a vulnerability and an ATT&CK technique.
        
        Args:
            mapping (dict): Dictionary containing mapping information:
                - vuln_id: CVE ID
                - technique_id: ATT&CK technique ID
                - mapping_type: Type of mapping (e.g., 'cwe_mapping', 'description_keyword')
                - confidence: Confidence score (0-1)
                
        Returns:
            bool: True if successful, False otherwise
        """
        conn = self.connect()
        cursor = conn.cursor()
        
        try:
            # Insert the mapping
            cursor.execute('''
            INSERT INTO vulnerability_attack_mappings (
                vuln_id, technique_id, mapping_type, confidence
            ) VALUES (?, ?, ?, ?)
            ''', (
                mapping['vuln_id'],
                mapping['technique_id'],
                mapping['mapping_type'],
                mapping['confidence']
            ))
            
            conn.commit()
            return True
            
        except Exception as e:
            print(f"Error inserting vulnerability-ATT&CK mapping: {e}")
            conn.rollback()
            return False

    def insert_attack_technique(self, technique_data):
        """
        Insert or update an ATT&CK technique.
        
        Args:
            technique_data: Dictionary containing technique data
                - technique_id: ATT&CK technique ID (e.g., T1059)
                - name: Name of the technique
                - tactic: Associated tactic
                - description: Description of the technique
        
        Returns:
            bool: True if successful, False otherwise
        """
        conn = self.connect()
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
            INSERT OR REPLACE INTO attack_techniques 
            (technique_id, name, tactic, description)
            VALUES (?, ?, ?, ?)
            ''', (
                technique_data['technique_id'],
                technique_data.get('name', ''),
                technique_data.get('tactic', ''),
                technique_data.get('description', '')
            ))
            
            conn.commit()
            return True
            
        except Exception as e:
            conn.rollback()
            print(f"Error inserting ATT&CK technique {technique_data.get('technique_id')}: {e}")
            return False

    def count_records(self, table_name):
        """Count the number of records in a table."""
        conn = self.connect()
        cursor = conn.cursor()
        try:
            cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
            return cursor.fetchone()[0]
        except Exception as e:
            print(f"Error counting records in {table_name}: {e}")
            return 0
    
    def batch_insert_vulnerabilities(self, vulnerabilities_data, batch_size=100):
        # Apply performance optimizations for bulk operations
        conn = self.connect()
        conn.execute("PRAGMA synchronous = OFF")  # Don't wait for disk writes
        conn.execute("PRAGMA journal_mode = MEMORY")  # In-memory journaling
        conn.execute("PRAGMA cache_size = 100000")  # Larger cache (in pages)
        conn.execute("PRAGMA temp_store = MEMORY")  # Store temp tables in memory
        """
        Insert multiple vulnerability records with optimized performance.
        
        Args:
            vulnerabilities_data: List of dictionaries containing vulnerability data
            batch_size: Number of records to process in a single transaction
            
        Returns:
            int: Number of successfully inserted records
        """
        total_records = len(vulnerabilities_data)
        success_count = 0
        start_time = time.time()
        last_report_time = start_time
        
        # Process in batches to balance memory usage and performance
        for i in range(0, total_records, batch_size):
            batch = vulnerabilities_data[i:i+batch_size]
            batch_start = time.time()
            
            # Start a transaction for the entire batch
            conn = self.connect()
            conn.execute("BEGIN TRANSACTION")
            
            try:
                # Process each vulnerability in the batch
                batch_success = 0
                for vuln in batch:
                    if self._insert_vulnerability_no_transaction(vuln):
                        batch_success += 1
                        success_count += 1
                
                # Commit the batch transaction
                conn.commit()
                batch_time = time.time() - batch_start
                
                # Progress reporting (not too frequently to avoid console spam)
                current_time = time.time()
                if current_time - last_report_time > 5 or i + batch_size >= total_records:
                    progress = (i + len(batch)) / total_records * 100
                    elapsed = current_time - start_time
                    est_total = elapsed / (progress / 100) if progress > 0 else 0
                    remaining = est_total - elapsed
                    
                    print(f"Progress: {progress:.1f}% ({i + len(batch)}/{total_records}) - "
                          f"Success rate: {success_count/(i + len(batch)):.1%} - "
                          f"Batch time: {batch_time:.2f}s - "
                          f"Est. remaining: {remaining/60:.1f} min")
                    last_report_time = current_time
                    
            except Exception as e:
                conn.rollback()
                print(f"Error in batch {i//batch_size + 1}: {e}")
        
        total_time = time.time() - start_time
        print(f"Batch insertion completed in {total_time/60:.2f} minutes - "
              f"Successfully inserted {success_count} of {total_records} records")
        
        return success_count

    def _insert_vulnerability_no_transaction(self, vulnerability_data):
        """Version of insert_vulnerability without transaction handling for batch operations"""
        conn = self.connect()
        cursor = conn.cursor()
        
        try:
            # Insert into vulnerabilities table
            vuln_id = vulnerability_data['id']
            cursor.execute('''
            INSERT OR REPLACE INTO vulnerabilities 
            (id, description, published_date, modified_date, 
             known_exploited, has_exploit, has_cisa_advisory, has_vendor_advisory,
             epss_score, epss_percentile,
             kev_date_added, kev_vendor_project, kev_product, kev_notes, kev_required_action, kev_due_date)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                vuln_id, 
                vulnerability_data.get('description', ''),
                vulnerability_data.get('other', {}).get('published', ''),
                vulnerability_data.get('other', {}).get('modified', ''),
                1 if vulnerability_data.get('known_exploited') else 0,
                1 if vulnerability_data.get('has_exploit') else 0,
                1 if vulnerability_data.get('has_cisa_advisory') else 0,
                1 if vulnerability_data.get('has_vendor_advisory') else 0,
                vulnerability_data.get('epss_score'),
                vulnerability_data.get('epss_percentile'),
                vulnerability_data.get('cisa_fields', {}).get('kev_date_added', ''),
                vulnerability_data.get('cisa_fields', {}).get('kev_vendor_project', ''),
                vulnerability_data.get('cisa_fields', {}).get('kev_product', ''),
                vulnerability_data.get('cisa_fields', {}).get('kev_notes', ''),
                vulnerability_data.get('cisa_fields', {}).get('kev_required_action', ''),
                vulnerability_data.get('cisa_fields', {}).get('kev_due_date', '')
            ))
            
            # Insert CVSS metrics
            if 'cvss' in vulnerability_data and vulnerability_data['cvss']:
                cvss = vulnerability_data['cvss']
                # Parse CVSS vector
                vector_parts = {}
                if 'vector' in cvss:
                    parts = cvss['vector'].split('/')
                    for part in parts:
                        if ':' in part:
                            key, value = part.split(':')
                            vector_parts[key] = value
                
                cursor.execute('''
                INSERT OR REPLACE INTO metrics
                (vuln_id, cvss_version, base_score, vector, 
                attack_vector, attack_complexity, privileges_required, user_interaction,
                scope, confidentiality, integrity, availability,
                exploitability_score, impact_score)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    vuln_id,
                    cvss.get('version', ''),
                    cvss.get('base_score', 0.0),
                    cvss.get('vector', ''),
                    vector_parts.get('AV', ''),
                    vector_parts.get('AC', ''),
                    vector_parts.get('PR', ''),
                    vector_parts.get('UI', ''),
                    vector_parts.get('S', ''),
                    vector_parts.get('C', ''),
                    vector_parts.get('I', ''),
                    vector_parts.get('A', ''),
                    cvss.get('exploitability_score', 0.0),
                    cvss.get('impact_score', 0.0)
                ))
            
            # Insert CWE weaknesses
            if 'cwe' in vulnerability_data and vulnerability_data['cwe']:
                for cwe_id in vulnerability_data['cwe']:
                    # First insert into weaknesses table (if not exists)
                    cursor.execute('''
                    INSERT OR IGNORE INTO weaknesses (cwe_id, name, description)
                    VALUES (?, ?, ?)
                    ''', (cwe_id, '', ''))  # Name and description would come from a separate CWE dictionary
                    
                    # Then insert into the relationship table
                    cursor.execute('''
                    INSERT OR IGNORE INTO vulnerability_weaknesses (vuln_id, cwe_id)
                    VALUES (?, ?)
                    ''', (vuln_id, cwe_id))
            
            # Insert affected products
            if 'products' in vulnerability_data and vulnerability_data['products']:
                for product in vulnerability_data['products']:
                    vendor = product.get('vendor', '')
                    product_name = product.get('product', '')
                    version = product.get('version', '')
                    
                    # Insert product and get its ID
                    cursor.execute('''
                    INSERT OR IGNORE INTO products (vendor, product, version)
                    VALUES (?, ?, ?)
                    ''', (vendor, product_name, version))
                    
                    # Get the product ID
                    cursor.execute('''
                    SELECT id FROM products WHERE vendor=? AND product=? AND version=?
                    ''', (vendor, product_name, version))
                    product_id = cursor.fetchone()[0]
                    
                    # Insert relationship
                    cursor.execute('''
                    INSERT OR IGNORE INTO vulnerability_products (vuln_id, product_id)
                    VALUES (?, ?)
                    ''', (vuln_id, product_id))
            
            # Insert references - check for 'references' key but insert into vuln_references table
            if 'references' in vulnerability_data and vulnerability_data['references']:
                for ref in vulnerability_data['references']:
                    if isinstance(ref, str):
                        url = ref
                        ref_type = ''
                    else:
                        # Handle if reference is a dictionary with more info
                        url = ref.get('url', '')
                        ref_type = ref.get('type', '')
                    
                    cursor.execute('''
                    INSERT INTO vuln_references (vuln_id, url, reference_type)
                    VALUES (?, ?, ?)
                    ''', (vuln_id, url, ref_type))
            
            # Insert attack techniques (if available)
            if 'attack_technique' in vulnerability_data and vulnerability_data['attack_technique']:
                for technique in vulnerability_data['attack_technique']:
                    technique_id = technique
                    # In a full implementation, you'd insert technique details from ATT&CK
                    cursor.execute('''
                    INSERT OR IGNORE INTO attack_techniques (technique_id, name, tactic, description)
                    VALUES (?, ?, ?, ?)
                    ''', (technique_id, '', '', ''))
                    
                    cursor.execute('''
                    INSERT OR IGNORE INTO vulnerability_techniques (vuln_id, technique_id)
                    VALUES (?, ?)
                    ''', (vuln_id, technique_id))
            
            return True
            
        except Exception as e:
            print(f"Error inserting vulnerability {vulnerability_data.get('id')}: {e}")
            return False

    def insert_cwe(self, cwe_data):
        """
        Insert or update a CWE weakness record.
        
        Args:
            cwe_data: Dictionary containing CWE data
                - cwe_id: CWE identifier (e.g., CWE-79)
                - name: Name of the weakness
                - description: Brief description
                - extended_description: Detailed description
                - category: Category/classification
                - mitigations: Mitigation information
        
        Returns:
            bool: True if successful, False otherwise
        """
        conn = self.connect()
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
            INSERT OR REPLACE INTO weaknesses 
            (cwe_id, name, description, extended_description, category, mitigations)
            VALUES (?, ?, ?, ?, ?, ?)
            ''', (
                cwe_data['cwe_id'],
                cwe_data['name'],
                cwe_data['description'],
                cwe_data.get('extended_description', ''),
                cwe_data.get('category', ''),
                cwe_data.get('mitigations', '')
            ))
            
            conn.commit()
            return True
            
        except Exception as e:
            conn.rollback()
            print(f"Error inserting CWE {cwe_data.get('cwe_id')}: {e}")
            return False
        
    def export_to_csv(self, output_path="analysis/classification_data.csv"):
        """
        Export comprehensive data for classification and analysis.
        
        Creates a unified dataset joining vulnerabilities with their
        associated weaknesses, products, metrics, and enrichment information.
        """
        conn = self.connect()
        
        # Enhanced query to include more fields from the database
        query = """
        SELECT 
            v.id as vuln_id,
            v.description,
            v.published_date,
            v.modified_date,
            v.known_exploited,
            v.has_exploit,
            v.has_cisa_advisory,
            v.has_vendor_advisory,
            v.epss_score,
            v.epss_percentile,
            v.kev_date_added,
            v.kev_vendor_project,
            v.kev_product,
            v.kev_notes,
            w.cwe_id as cwe,
            w.name as cwe_name,
            w.category as cwe_category,
            w.mitigations as cwe_mitigations,
            p.vendor,
            p.product,
            p.version,
            p.platform,
            p.version_start_including,
            p.version_start_excluding, 
            p.version_end_including,
            p.version_end_excluding,
            m.base_score,
            m.exploitability_score,
            m.impact_score,
            m.vector,
            m.attack_vector as av, 
            m.attack_complexity as ac, 
            m.privileges_required as pr, 
            m.user_interaction as ui, 
            m.scope as s, 
            m.confidentiality as c, 
            m.integrity as i, 
            m.availability as a
        FROM 
            vulnerabilities v
        LEFT JOIN 
            vulnerability_weaknesses vw ON v.id = vw.vuln_id
        LEFT JOIN 
            weaknesses w ON vw.cwe_id = w.cwe_id
        LEFT JOIN 
            vulnerability_products vp ON v.id = vp.vuln_id
        LEFT JOIN 
            products p ON vp.product_id = p.id
        LEFT JOIN 
            metrics m ON v.id = m.vuln_id
        """
        
        df = pd.read_sql_query(query, conn)
        
        # Basic counts and metadata
        df['product_count'] = df.groupby('vuln_id')['product'].transform('count')
        df['reference_count'] = df.apply(lambda x: self.count_references(x['vuln_id']), axis=1)
        
        # Reference information for mitigation extraction
        ref_df = pd.read_sql_query(
            """
            SELECT vuln_id, GROUP_CONCAT(url, '|') as reference_urls,
                   GROUP_CONCAT(reference_type, '|') as reference_types
            FROM vuln_references
            GROUP BY vuln_id
            """,
            conn
        )
        if not ref_df.empty:
            df = df.merge(ref_df, left_on='vuln_id', right_on='vuln_id', how='left')
        
        # Calculate days_to_patch (if published_date and modified_date are available)
        df['published_date'] = pd.to_datetime(df['published_date'], errors='coerce')
        df['modified_date'] = pd.to_datetime(df['modified_date'], errors='coerce')
        df['days_to_patch'] = (df['modified_date'] - df['published_date']).dt.days
        # Replace negative values and NaNs with 0
        df['days_to_patch'] = df['days_to_patch'].fillna(0).apply(lambda x: max(0, x))
        
        # Derive exploit_maturity based on available data
        def calculate_exploit_maturity(row):
            if row['known_exploited'] == 1:
                return 1.0  # Known exploitation
            elif row['has_exploit'] == 1:
                return 0.8  # Has exploit but not officially known
            elif row['epss_score'] and row['epss_score'] > 0.5:
                return 0.6  # High EPSS score
            elif row['epss_score']:
                return row['epss_score']  # Use EPSS as maturity indicator
            return 0.0  # Default
        
        df['exploit_maturity'] = df.apply(calculate_exploit_maturity, axis=1)
        
        # Create product_details field
        df['product_details'] = df.apply(
            lambda x: f"{x['vendor']}/{x['product']} {x['version']} ({x['platform']})" 
            if pd.notna(x['platform']) else f"{x['vendor']}/{x['product']} {x['version']}",
            axis=1
        )
        
        # Create affected_services_details (same as product_details for now)
        df['affected_services_details'] = df['product_details']
        
        # Extract mitigation info from CWE mitigations and references
        def extract_mitigation_info(row):
            mitigations = []
            
            # Add CWE mitigations if available
            if pd.notna(row['cwe_mitigations']) and row['cwe_mitigations']:
                mitigations.append(row['cwe_mitigations'])
                
            # Check for patch references
            if pd.notna(row['reference_types']) and 'patch' in str(row['reference_types']).lower():
                mitigations.append("Patch available")
                
            # Check for workaround references
            if pd.notna(row['reference_urls']):
                urls = str(row['reference_urls']).lower()
                if 'workaround' in urls or 'mitigation' in urls:
                    mitigations.append("Workaround available")
                    
            return "; ".join(mitigations) if mitigations else ""
        
        df['mitigation_info'] = df.apply(extract_mitigation_info, axis=1)
        
        # Save to CSV
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        df.to_csv(output_path, index=False)
        
        print(f"Exported {len(df)} enriched records to {output_path}")
        return df

    def get_vulnerability_by_id(self, vuln_id):
        """
        Retrieve a vulnerability by its ID with all related information.
        
        Args:
            vuln_id: Vulnerability ID (e.g., CVE-2024-xxxxx)
            
        Returns:
            Dictionary containing all vulnerability information
        """
        conn = self.connect()
        
        # Get basic vulnerability info
        vuln_df = pd.read_sql_query(
            "SELECT * FROM vulnerabilities WHERE id=?", 
            conn, 
            params=(vuln_id,)
        )
        
        if vuln_df.empty:
            return None
        
        vuln_data = vuln_df.iloc[0].to_dict()
        
        # Get metrics
        metrics_df = pd.read_sql_query(
            "SELECT * FROM metrics WHERE vuln_id=?", 
            conn, 
            params=(vuln_id,)
        )
        if not metrics_df.empty:
            vuln_data['cvss'] = metrics_df.iloc[0].to_dict()
        
        # Get CWEs
        cwe_df = pd.read_sql_query(
            """
            SELECT w.* FROM weaknesses w
            JOIN vulnerability_weaknesses vw ON w.cwe_id = vw.cwe_id
            WHERE vw.vuln_id=?
            """, 
            conn, 
            params=(vuln_id,)
        )
        if not cwe_df.empty:
            vuln_data['cwe'] = cwe_df['cwe_id'].tolist()
        
        # Get affected products
        products_df = pd.read_sql_query(
            """
            SELECT p.* FROM products p
            JOIN vulnerability_products vp ON p.id = vp.product_id
            WHERE vp.vuln_id=?
            """, 
            conn, 
            params=(vuln_id,)
        )
        if not products_df.empty:
            vuln_data['products'] = products_df.to_dict('records')
        
        # Get vuln_references - COMPLETING THIS SECTION
        refs_df = pd.read_sql_query(
            """
            SELECT url, reference_type FROM vuln_references
            WHERE vuln_id=?
            """,
            conn,
            params=(vuln_id,)
        )
        if not refs_df.empty:
            # If reference_type is present, return as dicts, otherwise as list of URLs
            if refs_df['reference_type'].any():
                vuln_data['references'] = refs_df.to_dict('records')
            else:
                vuln_data['references'] = refs_df['url'].tolist()
        
        # Get ATT&CK techniques
        techniques_df = pd.read_sql_query(
            """
            SELECT at.technique_id, at.name, at.tactic, vam.confidence, vam.mapping_type
            FROM attack_techniques at
            JOIN vulnerability_attack_mappings vam ON at.technique_id = vam.technique_id
            WHERE vam.vuln_id=?
            """,
            conn,
            params=(vuln_id,)
        )
        if not techniques_df.empty:
            vuln_data['attack_techniques'] = techniques_df.to_dict('records')
            # Also include just the technique IDs for backward compatibility
            vuln_data['attack_technique'] = techniques_df['technique_id'].tolist()
        
        return vuln_data

    def get_all_vulnerabilities_with_cwe(self):
        """Get all vulnerabilities with their CWEs."""
        conn = self.connect()
        query = """
        SELECT v.id, v.description, GROUP_CONCAT(w.cwe_id) as cwe
        FROM vulnerabilities v
        LEFT JOIN vulnerability_weaknesses vw ON v.id = vw.vuln_id
        LEFT JOIN weaknesses w ON vw.cwe_id = w.cwe_id
        GROUP BY v.id
        """
        df = pd.read_sql_query(query, conn)
        
        # Convert to list of dictionaries
        records = []
        for _, row in df.iterrows():
            cwe_list = row['cwe'].split(',') if row['cwe'] and pd.notnull(row['cwe']) else []
            records.append({
                'id': row['id'],
                'description': row['description'],
                'cwe': cwe_list
            })
        
        return records

    def count_references(self, vuln_id):
        """Count the number of references for a vulnerability."""
        conn = self.connect()
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM vuln_references WHERE vuln_id=?", (vuln_id,))
        return cursor.fetchone()[0]