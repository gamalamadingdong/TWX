CVE,description,published_date,modified_date,known_exploited,has_exploit,has_cisa_advisory,has_vendor_advisory,epss_score,epss_percentile,kev_date_added,kev_vendor_project,kev_product,kev_notes,cwe,cwe_name,cwe_category,cwe_mitigations,vendor,product,version,platform,version_start_including,version_start_excluding,version_end_including,version_end_excluding,base_score,exploitability_score,impact_score,vector,av,ac,pr,ui,s,c,i,a,product_count,reference_count,reference_urls,reference_types,days_to_patch,exploit_maturity,product_details,affected_services_details,mitigation_info,vuln_type,severity,original_type,validated_type,validation_notes
CVE-2021-1446,"A vulnerability in the DNS application layer gateway (ALG) functionality used by Network Address Translation (NAT) in Cisco IOS XE Software could allow an unauthenticated, remote attacker to cause an affected device to reload. The vulnerability is due to a logic error that occurs when an affected device inspects certain DNS packets. An attacker could exploit this vulnerability by sending crafted DNS packets through an affected device that is performing NAT for DNS packets. A successful exploit could allow an attacker to cause the device to reload, resulting in a denial of service (DoS) condition on an affected device. The vulnerability can be exploited only by traffic that is sent through an affected device via IPv4 packets. The vulnerability cannot be exploited via IPv6 traffic.",,,0,0,0,0,,,,,,,CWE-754,Improper Check for Unusual or Exceptional Conditions,Class,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Choose languages with features such as exception handling that force the programmer to anticipate unusual conditions that may generate exceptions. Custom exceptions may need to be developed to handle unusual business-logic conditions. Be careful not to pass sensitive exceptions back to the user (CWE-209, CWE-248).; Check the results of all functions that return a value and verify that the value is expected.; If using exception handling, catch and throw specific exceptions instead of overly-general exceptions (CWE-396, CWE-397). Catch and handle exceptions as locally as possible so that exceptions do not propagate too far up the call stack (CWE-705). Avoid unchecked or uncaught exceptions where feasible (CWE-248).; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
		  Exposing additional information to a potential attacker in the context of an exceptional condition can help the attacker determine what attack vectors are most likely to succeed beyond DoS.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.; Use system limits, which should help to prevent resource exhaustion. However, the product should still handle low resource conditions since they may still occur.",cisco,ios_xe,16.9.1a,,,,,,8.6,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H,N,L,N,N,C,N,N,H,266,3,https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-alg-dos-hbBS7SZE|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-alg-dos-hbBS7SZE|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-alg-dos-hbBS7SZE,||,0,0,cisco/ios_xe 16.9.1a,cisco/ios_xe 16.9.1a,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Choose languages with features such as exception handling that force the programmer to anticipate unusual conditions that may generate exceptions. Custom exceptions may need to be developed to handle unusual business-logic conditions. Be careful not to pass sensitive exceptions back to the user (CWE-209, CWE-248).; Check the results of all functions that return a value and verify that the value is expected.; If using exception handling, catch and throw specific exceptions instead of overly-general exceptions (CWE-396, CWE-397). Catch and handle exceptions as locally as possible so that exceptions do not propagate too far up the call stack (CWE-705). Avoid unchecked or uncaught exceptions where feasible (CWE-248).; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
		  Exposing additional information to a potential attacker in the context of an exceptional condition can help the attacker determine what attack vectors are most likely to succeed beyond DoS.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.; Use system limits, which should help to prevent resource exhaustion. However, the product should still handle low resource conditions since they may still occur.",Other,High,Other,Denial of Service (DoS),
CVE-2024-20268,"A vulnerability in the Simple Network Management Protocol (SNMP) feature of Cisco Adaptive Security Appliance (ASA) Software and Cisco Firepower Threat Defense (FTD) Software could allow an authenticated, remote attacker to cause an unexpected reload of the device.

This vulnerability is due to insufficient input validation of SNMP packets. An attacker could exploit this vulnerability by sending a crafted SNMP request to an affected device using IPv4 or IPv6. A successful exploit could allow the attacker to cause the affected device to reload, resulting in a denial of service (DoS) condition. This vulnerability affects all versions of SNMP (versions 1, 2c, and 3) and requires a valid SNMP community string or valid SNMPv3 user credentials.",,,0,0,0,0,,,,,,,CWE-231,Improper Handling of Extra Values,Variant,,Cisco,Cisco Adaptive Security Appliance (ASA) Software,9.14.1.30,,,,,,7.7,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H,N,L,L,N,C,N,N,H,144,6,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-snmp-dos-7TcnzxTU|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-fmc-xss-M446vbEO|https://sec.cloudapps.cisco.com/security/center/viewErp.x?alertId=ERP-75300|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-snmp-dos-7TcnzxTU|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-fmc-xss-M446vbEO|https://sec.cloudapps.cisco.com/security/center/viewErp.x?alertId=ERP-75300,|||||,0,0,Cisco/Cisco Adaptive Security Appliance (ASA) Software 9.14.1.30,Cisco/Cisco Adaptive Security Appliance (ASA) Software 9.14.1.30,,Other,High,Other,Denial of Service (DoS),
CVE-2024-38153,,,,0,0,0,0,,,,,,,CWE-367,Time-of-check Time-of-use (TOCTOU) Race Condition,Base,"The most basic advice for TOCTOU vulnerabilities is to not perform a check before the use. This does not resolve the underlying issue of the execution of a function on a resource whose state and identity cannot be assured, but it does help to limit the false sense of security given by the check.; When the file being altered is owned by the current user and group, set the effective gid and uid to that of the current user and group when executing this statement.; Limit the interleaving of operations on files from multiple processes.; If you cannot perform operations atomically and you must share access to the resource between multiple processes or threads, then try to limit the amount of time (CPU cycles) between the check and use of the resource. This will not fix the problem, but it could make it more difficult for an attack to succeed.; Recheck the resource after the use call to verify that the action was taken appropriately.; Ensure that some environmental locking mechanism can be used to protect resources effectively.; Ensure that locking occurs before the check, as opposed to afterwards, such that the resource, as checked, is the same as it is when in use.",Microsoft,Windows Server 2008  Service Pack 2,6.0.6003.0,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,L,L,L,N,U,H,H,H,42,2,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-38153|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-38153,|,0,0,Microsoft/Windows Server 2008  Service Pack 2 6.0.6003.0,Microsoft/Windows Server 2008  Service Pack 2 6.0.6003.0,"The most basic advice for TOCTOU vulnerabilities is to not perform a check before the use. This does not resolve the underlying issue of the execution of a function on a resource whose state and identity cannot be assured, but it does help to limit the false sense of security given by the check.; When the file being altered is owned by the current user and group, set the effective gid and uid to that of the current user and group when executing this statement.; Limit the interleaving of operations on files from multiple processes.; If you cannot perform operations atomically and you must share access to the resource between multiple processes or threads, then try to limit the amount of time (CPU cycles) between the check and use of the resource. This will not fix the problem, but it could make it more difficult for an attack to succeed.; Recheck the resource after the use call to verify that the action was taken appropriately.; Ensure that some environmental locking mechanism can be used to protect resources effectively.; Ensure that locking occurs before the check, as opposed to afterwards, such that the resource, as checked, is the same as it is when in use.",Other,High,Other,Elevation of Privilege (EoP),
CVE-2022-25172,"An information disclosure vulnerability exists in the web interface session cookie functionality of InHand Networks InRouter302 V3.5.4. The session cookie misses the HttpOnly flag, making it accessible via JavaScript and thus allowing an attacker, able to perform an XSS attack, to steal the session cookie.",,,0,0,0,0,,,,,,,CWE-732,Incorrect Permission Assignment for Critical Resource,Class,"When using a critical resource such as a configuration file, check to see if the resource has insecure permissions (such as being modifiable by any regular user) [REF-62], and generate an error or even exit the software if there is a possibility that the resource could have been modified by an unauthorized party.; Divide the software into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully defining distinct user groups, privileges, and/or roles. Map these against data, functionality, and the related resources. Then set the permissions accordingly. This will allow you to maintain more fine-grained control over your resources. [REF-207]; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; During program startup, explicitly set the default permissions or umask to the most restrictive setting possible. Also set the appropriate permissions during program installation. This will prevent you from inheriting insecure permissions from any user who installs or runs the program.; For all configuration files, executables, and libraries, make sure that they are only readable and writable by the software's administrator.; Do not suggest insecure configuration changes in documentation, especially if those configurations can extend to resources and other programs that are outside the scope of the application.; Do not assume that a system administrator will manually change the configuration to the settings that are recommended in the software's manual.; Ensure that the software runs properly under the United States Government Configuration Baseline (USGCB) [REF-199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software.; When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to disable public access.",Other_Vendor,Other_Product,V3.5.4,,,,,,7.5,,,CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,N,L,N,N,U,H,N,N,2,6,https://talosintelligence.com/vulnerability_reports/TALOS-2022-1470|https://talosintelligence.com/vulnerability_reports/TALOS-2022-1470|https://www.inhandnetworks.com/upload/attachment/202205/10/InHand-PSA-2022-01.pdf|https://www.inhandnetworks.com/upload/attachment/202205/10/InHand-PSA-2022-01.pdf|https://www.inhandnetworks.com/upload/attachment/202205/10/InHand-PSA-2022-01.pdf|https://talosintelligence.com/vulnerability_reports/TALOS-2022-1470,|||||,0,0,InHand Networks/InRouter302 V3.5.4,InHand Networks/InRouter302 V3.5.4,"When using a critical resource such as a configuration file, check to see if the resource has insecure permissions (such as being modifiable by any regular user) [REF-62], and generate an error or even exit the software if there is a possibility that the resource could have been modified by an unauthorized party.; Divide the software into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully defining distinct user groups, privileges, and/or roles. Map these against data, functionality, and the related resources. Then set the permissions accordingly. This will allow you to maintain more fine-grained control over your resources. [REF-207]; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; During program startup, explicitly set the default permissions or umask to the most restrictive setting possible. Also set the appropriate permissions during program installation. This will prevent you from inheriting insecure permissions from any user who installs or runs the program.; For all configuration files, executables, and libraries, make sure that they are only readable and writable by the software's administrator.; Do not suggest insecure configuration changes in documentation, especially if those configurations can extend to resources and other programs that are outside the scope of the application.; Do not assume that a system administrator will manually change the configuration to the settings that are recommended in the software's manual.; Ensure that the software runs properly under the United States Government Configuration Baseline (USGCB) [REF-199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software.; When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to disable public access.",Other,High,Other,Information Disclosure,
CVE-2024-38178,,,,0,0,0,0,,,,,,,CWE-843,Access of Resource Using Incompatible Type ('Type Confusion'),Base,,microsoft,windows_11_22h2,*,,,,,,7.5,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H/E:F/RL:O/RC:C,N,H,N,R,U,H,H,H,32,2,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-38178|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-38178,|,0,0,microsoft/windows_11_22h2 *,microsoft/windows_11_22h2 *,,Other,High,Other,Memory Corruption,
CVE-2024-21615,"An Incorrect Default Permissions vulnerability in Juniper Networks Junos OS and Junos OS Evolved allows a local, low-privileged attacker to access confidential information on the system.

On all Junos OS and Junos OS Evolved platforms, when NETCONF traceoptions are configured, and a super-user performs specific actions via NETCONF, then a low-privileged user can access sensitive information compromising the confidentiality of the system.
This issue affects:

Junos OS:



  *  all versions before 21.2R3-S7, 

  *  from 21.4 before 21.4R3-S5, 

  *  from 22.1 before 22.1R3-S5, 

  *  from 22.2 before 22.2R3-S3, 

  *  from 22.3 before 22.3R3-S2, 

  *  from 22.4 before 22.4R3, 

  *  from 23.2 before 23.2R1-S2.





Junos OS Evolved: 



  *  all versions before 21.2R3-S7-EVO, 

  *  from 21.3 before 21.3R3-S5-EVO, 

  *  from 21.4 before 21.4R3-S5-EVO, 

  *  from 22.1 before 22.1R3-S5-EVO, 

  *  from 22.2 before 22.2R3-S3-EVO, 

  *  from 22.3 before 22.3R3-S2-EVO,

  *  from 22.4 before 22.4R3-EVO, 

  *  from 23.2 before 23.2R1-S2.",,,0,0,0,0,,,,,,,CWE-276,Incorrect Default Permissions,Base,"The architecture needs to access and modification attributes for files to only those users who actually require those actions.; Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
          Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",juniper,Other_Product,21.4,,,,,,5,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:N,L,L,L,R,U,H,N,N,32,6,https://supportportal.juniper.net/JSA75756|https://supportportal.juniper.net/JSA75756|https://www.first.org/cvss/calculator/4.0#CVSS:4.0/AV:L/AC:L/AT:N/PR:L/UI:P/VC:H/VI:N/VA:N/SC:L/SI:N/SA:N|https://www.first.org/cvss/calculator/4.0#CVSS:4.0/AV:L/AC:L/AT:N/PR:L/UI:P/VC:H/VI:N/VA:N/SC:L/SI:N/SA:N|https://supportportal.juniper.net/JSA75756|https://www.first.org/cvss/calculator/4.0#CVSS:4.0/AV:L/AC:L/AT:N/PR:L/UI:P/VC:H/VI:N/VA:N/SC:L/SI:N/SA:N,|||||,0,0,juniper/junos_os_evolved 21.4,juniper/junos_os_evolved 21.4,"The architecture needs to access and modification attributes for files to only those users who actually require those actions.; Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
          Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Other,Medium,Other,Incorrect Default Permissions,
CVE-2024-20480,"A vulnerability in the DHCP Snooping feature of Cisco IOS XE Software on Software-Defined Access (SD-Access) fabric edge nodes could allow an unauthenticated, remote attacker to cause high CPU utilization on an affected device, resulting in a denial of service (DoS) condition that requires a manual reload to recover.  
 This vulnerability is due to improper handling of IPv4 DHCP packets. An attacker could exploit this vulnerability by sending certain IPv4 DHCP packets to an affected device. A successful exploit could allow the attacker to cause the device to exhaust CPU resources and stop processing traffic, resulting in a DoS condition that requires a manual reload to recover.",,,0,0,0,0,,,,,,,CWE-670,Always-Incorrect Control Flow Implementation,Class,,cisco,ios_xe,16.3.3,,,,,,8.6,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H,N,L,N,N,C,N,N,H,820,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ios-xe-sda-edge-dos-MBcbG9k|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ios-xe-sda-edge-dos-MBcbG9k,|,0,0,cisco/ios_xe 16.3.3,cisco/ios_xe 16.3.3,,Other,High,Other,Denial of Service (DoS),
CVE-2024-26781,"In the Linux kernel, the following vulnerability has been resolved:

mptcp: fix possible deadlock in subflow diag

Syzbot and Eric reported a lockdep splat in the subflow diag:

   WARNING: possible circular locking dependency detected
   6.8.0-rc4-syzkaller-00212-g40b9385dd8e6 #0 Not tainted

   syz-executor.2/24141 is trying to acquire lock:
   ffff888045870130 (k-sk_lock-AF_INET6){+.+.}-{0:0}, at:
   tcp_diag_put_ulp net/ipv4/tcp_diag.c:100 [inline]
   ffff888045870130 (k-sk_lock-AF_INET6){+.+.}-{0:0}, at:
   tcp_diag_get_aux+0x738/0x830 net/ipv4/tcp_diag.c:137

   but task is already holding lock:
   ffffc9000135e488 (&h->lhash2[i].lock){+.+.}-{2:2}, at: spin_lock
   include/linux/spinlock.h:351 [inline]
   ffffc9000135e488 (&h->lhash2[i].lock){+.+.}-{2:2}, at:
   inet_diag_dump_icsk+0x39f/0x1f80 net/ipv4/inet_diag.c:1038

   which lock already depends on the new lock.

   the existing dependency chain (in reverse order) is:

   -> #1 (&h->lhash2[i].lock){+.+.}-{2:2}:
   lock_acquire+0x1e3/0x530 kernel/locking/lockdep.c:5754
   __raw_spin_lock include/linux/spinlock_api_smp.h:133 [inline]
   _raw_spin_lock+0x2e/0x40 kernel/locking/spinlock.c:154
   spin_lock include/linux/spinlock.h:351 [inline]
   __inet_hash+0x335/0xbe0 net/ipv4/inet_hashtables.c:743
   inet_csk_listen_start+0x23a/0x320 net/ipv4/inet_connection_sock.c:1261
   __inet_listen_sk+0x2a2/0x770 net/ipv4/af_inet.c:217
   inet_listen+0xa3/0x110 net/ipv4/af_inet.c:239
   rds_tcp_listen_init+0x3fd/0x5a0 net/rds/tcp_listen.c:316
   rds_tcp_init_net+0x141/0x320 net/rds/tcp.c:577
   ops_init+0x352/0x610 net/core/net_namespace.c:136
   __register_pernet_operations net/core/net_namespace.c:1214 [inline]
   register_pernet_operations+0x2cb/0x660 net/core/net_namespace.c:1283
   register_pernet_device+0x33/0x80 net/core/net_namespace.c:1370
   rds_tcp_init+0x62/0xd0 net/rds/tcp.c:735
   do_one_initcall+0x238/0x830 init/main.c:1236
   do_initcall_level+0x157/0x210 init/main.c:1298
   do_initcalls+0x3f/0x80 init/main.c:1314
   kernel_init_freeable+0x42f/0x5d0 init/main.c:1551
   kernel_init+0x1d/0x2a0 init/main.c:1441
   ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147
   ret_from_fork_asm+0x1b/0x30 arch/x86/entry/entry_64.S:242

   -> #0 (k-sk_lock-AF_INET6){+.+.}-{0:0}:
   check_prev_add kernel/locking/lockdep.c:3134 [inline]
   check_prevs_add kernel/locking/lockdep.c:3253 [inline]
   validate_chain+0x18ca/0x58e0 kernel/locking/lockdep.c:3869
   __lock_acquire+0x1345/0x1fd0 kernel/locking/lockdep.c:5137
   lock_acquire+0x1e3/0x530 kernel/locking/lockdep.c:5754
   lock_sock_fast include/net/sock.h:1723 [inline]
   subflow_get_info+0x166/0xd20 net/mptcp/diag.c:28
   tcp_diag_put_ulp net/ipv4/tcp_diag.c:100 [inline]
   tcp_diag_get_aux+0x738/0x830 net/ipv4/tcp_diag.c:137
   inet_sk_diag_fill+0x10ed/0x1e00 net/ipv4/inet_diag.c:345
   inet_diag_dump_icsk+0x55b/0x1f80 net/ipv4/inet_diag.c:1061
   __inet_diag_dump+0x211/0x3a0 net/ipv4/inet_diag.c:1263
   inet_diag_dump_compat+0x1c1/0x2d0 net/ipv4/inet_diag.c:1371
   netlink_dump+0x59b/0xc80 net/netlink/af_netlink.c:2264
   __netlink_dump_start+0x5df/0x790 net/netlink/af_netlink.c:2370
   netlink_dump_start include/linux/netlink.h:338 [inline]
   inet_diag_rcv_msg_compat+0x209/0x4c0 net/ipv4/inet_diag.c:1405
   sock_diag_rcv_msg+0xe7/0x410
   netlink_rcv_skb+0x1e3/0x430 net/netlink/af_netlink.c:2543
   sock_diag_rcv+0x2a/0x40 net/core/sock_diag.c:280
   netlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline]
   netlink_unicast+0x7ea/0x980 net/netlink/af_netlink.c:1367
   netlink_sendmsg+0xa3b/0xd70 net/netlink/af_netlink.c:1908
   sock_sendmsg_nosec net/socket.c:730 [inline]
   __sock_sendmsg+0x221/0x270 net/socket.c:745
   ____sys_sendmsg+0x525/0x7d0 net/socket.c:2584
   ___sys_sendmsg net/socket.c:2638 [inline]
   __sys_sendmsg+0x2b0/0x3a0 net/socket.c:2667
   do_syscall_64+0xf9/0x240
   entry_SYSCALL_64_after_hwframe+0x6f/0x77

As noted by Eric we can break the lock dependency chain avoid
dumping 
---truncated---",,,0,0,0,0,,,,,,,CWE-667,Improper Locking,Class,Use industry standard APIs to implement locking mechanism.,linux,linux_kernel,5.15.150,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,16,19,https://git.kernel.org/stable/c/70e5b013538d5e4cb421afed431a5fcd2a5d49ee|https://git.kernel.org/stable/c/70e5b013538d5e4cb421afed431a5fcd2a5d49ee|https://git.kernel.org/stable/c/cc32ba2fdf3f8b136619fff551f166ba51ec856d|https://git.kernel.org/stable/c/cc32ba2fdf3f8b136619fff551f166ba51ec856d|https://git.kernel.org/stable/c/d487e7ba1bc7444d5f062c4930ef8436c47c7e63|https://git.kernel.org/stable/c/d487e7ba1bc7444d5f062c4930ef8436c47c7e63|https://git.kernel.org/stable/c/d6a9608af9a75d13243d217f6ce1e30e57d56ffe|https://git.kernel.org/stable/c/d6a9608af9a75d13243d217f6ce1e30e57d56ffe|https://git.kernel.org/stable/c/f27d319df055629480b84b9288a502337b6f2a2e|https://git.kernel.org/stable/c/f27d319df055629480b84b9288a502337b6f2a2e|https://git.kernel.org/stable/c/fa8c776f4c323a9fbc8ddf25edcb962083391430|https://git.kernel.org/stable/c/fa8c776f4c323a9fbc8ddf25edcb962083391430|https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html|https://git.kernel.org/stable/c/70e5b013538d5e4cb421afed431a5fcd2a5d49ee|https://git.kernel.org/stable/c/cc32ba2fdf3f8b136619fff551f166ba51ec856d|https://git.kernel.org/stable/c/f27d319df055629480b84b9288a502337b6f2a2e|https://git.kernel.org/stable/c/fa8c776f4c323a9fbc8ddf25edcb962083391430|https://git.kernel.org/stable/c/d487e7ba1bc7444d5f062c4930ef8436c47c7e63|https://git.kernel.org/stable/c/d6a9608af9a75d13243d217f6ce1e30e57d56ffe,||||||||||||||||||,0,0,linux/linux_kernel 5.15.150,linux/linux_kernel 5.15.150,Use industry standard APIs to implement locking mechanism.,Other,Medium,Other,Buffer Overflow,
CVE-2022-35205,"An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",,,0,0,0,0,,,,,,,CWE-617,Reachable Assertion,Base,Make sensitive open/close operation non reachable by directly user-controlled data (e.g. open/close resources); Perform input validation on user data.,Other_Vendor,Other_Product,2.38.50,,,,,,5.5,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,L,L,N,R,U,N,N,H,2,6,https://security.netapp.com/advisory/ntap-20231006-0010/|https://security.netapp.com/advisory/ntap-20231006-0010/|https://sourceware.org/bugzilla/show_bug.cgi?id=29289|https://sourceware.org/bugzilla/show_bug.cgi?id=29289|https://sourceware.org/bugzilla/show_bug.cgi?id=29289|https://security.netapp.com/advisory/ntap-20231006-0010/,|||||,0,0,gnu/binutils 2.38.50,gnu/binutils 2.38.50,Make sensitive open/close operation non reachable by directly user-controlled data (e.g. open/close resources); Perform input validation on user data.,Other,Medium,Other,Remote Code Execution (RCE),
CVE-2024-33005,"Due to the missing authorization checks in the
local systems, the admin users of SAP Web Dispatcher, SAP NetWeaver Application
Server (ABAP and Java), and SAP Content Server can impersonate other users and
may perform some unintended actions. This could lead to a low impact on
confidentiality and a high impact on the integrity and availability of the
applications.",,,0,0,0,0,,,,,,,CWE-862,Missing Authorization,Class,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7].; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",sap,Other_Product,kernel_7.54,,,,,,6.3,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:H/A:H,L,L,H,N,U,L,H,H,74,4,https://me.sap.com/notes/3438085|https://url.sap/sapsecuritypatchday|https://me.sap.com/notes/3438085|https://url.sap/sapsecuritypatchday,|||,0,0,sap/web_dispatcher kernel_7.54,sap/web_dispatcher kernel_7.54,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7].; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",Other,Medium,Other,Privilege Escalation,
CVE-2022-26777,Zoho ManageEngine Remote Access Plus before 10.1.2137.15 allows guest users to view license details.,,,0,0,0,0,,,,,,,CWE-425,Direct Request ('Forced Browsing'),Base,"Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files.; Consider using MVC based frameworks such as Struts.",Other_Vendor,Other_Product,*,,,,,,5.3,3.9,1.4,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N,N,L,N,N,U,L,N,N,2,6,https://raxis.com/blog/cve-2022-26653-and-cve-2022-26777|https://raxis.com/blog/cve-2022-26653-and-cve-2022-26777|https://www.manageengine.com/remote-desktop-management/advisory/cve-2022-26777.html|https://www.manageengine.com/remote-desktop-management/advisory/cve-2022-26777.html|https://www.manageengine.com/remote-desktop-management/advisory/cve-2022-26777.html|https://raxis.com/blog/cve-2022-26653-and-cve-2022-26777,|||||,0,0,zohocorp/manageengine_remote_access_plus *,zohocorp/manageengine_remote_access_plus *,"Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files.; Consider using MVC based frameworks such as Struts.",Other,Medium,Other,Cross-Site Scripting (XSS),
CVE-2024-49841,Memory corruption during memory assignment to headless peripheral VM due to incorrect error code handling.,,,0,0,0,0,,,,,,,CWE-390,Detection of Error Condition Without Action,Base,"Properly handle each exception. This is the recommended solution. Ensure that all exceptions are handled in such a way that you can be sure of the state of your system at any given moment.; If a function returns an error, it is important to either fix the problem and try again, alert the user that an error has happened and let the program continue, or alert the user and close and cleanup the program.; Subject the product to extensive testing to discover some of the possible instances of where/how errors or return values are not handled. Consider testing techniques such as ad hoc, equivalence partitioning, robustness and fault tolerance, mutation, and fuzzing.","Qualcomm, Inc.",Snapdragon,WSA8840,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,173,4,https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2025-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2025-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2025-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2025-bulletin.html,|||,0,0,"Qualcomm, Inc./Snapdragon WSA8840","Qualcomm, Inc./Snapdragon WSA8840","Properly handle each exception. This is the recommended solution. Ensure that all exceptions are handled in such a way that you can be sure of the state of your system at any given moment.; If a function returns an error, it is important to either fix the problem and try again, alert the user that an error has happened and let the program continue, or alert the user and close and cleanup the program.; Subject the product to extensive testing to discover some of the possible instances of where/how errors or return values are not handled. Consider testing techniques such as ad hoc, equivalence partitioning, robustness and fault tolerance, mutation, and fuzzing.",Other,High,Other,SQL Injection,
CVE-2024-20470,"A vulnerability in the web-based management interface of Cisco Small Business RV340, RV340W, RV345, and RV345P Dual WAN Gigabit VPN Routers could allow an authenticated, remote attacker to execute arbitrary code on an affected device. In order to exploit this vulnerability, the attacker must have valid admin credentials.

This vulnerability exists because the web-based management interface does not sufficiently validate user-supplied input. An attacker could exploit this vulnerability by sending crafted HTTP input to an affected device. A successful exploit could allow the attacker to execute arbitrary code as the root user on the underlying operating system.",,,0,0,0,0,,,,,,,CWE-146,Improper Neutralization of Expression/Command Delimiters,Variant,"Developers should anticipate that inter-expression and inter-command delimiters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.",Cisco,Cisco Small Business RV Series Router Firmware,1.0.03.15,,,,,,6.5,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N,N,L,H,N,U,H,H,N,20,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv34x-privesc-rce-qE33TCms|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv34x-privesc-rce-qE33TCms,|,0,0,Cisco/Cisco Small Business RV Series Router Firmware 1.0.03.15,Cisco/Cisco Small Business RV Series Router Firmware 1.0.03.15,"Developers should anticipate that inter-expression and inter-command delimiters will be injected/removed/manipulated in the input vectors of their product. Use an appropriate combination of denylists and allowlists to ensure only valid, expected and appropriate input is processed by the system.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.",Other,Medium,Other,Denial of Service (DoS),
CVE-2024-39592,"Elements of PDCE does not perform necessary
authorization checks for an authenticated user, resulting in escalation of
privileges.



This
allows an attacker to read sensitive information causing high impact on the
confidentiality of the application.",,,0,0,0,0,,,,,,,CWE-862,Missing Authorization,Class,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7].; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",SAP_SE,Other_Product,S4COREOP 104,,,,,,7.7,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N,N,L,L,N,C,H,N,N,14,6,https://me.sap.com/notes/3483344|https://me.sap.com/notes/3483344|https://url.sap/sapsecuritypatchday|https://url.sap/sapsecuritypatchday|https://url.sap/sapsecuritypatchday|https://me.sap.com/notes/3483344,|||||,0,0,SAP_SE/SAP PDCE S4COREOP 104,SAP_SE/SAP PDCE S4COREOP 104,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7].; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",Other,High,Other,Remote Code Execution (RCE),
CVE-2022-20958,"A vulnerability in the web-based management interface of Cisco BroadWorks CommPilot application could allow an unauthenticated, remote attacker to perform a server-side request forgery (SSRF) attack on an affected device.
 This vulnerability is due to insufficient validation of user-supplied input. An attacker could exploit this vulnerability by sending a crafted HTTP request to the web interface. A successful exploit could allow the attacker to obtain confidential information from the BroadWorks server and other device on the network.
    
  {{value}} [""%7b%7bvalue%7d%7d""])}]]
",,,0,0,0,0,,,,,,,CWE-36,Absolute Path Traversal,Base,,Cisco,Cisco BroadWorks,24.0 ap375533,,,,,,8.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:H,N,L,L,N,U,H,L,H,2546,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp,||,0,0,Cisco/Cisco BroadWorks 24.0 ap375533,Cisco/Cisco BroadWorks 24.0 ap375533,,Other,High,Other,Denial of Service (DoS),
CVE-2024-22317,IBM App Connect Enterprise 11.0.0.1 through 11.0.0.24 and 12.0.1.0 through 12.0.11.0 could allow a remote attacker to obtain sensitive information or cause a denial of service due to improper restriction of excessive authentication attempts.  IBM X-Force ID:  279143.,,,0,0,0,0,,,,,,,CWE-307,Improper Restriction of Excessive Authentication Attempts,Base,"Common protection mechanisms include:
                     
                        Disconnecting the user after a small number of failed attempts
                        Implementing a timeout
                        Locking out a targeted account
                        Requiring a computational task on the user's part.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator. [REF-45]",IBM,Other_Product,12.0.1.0,,,,,,9.1,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H,N,L,N,N,U,H,N,H,3,6,https://exchange.xforce.ibmcloud.com/vulnerabilities/279143|https://exchange.xforce.ibmcloud.com/vulnerabilities/279143|https://www.ibm.com/support/pages/node/7108661|https://www.ibm.com/support/pages/node/7108661|https://www.ibm.com/support/pages/node/7108661|https://exchange.xforce.ibmcloud.com/vulnerabilities/279143,|||||,0,0,IBM/App Connect Enterprise 12.0.1.0,IBM/App Connect Enterprise 12.0.1.0,"Common protection mechanisms include:
                     
                        Disconnecting the user after a small number of failed attempts
                        Implementing a timeout
                        Locking out a targeted account
                        Requiring a computational task on the user's part.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator. [REF-45]",Other,Critical,Other,Privilege Escalation,
CVE-2022-23496, Yet Another UserAgent Analyzer (Yauaa) is a java library that tries to parse and analyze the useragent string and extract as many relevant attributes as possible. Applications using the Client Hints analysis feature introduced with 7.0.0 can crash because the Yauaa library throws an ArrayIndexOutOfBoundsException. If uncaught the exception will result in a program crash. Applications that do not use this feature are not affected. Users are advised to upgrade to version 7.9.0. Users unable to upgrade may catch and discard any ArrayIndexOutOfBoundsException thrown by the Yauaa library.,,,0,0,0,0,,,,,,,CWE-755,Improper Handling of Exceptional Conditions,Class,,Other_Vendor,Other_Product,">= 7.0.0, < 7.9.0",,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,2,6,https://github.com/nielsbasjes/yauaa/commit/3017a866e2cff0d308f264b66fde4fa79e3beb9e|https://github.com/nielsbasjes/yauaa/commit/3017a866e2cff0d308f264b66fde4fa79e3beb9e|https://github.com/nielsbasjes/yauaa/security/advisories/GHSA-c4pm-63cg-9j7h|https://github.com/nielsbasjes/yauaa/security/advisories/GHSA-c4pm-63cg-9j7h|https://github.com/nielsbasjes/yauaa/security/advisories/GHSA-c4pm-63cg-9j7h|https://github.com/nielsbasjes/yauaa/commit/3017a866e2cff0d308f264b66fde4fa79e3beb9e,|||||,0,0,"nielsbasjes/yauaa >= 7.0.0, < 7.9.0","nielsbasjes/yauaa >= 7.0.0, < 7.9.0",,Other,High,Other,Information Disclosure,
CVE-2023-36832,"An Improper Handling of Exceptional Conditions vulnerability in packet processing of Juniper Networks Junos OS on MX Series allows an unauthenticated network-based attacker to send specific packets to an Aggregated Multiservices (AMS) interface on the device, causing the packet forwarding engine (PFE) to crash, resulting in a Denial of Service (DoS).  Continued receipt and processing of this packet will create a sustained Denial of Service (DoS) condition.

This issue is only triggered by packets destined to a local-interface via a service-interface (AMS).  AMS is only supported on the MS-MPC, MS-MIC, and MX-SPC3 cards.  This issue is not experienced on other types of interfaces or configurations.  Additionally, transit traffic does not trigger this issue.

This issue affects Juniper Networks Junos OS on MX Series:
All versions prior to 19.1R3-S10;
19.2 versions prior to 19.2R3-S7;
19.3 versions prior to 19.3R3-S8;
19.4 versions prior to 19.4R3-S12;
20.2 versions prior to 20.2R3-S8;
20.4 versions prior to 20.4R3-S7;
21.1 versions prior to 21.1R3-S5;
21.2 versions prior to 21.2R3-S5;
21.3 versions prior to 21.3R3-S4;
21.4 versions prior to 21.4R3-S3;
22.1 versions prior to 22.1R3-S2;
22.2 versions prior to 22.2R3;
22.3 versions prior to 22.3R2-S1, 22.3R3;
22.4 versions prior to 22.4R1-S2, 22.4R2.
",,,0,0,0,0,,,,,,,CWE-755,Improper Handling of Exceptional Conditions,Class,,Juniper Networks,Junos OS,22.4,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,14,3,https://supportportal.juniper.net/JSA71639|https://supportportal.juniper.net/JSA71639|https://supportportal.juniper.net/JSA71639,||,0,0,Juniper Networks/Junos OS 22.4,Juniper Networks/Junos OS 22.4,,Other,High,Other,Remote Code Execution (RCE),
CVE-2024-33045,Memory corruption when BTFM client sends new messages over Slimbus to ADSP.,,,0,0,0,0,,,,,,,CWE-562,Return of Stack Variable Address,Base,Use static analysis tools to spot return of the address of a stack variable.,"Qualcomm, Inc.",Snapdragon,QCA6310,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,360,2,https://docs.qualcomm.com/product/publicresources/securitybulletin/september-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/september-2024-bulletin.html,|,0,0,"Qualcomm, Inc./Snapdragon QCA6310","Qualcomm, Inc./Snapdragon QCA6310",Use static analysis tools to spot return of the address of a stack variable.,Other,High,Other,Privilege Escalation,
CVE-2022-20694,"A vulnerability in the implementation of the Resource Public Key Infrastructure (RPKI) feature of Cisco IOS XE Software could allow an unauthenticated, remote attacker to cause the Border Gateway Protocol (BGP) process to crash, resulting in a denial of service (DoS) condition. This vulnerability is due to the incorrect handling of a specific RPKI to Router (RTR) Protocol packet header. An attacker could exploit this vulnerability by compromising the RPKI validator server and sending a specifically crafted RTR packet to an affected device. Alternatively, the attacker could use man-in-the-middle techniques to impersonate the RPKI validator server and send a crafted RTR response packet over the established RTR TCP connection to the affected device. A successful exploit could allow the attacker to cause a DoS condition because the BGP process could constantly restart and BGP routing could become unstable.",,,0,0,0,0,,,,,,,CWE-617,Reachable Assertion,Base,Make sensitive open/close operation non reachable by directly user-controlled data (e.g. open/close resources); Perform input validation on user data.,cisco,ios_xe,3.7.0xas,,,,,,6.8,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:N/A:H,N,H,N,N,C,N,N,H,235,3,https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxe-rpki-dos-2EgCNeKE|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxe-rpki-dos-2EgCNeKE|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxe-rpki-dos-2EgCNeKE,||,0,0,cisco/ios_xe 3.7.0xas,cisco/ios_xe 3.7.0xas,Make sensitive open/close operation non reachable by directly user-controlled data (e.g. open/close resources); Perform input validation on user data.,Other,Medium,Other,Denial of Service (DoS),
CVE-2023-20210,"A vulnerability in Cisco BroadWorks could allow an authenticated, local attacker to elevate privileges to the root user on an affected device.
 The vulnerability is due to insufficient input validation by the operating system CLI. An attacker could exploit this vulnerability by issuing a crafted command to the affected system. A successful exploit could allow the attacker to execute commands as the root user. To exploit this vulnerability, an attacker must have valid BroadWorks administrative privileges on the affected device.",,,0,0,0,0,,,,,,,CWE-250,Execution with Unnecessary Privileges,Base,"Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF-76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE-271. Avoid weaknesses such as CWE-288 and CWE-420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators.; Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF-76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE-271. Avoid weaknesses such as CWE-288 and CWE-420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators.; Perform extensive input validation for any privileged code that must be exposed to the user and reject anything that does not fit your strict requirements.; When dropping privileges, ensure that they have been dropped successfully to avoid CWE-273. As protection mechanisms in the environment get stronger, privilege-dropping calls may fail even if it seems like they would always succeed.; If circumstances force you to run with extra privileges, then determine the minimum access level necessary. First identify the different permissions that the software and its users will need to perform their actions, such as file read and write permissions, network socket permissions, and so forth. Then explicitly allow those actions while denying all else [REF-76]. Perform extensive input validation and canonicalization to minimize the chances of introducing a separate vulnerability. This mitigation is much more prone to error than dropping the privileges in the first place.; Ensure that the software runs properly under the United States Government Configuration Baseline (USGCB) [REF-199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software.",Cisco,Cisco BroadWorks,23.0 ap383754,,,,,,6,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N,L,L,H,N,U,H,H,N,9196,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-privesc-yw4ekrXW|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-privesc-yw4ekrXW|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-privesc-yw4ekrXW,||,0,0,Cisco/Cisco BroadWorks 23.0 ap383754,Cisco/Cisco BroadWorks 23.0 ap383754,"Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF-76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE-271. Avoid weaknesses such as CWE-288 and CWE-420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators.; Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF-76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE-271. Avoid weaknesses such as CWE-288 and CWE-420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators.; Perform extensive input validation for any privileged code that must be exposed to the user and reject anything that does not fit your strict requirements.; When dropping privileges, ensure that they have been dropped successfully to avoid CWE-273. As protection mechanisms in the environment get stronger, privilege-dropping calls may fail even if it seems like they would always succeed.; If circumstances force you to run with extra privileges, then determine the minimum access level necessary. First identify the different permissions that the software and its users will need to perform their actions, such as file read and write permissions, network socket permissions, and so forth. Then explicitly allow those actions while denying all else [REF-76]. Perform extensive input validation and canonicalization to minimize the chances of introducing a separate vulnerability. This mitigation is much more prone to error than dropping the privileges in the first place.; Ensure that the software runs properly under the United States Government Configuration Baseline (USGCB) [REF-199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software.",Other,Medium,Other,Remote Code Execution (RCE),
CVE-2022-38773,Affected devices do not contain an Immutable Root of Trust in Hardware. With this the integrity of the code executed on the device can not be validated during load-time. An attacker with physical access to the device could use this to replace the boot image of the device and execute arbitrary code.,,,0,0,0,0,,,,,,,CWE-1326,Missing Immutable Root of Trust in Hardware,Base,"When architecting the system, the RoT should be designated for storage in a memory that does not allow further programming/writes.; During implementation and test, the RoT memory location should be demonstrated to not allow further programming/writes.",Siemens,Other_Product,0,,,,,,4.6,,,CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N/E:P/RL:T/RC:C,P,L,N,N,U,N,H,N,71,6,https://cert-portal.siemens.com/productcert/html/ssa-482757.html|https://cert-portal.siemens.com/productcert/html/ssa-482757.html|https://cert-portal.siemens.com/productcert/pdf/ssa-482757.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-482757.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-482757.pdf|https://cert-portal.siemens.com/productcert/html/ssa-482757.html,|||||,0,0,Siemens/SIMATIC S7-1500 CPU 1518-4 PN/DP 0,Siemens/SIMATIC S7-1500 CPU 1518-4 PN/DP 0,"When architecting the system, the RoT should be designated for storage in a memory that does not allow further programming/writes.; During implementation and test, the RoT memory location should be demonstrated to not allow further programming/writes.",Other,Medium,Other,Information Disclosure,
CVE-2022-43767,"A vulnerability has been identified in SIMATIC CP 1242-7 V2 (6GK7242-7KX31-0XE0) (All versions < V3.4.29), SIMATIC CP 1243-1 (6GK7243-1BX30-0XE0) (All versions < V3.4.29), SIMATIC CP 1243-1 DNP3 (incl. SIPLUS variants) (All versions < V3.4.29), SIMATIC CP 1243-1 IEC (incl. SIPLUS variants) (All versions < V3.4.29), SIMATIC CP 1243-7 LTE EU (6GK7243-7KX30-0XE0) (All versions < V3.4.29), SIMATIC CP 1243-7 LTE US (6GK7243-7SX30-0XE0) (All versions < V3.4.29), SIMATIC CP 1243-8 IRC (6GK7243-8RX30-0XE0) (All versions < V3.4.29), SIMATIC CP 1542SP-1 (6GK7542-6UX00-0XE0) (All versions < V2.3), SIMATIC CP 1542SP-1 IRC (6GK7542-6VX00-0XE0) (All versions < V2.3), SIMATIC CP 1543SP-1 (6GK7543-6WX00-0XE0) (All versions < V2.3), SIMATIC CP 443-1 (6GK7443-1EX30-0XE0) (All versions < V3.3), SIMATIC CP 443-1 (6GK7443-1EX30-0XE1) (All versions < V3.3), SIMATIC CP 443-1 Advanced (6GK7443-1GX30-0XE0) (All versions < V3.3), SIPLUS ET 200SP CP 1542SP-1 IRC TX RAIL (6AG2542-6VX00-4XE0) (All versions < V2.3), SIPLUS ET 200SP CP 1543SP-1 ISEC (6AG1543-6WX00-7XE0) (All versions < V2.3), SIPLUS ET 200SP CP 1543SP-1 ISEC TX RAIL (6AG2543-6WX00-4XE0) (All versions < V2.3), SIPLUS NET CP 1242-7 V2 (6AG1242-7KX31-7XE0) (All versions < V3.4.29), SIPLUS NET CP 443-1 (6AG1443-1EX30-4XE0) (All versions < V3.3), SIPLUS NET CP 443-1 Advanced (6AG1443-1GX30-4XE0) (All versions < V3.3), SIPLUS S7-1200 CP 1243-1 (6AG1243-1BX30-2AX0) (All versions < V3.4.29), SIPLUS S7-1200 CP 1243-1 RAIL (6AG2243-1BX30-1XE0) (All versions < V3.4.29), SIPLUS TIM 1531 IRC (6AG1543-1MX00-7XE0) (All versions < V2.3.6), TIM 1531 IRC (6GK7543-1MX00-0XE0) (All versions < V2.3.6). The webserver of the affected products contains a vulnerability that may lead to a denial of service condition. An attacker may cause a denial of service situation of the webserver of the affected product.",,,0,0,0,0,,,,,,,CWE-833,Deadlock,Base,,Siemens,Other_Product,0,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H/E:P/RL:O/RC:C,N,L,N,N,U,N,N,H,22,9,https://cert-portal.siemens.com/productcert/html/ssa-139628.html|https://cert-portal.siemens.com/productcert/html/ssa-139628.html|https://cert-portal.siemens.com/productcert/html/ssa-566905.html|https://cert-portal.siemens.com/productcert/html/ssa-566905.html|https://cert-portal.siemens.com/productcert/pdf/ssa-566905.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-566905.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-566905.pdf|https://cert-portal.siemens.com/productcert/html/ssa-139628.html|https://cert-portal.siemens.com/productcert/html/ssa-566905.html,||||||||,0,0,Siemens/SIMATIC CP 443-1 Advanced 0,Siemens/SIMATIC CP 443-1 Advanced 0,,Other,High,Other,Denial of Service (DoS),
CVE-2023-33111,Information disclosure when VI calibration state set by ADSP is greater than MAX_FBSP_STATE in the response payload to AFE calibration command.,,,0,0,0,0,,,,,,,CWE-129,Improper Validation of Array Index,Variant,"Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, Ada allows the programmer to constrain the values of a variable and languages such as Java and Ruby will allow the programmer to handle exceptions when an out-of-bounds index is accessed.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When accessing a user-controlled array index, use a stringent range of values that are within the target array. Make sure that you do not allow negative values to be used. That is, verify the minimum as well as the maximum of the range of acceptable values.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.","Qualcomm, Inc.",Snapdragon,QCA8081,,,,,,5.5,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N,L,L,L,N,U,H,N,N,86,3,https://docs.qualcomm.com/product/publicresources/securitybulletin/april-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/april-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/april-2024-bulletin.html,||,0,0,"Qualcomm, Inc./Snapdragon QCA8081","Qualcomm, Inc./Snapdragon QCA8081","Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, Ada allows the programmer to constrain the values of a variable and languages such as Java and Ruby will allow the programmer to handle exceptions when an out-of-bounds index is accessed.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When accessing a user-controlled array index, use a stringent range of values that are within the target array. Make sure that you do not allow negative values to be used. That is, verify the minimum as well as the maximum of the range of acceptable values.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Other,Medium,Other,Privilege Escalation,
CVE-2021-39270,"In Ping Identity RSA SecurID Integration Kit before 3.2, user impersonation can occur.",,,0,0,0,0,,,,,,,CWE-346,Origin Validation Error,Class,,Other_Vendor,Other_Product,3.0.1,,,,,,7.5,3.9,3.6,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N,N,L,N,N,U,N,H,N,5,6,https://docs.pingidentity.com/bundle/integrations/page/yqq1563995045546.html|https://docs.pingidentity.com/bundle/integrations/page/yqq1563995045546.html|https://www.pingidentity.com/en/resources/downloads/pingfederate.html|https://www.pingidentity.com/en/resources/downloads/pingfederate.html|https://www.pingidentity.com/en/resources/downloads/pingfederate.html|https://docs.pingidentity.com/bundle/integrations/page/yqq1563995045546.html,|||||,0,0,Ping Identity/RSA SecurID Integration Kit 3.0.1,Ping Identity/RSA SecurID Integration Kit 3.0.1,,Other,High,Other,Remote Code Execution (RCE),
CVE-2023-33995,Missing Authorization vulnerability in Photo Gallery Team Photo Gallery by 10Web allows Exploiting Incorrectly Configured Access Control Security Levels.This issue affects Photo Gallery by 10Web: from n/a through 1.8.15.,,,0,0,0,0,,,,,,,CWE-862,Missing Authorization,Class,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7].; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",Other_Vendor,Other_Product,*,,,,,,4.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,N,L,L,N,U,N,L,N,2,2,https://patchstack.com/database/wordpress/plugin/photo-gallery/vulnerability/wordpress-photo-gallery-by-10web-plugin-1-8-15-broken-access-control-vulnerability?_s_id=cve|https://patchstack.com/database/wordpress/plugin/photo-gallery/vulnerability/wordpress-photo-gallery-by-10web-plugin-1-8-15-broken-access-control-vulnerability?_s_id=cve,|,0,0,10web/photo_gallery *,10web/photo_gallery *,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7].; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",Other,Medium,Other,Denial of Service (DoS),
CVE-2024-54106,"Null pointer dereference vulnerability in the image decoding module
Impact: Successful exploitation of this vulnerability will affect availability.",,,0,0,0,0,,,,,,,CWE-248,Uncaught Exception,Base,,Huawei,HarmonyOS,5.0.0,,,,,,7.1,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:H,N,L,N,R,U,N,L,H,4,2,https://consumer.huawei.com/en/support/bulletin/2024/12/|https://consumer.huawei.com/en/support/bulletin/2024/12/,|,0,0,Huawei/HarmonyOS 5.0.0,Huawei/HarmonyOS 5.0.0,,Other,High,Other,Privilege Escalation,
CVE-2021-1403,"A vulnerability in the web UI feature of Cisco IOS XE Software could allow an unauthenticated, remote attacker to conduct a cross-site WebSocket hijacking (CSWSH) attack and cause a denial of service (DoS) condition on an affected device. This vulnerability is due to insufficient HTTP protections in the web UI on an affected device. An attacker could exploit this vulnerability by persuading an authenticated user of the web UI to follow a crafted link. A successful exploit could allow the attacker to corrupt memory on the affected device, forcing it to reload and causing a DoS condition.",,,0,0,0,0,,,,,,,CWE-1021,Improper Restriction of Rendered UI Layers or Frames,Base,"The use of X-Frame-Options allows developers of web content to restrict the usage of their application within the form of overlays, frames, or iFrames. The developer can indicate from which domains can frame the content.
                  The concept of X-Frame-Options is well documented, but implementation of this protection mechanism is in development to cover gaps. There is a need for allowing frames from multiple domains.; A developer can use a ""frame-breaker"" script in each page that should not be framed. This is very helpful for legacy browsers that do not support X-Frame-Options security feature previously mentioned.
                  It is also important to note that this tactic has been circumvented or bypassed. Improper usage of frames can persist in the web application through nested frames. The ""frame-breaking"" script does not intuitively account for multiple nested frames that can be presented to the user.; This defense-in-depth technique can be used to prevent the improper usage of frames in web applications. It prioritizes the valid sources of data to be loaded into the application through the usage of declarative policies. Based on which implementation of Content Security Policy is in use, the developer should use the ""frame-ancestors"" directive or the ""frame-src"" directive to mitigate this weakness. Both directives allow for the placement of restrictions when it comes to allowing embedded content.",cisco,ios_xe,16.5.3,,,,,,7.4,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:N/I:N/A:H,N,L,N,R,C,N,N,H,248,3,https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxe-cswsh-FKk9AzT5|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxe-cswsh-FKk9AzT5|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iosxe-cswsh-FKk9AzT5,||,0,0,cisco/ios_xe 16.5.3,cisco/ios_xe 16.5.3,"The use of X-Frame-Options allows developers of web content to restrict the usage of their application within the form of overlays, frames, or iFrames. The developer can indicate from which domains can frame the content.
                  The concept of X-Frame-Options is well documented, but implementation of this protection mechanism is in development to cover gaps. There is a need for allowing frames from multiple domains.; A developer can use a ""frame-breaker"" script in each page that should not be framed. This is very helpful for legacy browsers that do not support X-Frame-Options security feature previously mentioned.
                  It is also important to note that this tactic has been circumvented or bypassed. Improper usage of frames can persist in the web application through nested frames. The ""frame-breaking"" script does not intuitively account for multiple nested frames that can be presented to the user.; This defense-in-depth technique can be used to prevent the improper usage of frames in web applications. It prioritizes the valid sources of data to be loaded into the application through the usage of declarative policies. Based on which implementation of Content Security Policy is in use, the developer should use the ""frame-ancestors"" directive or the ""frame-src"" directive to mitigate this weakness. Both directives allow for the placement of restrictions when it comes to allowing embedded content.",Other,High,Other,Information Disclosure,
CVE-2024-42253,"In the Linux kernel, the following vulnerability has been resolved:

gpio: pca953x: fix pca953x_irq_bus_sync_unlock race

Ensure that `i2c_lock' is held when setting interrupt latch and mask in
pca953x_irq_bus_sync_unlock() in order to avoid races.

The other (non-probe) call site pca953x_gpio_set_multiple() ensures the
lock is held before calling pca953x_write_regs().

The problem occurred when a request raced against irq_bus_sync_unlock()
approximately once per thousand reboots on an i.MX8MP based system.

 * Normal case

   0-0022: write register AI|3a {03,02,00,00,01} Input latch P0
   0-0022: write register AI|49 {fc,fd,ff,ff,fe} Interrupt mask P0
   0-0022: write register AI|08 {ff,00,00,00,00} Output P3
   0-0022: write register AI|12 {fc,00,00,00,00} Config P3

 * Race case

   0-0022: write register AI|08 {ff,00,00,00,00} Output P3
   0-0022: write register AI|08 {03,02,00,00,01} *** Wrong register ***
   0-0022: write register AI|12 {fc,00,00,00,00} Config P3
   0-0022: write register AI|49 {fc,fd,ff,ff,fe} Interrupt mask P0",,,0,0,0,0,,,,,,,CWE-667,Improper Locking,Class,Use industry standard APIs to implement locking mechanism.,linux,linux_kernel,*,,,,,,4.7,1,3.6,CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,L,H,L,N,U,N,N,H,7,8,https://git.kernel.org/stable/c/58a5c93bd1a6e949267400080f07e57ffe05ec34|https://git.kernel.org/stable/c/bfc6444b57dc7186b6acc964705d7516cbaf3904|https://git.kernel.org/stable/c/de7cffa53149c7b48bd1bb29b02390c9f05b7f41|https://git.kernel.org/stable/c/e2ecdddca80dd845df42376e4b0197fe97018ba2|https://git.kernel.org/stable/c/58a5c93bd1a6e949267400080f07e57ffe05ec34|https://git.kernel.org/stable/c/e2ecdddca80dd845df42376e4b0197fe97018ba2|https://git.kernel.org/stable/c/de7cffa53149c7b48bd1bb29b02390c9f05b7f41|https://git.kernel.org/stable/c/bfc6444b57dc7186b6acc964705d7516cbaf3904,|||||||,0,0,linux/linux_kernel *,linux/linux_kernel *,Use industry standard APIs to implement locking mechanism.,Other,Medium,Other,Remote Code Execution (RCE),
CVE-2023-24843,Transient DOS in Modem while triggering a camping on an 5G cell.,,,0,0,0,0,,,,,,,CWE-617,Reachable Assertion,Base,Make sensitive open/close operation non reachable by directly user-controlled data (e.g. open/close resources); Perform input validation on user data.,"Qualcomm, Inc.",Snapdragon,WCD9341,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,66,3,https://www.qualcomm.com/company/product-security/bulletins/october-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/october-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/october-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon WCD9341","Qualcomm, Inc./Snapdragon WCD9341",Make sensitive open/close operation non reachable by directly user-controlled data (e.g. open/close resources); Perform input validation on user data.,Other,High,Other,Denial of Service (DoS),
CVE-2025-30881,Missing Authorization vulnerability in ThemeHunk Big Store allows Exploiting Incorrectly Configured Access Control Security Levels. This issue affects Big Store: from n/a through 2.0.8.,,,0,0,0,0,,,,,,,CWE-862,Missing Authorization,Class,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7].; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",Other_Vendor,Other_Product,,,,,,,4.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N,N,L,L,N,U,N,L,N,1,2,https://patchstack.com/database/wordpress/theme/big-store/vulnerability/wordpress-big-store-theme-2-0-8-broken-access-control-vulnerability?_s_id=cve|https://patchstack.com/database/wordpress/theme/big-store/vulnerability/wordpress-big-store-theme-2-0-8-broken-access-control-vulnerability?_s_id=cve,|,0,0,ThemeHunk/Big Store n/a,ThemeHunk/Big Store n/a,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) [REF-229] to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that access control checks are performed related to the business logic. These checks may be different than the access control checks that are applied to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor [REF-7].; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",Other,Medium,Other,Privilege Escalation,
CVE-2022-25695,"Memory corruption in MODEM due to Improper Validation of Array Index while processing GSTK Proactive commands in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables",,,0,0,0,0,,,,,,,CWE-129,Improper Validation of Array Index,Variant,"Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, Ada allows the programmer to constrain the values of a variable and languages such as Java and Ruby will allow the programmer to handle exceptions when an out-of-bounds index is accessed.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When accessing a user-controlled array index, use a stringent range of values that are within the target array. Make sure that you do not allow negative values to be used. That is, verify the minimum as well as the maximum of the range of acceptable values.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.","Qualcomm, Inc.",Other_Product,SD780G,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,197,3,https://www.qualcomm.com/company/product-security/bulletins/december-2022-bulletin|https://www.qualcomm.com/company/product-security/bulletins/december-2022-bulletin|https://www.qualcomm.com/company/product-security/bulletins/december-2022-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables SD780G","Qualcomm, Inc./Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables SD780G","Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, Ada allows the programmer to constrain the values of a variable and languages such as Java and Ruby will allow the programmer to handle exceptions when an out-of-bounds index is accessed.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When accessing a user-controlled array index, use a stringent range of values that are within the target array. Make sure that you do not allow negative values to be used. That is, verify the minimum as well as the maximum of the range of acceptable values.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Other,High,Other,Information Disclosure,
CVE-2022-40531,Memory corruption in WLAN due to incorrect type cast while sending WMI_SCAN_SCH_PRIO_TBL_CMDID message.,,,0,0,0,0,,,,,,,CWE-704,Incorrect Type Conversion or Cast,Class,,"Qualcomm, Inc.",Snapdragon,SD870,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,284,3,https://www.qualcomm.com/company/product-security/bulletins/march-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/march-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/march-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon SD870","Qualcomm, Inc./Snapdragon SD870",,Other,High,Other,Remote Code Execution (RCE),
CVE-2023-20210,"A vulnerability in Cisco BroadWorks could allow an authenticated, local attacker to elevate privileges to the root user on an affected device.
 The vulnerability is due to insufficient input validation by the operating system CLI. An attacker could exploit this vulnerability by issuing a crafted command to the affected system. A successful exploit could allow the attacker to execute commands as the root user. To exploit this vulnerability, an attacker must have valid BroadWorks administrative privileges on the affected device.",,,0,0,0,0,,,,,,,CWE-250,Execution with Unnecessary Privileges,Base,"Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF-76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE-271. Avoid weaknesses such as CWE-288 and CWE-420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators.; Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF-76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE-271. Avoid weaknesses such as CWE-288 and CWE-420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators.; Perform extensive input validation for any privileged code that must be exposed to the user and reject anything that does not fit your strict requirements.; When dropping privileges, ensure that they have been dropped successfully to avoid CWE-273. As protection mechanisms in the environment get stronger, privilege-dropping calls may fail even if it seems like they would always succeed.; If circumstances force you to run with extra privileges, then determine the minimum access level necessary. First identify the different permissions that the software and its users will need to perform their actions, such as file read and write permissions, network socket permissions, and so forth. Then explicitly allow those actions while denying all else [REF-76]. Perform extensive input validation and canonicalization to minimize the chances of introducing a separate vulnerability. This mitigation is much more prone to error than dropping the privileges in the first place.; Ensure that the software runs properly under the United States Government Configuration Baseline (USGCB) [REF-199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software.",Cisco,Cisco BroadWorks,21.0 ap241133,,,,,,6,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N,L,L,H,N,U,H,H,N,9196,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-privesc-yw4ekrXW|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-privesc-yw4ekrXW|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-privesc-yw4ekrXW,||,0,0,Cisco/Cisco BroadWorks 21.0 ap241133,Cisco/Cisco BroadWorks 21.0 ap241133,"Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF-76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE-271. Avoid weaknesses such as CWE-288 and CWE-420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators.; Identify the functionality that requires additional privileges, such as access to privileged operating system resources. Wrap and centralize this functionality if possible, and isolate the privileged code as much as possible from other code [REF-76]. Raise privileges as late as possible, and drop them as soon as possible to avoid CWE-271. Avoid weaknesses such as CWE-288 and CWE-420 by protecting all possible communication channels that could interact with the privileged code, such as a secondary socket that is only intended to be accessed by administrators.; Perform extensive input validation for any privileged code that must be exposed to the user and reject anything that does not fit your strict requirements.; When dropping privileges, ensure that they have been dropped successfully to avoid CWE-273. As protection mechanisms in the environment get stronger, privilege-dropping calls may fail even if it seems like they would always succeed.; If circumstances force you to run with extra privileges, then determine the minimum access level necessary. First identify the different permissions that the software and its users will need to perform their actions, such as file read and write permissions, network socket permissions, and so forth. Then explicitly allow those actions while denying all else [REF-76]. Perform extensive input validation and canonicalization to minimize the chances of introducing a separate vulnerability. This mitigation is much more prone to error than dropping the privileges in the first place.; Ensure that the software runs properly under the United States Government Configuration Baseline (USGCB) [REF-199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software.",Other,Medium,Other,Remote Code Execution (RCE),
CVE-2024-31201,A “CWE-428: Unquoted Search Path or Element” affects the ThermoscanIP_Scrutation service. Such misconfiguration could be abused in scenarios where incorrect permissions were assigned to the C:\ path to attempt a privilege escalation on the local machine.,,,0,0,0,0,,,,,,,CWE-428,Unquoted Search Path or Element,Base,"Properly quote the full search path before executing a program on the system.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.",Other_Vendor,Other_Product,20211103,,,,,,6.5,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H,L,L,H,R,U,H,H,H,2,2,https://www.nozominetworks.com/labs/vulnerability-advisories-cve-2024-31201|https://www.nozominetworks.com/labs/vulnerability-advisories-cve-2024-31201,|,0,0,Plug&Track/Thermoscan IP 20211103,Plug&Track/Thermoscan IP 20211103,"Properly quote the full search path before executing a program on the system.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.",Other,Medium,Other,Denial of Service (DoS),
CVE-2022-49315,"In the Linux kernel, the following vulnerability has been resolved:

drivers: staging: rtl8192e: Fix deadlock in rtllib_beacons_stop()

There is a deadlock in rtllib_beacons_stop(), which is shown
below:

   (Thread 1)              |      (Thread 2)
                           | rtllib_send_beacon()
rtllib_beacons_stop()      |  mod_timer()
 spin_lock_irqsave() //(1) |  (wait a time)
 ...                       | rtllib_send_beacon_cb()
 del_timer_sync()          |  spin_lock_irqsave() //(2)
 (wait timer to stop)      |  ...

We hold ieee->beacon_lock in position (1) of thread 1 and
use del_timer_sync() to wait timer to stop, but timer handler
also need ieee->beacon_lock in position (2) of thread 2.
As a result, rtllib_beacons_stop() will block forever.

This patch extracts del_timer_sync() from the protection of
spin_lock_irqsave(), which could let timer handler to obtain
the needed lock.",,,0,0,0,0,,,,,,,CWE-667,Improper Locking,Class,Use industry standard APIs to implement locking mechanism.,Linux,Linux,4.19.247,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,11,18,https://git.kernel.org/stable/c/08bacf871c019163ccd1389d0bc957a43324967a|https://git.kernel.org/stable/c/0f69d7d5e918aa43423d86bd17ddb11b1b5e8ada|https://git.kernel.org/stable/c/381045dc64d23a2229c47c5524c06bfc33d34446|https://git.kernel.org/stable/c/4681129fda9e8555392eaaadb239ec6a6e2b3e12|https://git.kernel.org/stable/c/46c861009bf437a18417df24cea0d181741b7d72|https://git.kernel.org/stable/c/64b05fa212c7e4d057676e8b7e7120c6eb2f615b|https://git.kernel.org/stable/c/9b6bdbd9337de3917945847bde262a34a87a6303|https://git.kernel.org/stable/c/fef451f0fbbe85dbd2962b18379d02e2965610db|https://git.kernel.org/stable/c/ffd4c4d5293e4985092ea45ba21cad9326e2e434|https://git.kernel.org/stable/c/4681129fda9e8555392eaaadb239ec6a6e2b3e12|https://git.kernel.org/stable/c/381045dc64d23a2229c47c5524c06bfc33d34446|https://git.kernel.org/stable/c/08bacf871c019163ccd1389d0bc957a43324967a|https://git.kernel.org/stable/c/64b05fa212c7e4d057676e8b7e7120c6eb2f615b|https://git.kernel.org/stable/c/0f69d7d5e918aa43423d86bd17ddb11b1b5e8ada|https://git.kernel.org/stable/c/fef451f0fbbe85dbd2962b18379d02e2965610db|https://git.kernel.org/stable/c/46c861009bf437a18417df24cea0d181741b7d72|https://git.kernel.org/stable/c/ffd4c4d5293e4985092ea45ba21cad9326e2e434|https://git.kernel.org/stable/c/9b6bdbd9337de3917945847bde262a34a87a6303,|||||||||||||||||,0,0,Linux/Linux 4.19.247,Linux/Linux 4.19.247,Use industry standard APIs to implement locking mechanism.,Other,Medium,Other,Information Disclosure,
CVE-2024-0567,"A vulnerability was found in GnuTLS, where a cockpit (which uses gnuTLS) rejects a certificate chain with distributed trust. This issue occurs when validating a certificate chain with cockpit-certificate-ensure. This flaw allows an unauthenticated, remote client or attacker to initiate a denial of service attack.",,,0,0,0,0,,,,,,,CWE-347,Improper Verification of Cryptographic Signature,Base,,Red Hat,Other_Product,v5.8.6-5,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,43,28,http://www.openwall.com/lists/oss-security/2024/01/19/3|https://access.redhat.com/errata/RHSA-2024:0533|https://access.redhat.com/errata/RHSA-2024:0533|https://access.redhat.com/errata/RHSA-2024:1082|https://access.redhat.com/errata/RHSA-2024:1082|https://access.redhat.com/errata/RHSA-2024:1383|https://access.redhat.com/errata/RHSA-2024:1383|https://access.redhat.com/errata/RHSA-2024:2094|https://access.redhat.com/errata/RHSA-2024:2094|https://access.redhat.com/security/cve/CVE-2024-0567|https://access.redhat.com/security/cve/CVE-2024-0567|https://bugzilla.redhat.com/show_bug.cgi?id=2258544|https://bugzilla.redhat.com/show_bug.cgi?id=2258544|https://gitlab.com/gnutls/gnutls/-/issues/1521|https://gitlab.com/gnutls/gnutls/-/issues/1521|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7ZEIOLORQ7N6WRPFXZSYDL2MC4LP7VFV/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GNXKVR5YNUEBNHAHM5GSYKBZX4W2HMN2/|https://lists.gnupg.org/pipermail/gnutls-help/2024-January/004841.html|https://lists.gnupg.org/pipermail/gnutls-help/2024-January/004841.html|https://security.netapp.com/advisory/ntap-20240202-0011/|https://access.redhat.com/errata/RHSA-2024:0533|https://access.redhat.com/errata/RHSA-2024:1082|https://access.redhat.com/errata/RHSA-2024:1383|https://access.redhat.com/errata/RHSA-2024:2094|https://access.redhat.com/security/cve/CVE-2024-0567|https://bugzilla.redhat.com/show_bug.cgi?id=2258544|https://gitlab.com/gnutls/gnutls/-/issues/1521|https://lists.gnupg.org/pipermail/gnutls-help/2024-January/004841.html,|||||||||||||||||||||||||||,0,0,Red Hat/RHOL-5.8-RHEL-9 v5.8.6-5,Red Hat/RHOL-5.8-RHEL-9 v5.8.6-5,,Other,High,Other,Privilege Escalation,
CVE-2024-53127,"In the Linux kernel, the following vulnerability has been resolved:

Revert ""mmc: dw_mmc: Fix IDMAC operation with pages bigger than 4K""

The commit 8396c793ffdf (""mmc: dw_mmc: Fix IDMAC operation with pages
bigger than 4K"") increased the max_req_size, even for 4K pages, causing
various issues:
- Panic booting the kernel/rootfs from an SD card on Rockchip RK3566
- Panic booting the kernel/rootfs from an SD card on StarFive JH7100
- ""swiotlb buffer is full"" and data corruption on StarFive JH7110

At this stage no fix have been found, so it's probably better to just
revert the change.

This reverts commit 8396c793ffdf28bb8aee7cfe0891080f8cab7890.",,,0,0,0,0,,,,,,,,,,,Linux,Linux,8396c793ffdf28bb8aee7cfe0891080f8cab7890,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,19,16,https://git.kernel.org/stable/c/00bff71745bc3583bd5ca59be91e0ee1d27f1944|https://git.kernel.org/stable/c/1635e407a4a64d08a8517ac59ca14ad4fc785e75|https://git.kernel.org/stable/c/47693ba35bccaa16efa465159a1c12d78258349e|https://git.kernel.org/stable/c/56de724c58c07a7ca3aac027cfd2ccb184ed9e4e|https://git.kernel.org/stable/c/8f9416147d7ed414109d3501f1cb3d7a1735b25a|https://git.kernel.org/stable/c/938c13740f8b555986e53c0fcbaf00dcd1fabd4c|https://git.kernel.org/stable/c/a4685366f07448420badb710ff5c12aaaadf63ad|https://git.kernel.org/stable/c/f701eb601470bfc0a551913ce5f6ebaa770f0ce0|https://git.kernel.org/stable/c/00bff71745bc3583bd5ca59be91e0ee1d27f1944|https://git.kernel.org/stable/c/47693ba35bccaa16efa465159a1c12d78258349e|https://git.kernel.org/stable/c/938c13740f8b555986e53c0fcbaf00dcd1fabd4c|https://git.kernel.org/stable/c/f701eb601470bfc0a551913ce5f6ebaa770f0ce0|https://git.kernel.org/stable/c/8f9416147d7ed414109d3501f1cb3d7a1735b25a|https://git.kernel.org/stable/c/56de724c58c07a7ca3aac027cfd2ccb184ed9e4e|https://git.kernel.org/stable/c/a4685366f07448420badb710ff5c12aaaadf63ad|https://git.kernel.org/stable/c/1635e407a4a64d08a8517ac59ca14ad4fc785e75,|||||||||||||||,0,0,Linux/Linux 8396c793ffdf28bb8aee7cfe0891080f8cab7890,Linux/Linux 8396c793ffdf28bb8aee7cfe0891080f8cab7890,,Unknown,Medium,Unknown,Remote Code Execution (RCE),
CVE-2024-46734,"In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix race between direct IO write and fsync when using same fd

If we have 2 threads that are using the same file descriptor and one of
them is doing direct IO writes while the other is doing fsync, we have a
race where we can end up either:

1) Attempt a fsync without holding the inode's lock, triggering an
   assertion failures when assertions are enabled;

2) Do an invalid memory access from the fsync task because the file private
   points to memory allocated on stack by the direct IO task and it may be
   used by the fsync task after the stack was destroyed.

The race happens like this:

1) A user space program opens a file descriptor with O_DIRECT;

2) The program spawns 2 threads using libpthread for example;

3) One of the threads uses the file descriptor to do direct IO writes,
   while the other calls fsync using the same file descriptor.

4) Call task A the thread doing direct IO writes and task B the thread
   doing fsyncs;

5) Task A does a direct IO write, and at btrfs_direct_write() sets the
   file's private to an on stack allocated private with the member
   'fsync_skip_inode_lock' set to true;

6) Task B enters btrfs_sync_file() and sees that there's a private
   structure associated to the file which has 'fsync_skip_inode_lock' set
   to true, so it skips locking the inode's VFS lock;

7) Task A completes the direct IO write, and resets the file's private to
   NULL since it had no prior private and our private was stack allocated.
   Then it unlocks the inode's VFS lock;

8) Task B enters btrfs_get_ordered_extents_for_logging(), then the
   assertion that checks the inode's VFS lock is held fails, since task B
   never locked it and task A has already unlocked it.

The stack trace produced is the following:

   assertion failed: inode_is_locked(&inode->vfs_inode), in fs/btrfs/ordered-data.c:983
   ------------[ cut here ]------------
   kernel BUG at fs/btrfs/ordered-data.c:983!
   Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI
   CPU: 9 PID: 5072 Comm: worker Tainted: G     U     OE      6.10.5-1-default #1 openSUSE Tumbleweed 69f48d427608e1c09e60ea24c6c55e2ca1b049e8
   Hardware name: Acer Predator PH315-52/Covini_CFS, BIOS V1.12 07/28/2020
   RIP: 0010:btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs]
   Code: 50 d6 86 c0 e8 (...)
   RSP: 0018:ffff9e4a03dcfc78 EFLAGS: 00010246
   RAX: 0000000000000054 RBX: ffff9078a9868e98 RCX: 0000000000000000
   RDX: 0000000000000000 RSI: ffff907dce4a7800 RDI: ffff907dce4a7800
   RBP: ffff907805518800 R08: 0000000000000000 R09: ffff9e4a03dcfb38
   R10: ffff9e4a03dcfb30 R11: 0000000000000003 R12: ffff907684ae7800
   R13: 0000000000000001 R14: ffff90774646b600 R15: 0000000000000000
   FS:  00007f04b96006c0(0000) GS:ffff907dce480000(0000) knlGS:0000000000000000
   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
   CR2: 00007f32acbfc000 CR3: 00000001fd4fa005 CR4: 00000000003726f0
   Call Trace:
    <TASK>
    ? __die_body.cold+0x14/0x24
    ? die+0x2e/0x50
    ? do_trap+0xca/0x110
    ? do_error_trap+0x6a/0x90
    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]
    ? exc_invalid_op+0x50/0x70
    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]
    ? asm_exc_invalid_op+0x1a/0x20
    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]
    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]
    btrfs_sync_file+0x21a/0x4d0 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]
    ? __seccomp_filter+0x31d/0x4f0
    __x64_sys_fdatasync+0x4f/0x90
    do_syscall_64+0x82/0x160
    ? do_futex+0xcb/0x190
    ? __x64_sys_futex+0x10e/0x1d0
    ? switch_fpu_return+0x4f/0xd0
    ? syscall_exit_to_user_mode+0x72/0x220
    ? do_syscall_64+0x8e/0x160
    ? syscall_exit_to_user_mod
---truncated---",,,0,0,0,0,,,,,,,,,,,Linux,Linux,6.1.105,,,,,,0,,,,,,,,,,,,9,10,https://git.kernel.org/stable/c/01681aa609b5f110502f56c4e3b2938efcf4a5bc|https://git.kernel.org/stable/c/7b5595f33c3c273613b590892a578d78186bb400|https://git.kernel.org/stable/c/cd3087582e4fa36e89be4e6f859e75a4400292b4|https://git.kernel.org/stable/c/cd9253c23aedd61eb5ff11f37a36247cd46faf86|https://git.kernel.org/stable/c/d116a0b0e02f395cedfb8c725bd67480aa7c428c|https://git.kernel.org/stable/c/d116a0b0e02f395cedfb8c725bd67480aa7c428c|https://git.kernel.org/stable/c/cd3087582e4fa36e89be4e6f859e75a4400292b4|https://git.kernel.org/stable/c/7b5595f33c3c273613b590892a578d78186bb400|https://git.kernel.org/stable/c/01681aa609b5f110502f56c4e3b2938efcf4a5bc|https://git.kernel.org/stable/c/cd9253c23aedd61eb5ff11f37a36247cd46faf86,|||||||||,0,0,Linux/Linux 6.1.105,Linux/Linux 6.1.105,,Unknown,,Unknown,Denial of Service (DoS),
CVE-2022-22045,,,,0,0,0,0,,,,,,,,,,,microsoft,windows_10,20h2,,,,,,7.8,,,CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H/E:U/RL:O/RC:C,L,H,L,N,C,H,H,H,25,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-22045|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-22045|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-22045,||,0,0,microsoft/windows_10 20h2,microsoft/windows_10 20h2,,Unknown,High,Unknown,Information Disclosure,
CVE-2021-47313,"In the Linux kernel, the following vulnerability has been resolved:

cpufreq: CPPC: Fix potential memleak in cppc_cpufreq_cpu_init

It's a classic example of memleak, we allocate something, we fail and
never free the resources.

Make sure we free all resources on policy ->init() failures.",,,0,0,0,0,,,,,,,,,,,Linux,Linux,a28b2bfc099c6b9caa6ef697660408e076a32019,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,7,9,https://git.kernel.org/stable/c/b775383355755885b19d2acef977f1ca132e80a3|https://git.kernel.org/stable/c/b775383355755885b19d2acef977f1ca132e80a3|https://git.kernel.org/stable/c/e1b2b2b61d30d7ce057ec17237c217d152ed97f2|https://git.kernel.org/stable/c/e1b2b2b61d30d7ce057ec17237c217d152ed97f2|https://git.kernel.org/stable/c/fe2535a44904a77615a3af8e8fd7dafb98fb0e1b|https://git.kernel.org/stable/c/fe2535a44904a77615a3af8e8fd7dafb98fb0e1b|https://git.kernel.org/stable/c/b775383355755885b19d2acef977f1ca132e80a3|https://git.kernel.org/stable/c/e1b2b2b61d30d7ce057ec17237c217d152ed97f2|https://git.kernel.org/stable/c/fe2535a44904a77615a3af8e8fd7dafb98fb0e1b,||||||||,0,0,Linux/Linux a28b2bfc099c6b9caa6ef697660408e076a32019,Linux/Linux a28b2bfc099c6b9caa6ef697660408e076a32019,,Unknown,High,Unknown,Remote Code Execution (RCE),
CVE-2022-35750,,,,0,0,0,0,,,,,,,,,,,Microsoft,Windows Server 2008 Service Pack 2 (Server Core installation),6.0.6003.0,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,L,L,L,N,U,H,H,H,43,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-35750|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-35750|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-35750,||,0,0,Microsoft/Windows Server 2008 Service Pack 2 (Server Core installation) 6.0.6003.0,Microsoft/Windows Server 2008 Service Pack 2 (Server Core installation) 6.0.6003.0,,Unknown,High,Unknown,Privilege Escalation,
CVE-2022-43997,Incorrect access control in Aternity agent in Riverbed Aternity before 12.1.4.27 allows for local privilege escalation. There is an insufficiently protected handle to the A180AG.exe SYSTEM process with PROCESS_ALL_ACCESS rights.,,,0,0,0,0,,,,,,,,,,,Other_Vendor,Other_Product,*,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,2,6,https://gist.github.com/jackullrich/21fcfe75aeb5e18c60b80e684b83d741|https://gist.github.com/jackullrich/21fcfe75aeb5e18c60b80e684b83d741|https://winternl.com/cve-2022-43997/|https://winternl.com/cve-2022-43997/|https://winternl.com/cve-2022-43997/|https://gist.github.com/jackullrich/21fcfe75aeb5e18c60b80e684b83d741,|||||,0,0,aternity/aternity *,aternity/aternity *,,Unknown,High,Unknown,Denial of Service (DoS),
CVE-2024-23082,"ThreeTen Backport v1.6.8 was discovered to contain an integer overflow via the component org.threeten.bp.format.DateTimeFormatter::parse(CharSequence, ParsePosition). NOTE: this is disputed by multiple third parties who believe there was not reasonable evidence to determine the existence of a vulnerability. The submission may have been based on a tool that is not sufficiently robust for vulnerability identification.",,,0,0,0,0,,,,,,,,,,,Other_Vendor,Other_Product,,,,,,,0,,,,,,,,,,,,1,9,http://threeten.com|http://threeten.com|https://gist.github.com/LLM4IG/d2618f5f4e5ac37eb75cff5617e58b90|https://gist.github.com/LLM4IG/d2618f5f4e5ac37eb75cff5617e58b90|https://github.com/ThreeTen/threetenbp|https://github.com/ThreeTen/threetenbp|http://threeten.com|https://github.com/ThreeTen/threetenbp|https://gist.github.com/LLM4IG/d2618f5f4e5ac37eb75cff5617e58b90,||||||||,0,0,n/a/n/a n/a,n/a/n/a n/a,,Unknown,,Unknown,Remote Code Execution (RCE),
CVE-2021-43219,,,,0,0,0,0,,,,,,,,,,,microsoft,windows_server_2016,2004,,,,,,7.4,,,CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H/E:U/RL:O/RC:C,A,L,N,N,C,N,N,H,22,3,https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-43219|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-43219|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-43219,||,0,0,microsoft/windows_server_2016 2004,microsoft/windows_server_2016 2004,,Unknown,High,Unknown,Information Disclosure,
CVE-2023-21526,,,,0,0,0,0,,,,,,,,,,,microsoft,windows_server_2008,r2,,,,,,7.4,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N/E:U/RL:O/RC:C,N,H,N,N,U,H,H,N,36,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-21526|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-21526|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-21526,||,0,0,microsoft/windows_server_2008 r2,microsoft/windows_server_2008 r2,,Unknown,High,Unknown,Privilege Escalation,
CVE-2022-49553,"In the Linux kernel, the following vulnerability has been resolved:

fs/ntfs3: validate BOOT sectors_per_clusters

When the NTFS BOOT sectors_per_clusters field is > 0x80, it represents a
shift value.  Make sure that the shift value is not too large before using
it (NTFS max cluster size is 2MB).  Return -EVINVAL if it too large.

This prevents negative shift values and shift values that are larger than
the field size.

Prevents this UBSAN error:

 UBSAN: shift-out-of-bounds in ../fs/ntfs3/super.c:673:16
 shift exponent -192 is negative",,,0,0,0,0,,,,,,,,,,,Linux,Linux,82cae269cfa953032fbb8980a7d554d60fb00b17,,,,,,0,,,,,,,,,,,,7,8,https://git.kernel.org/stable/c/4746c49b11b2403f5b5b07c6eac9e60663dcd9a3|https://git.kernel.org/stable/c/58cf68a1886d14ffdc5c892ce483a82156769e88|https://git.kernel.org/stable/c/a2b6986316a2d106f6951e76db70fa4b2fde64a9|https://git.kernel.org/stable/c/a3b774342fa752a5290c0de36375289dfcf4a260|https://git.kernel.org/stable/c/58cf68a1886d14ffdc5c892ce483a82156769e88|https://git.kernel.org/stable/c/4746c49b11b2403f5b5b07c6eac9e60663dcd9a3|https://git.kernel.org/stable/c/a2b6986316a2d106f6951e76db70fa4b2fde64a9|https://git.kernel.org/stable/c/a3b774342fa752a5290c0de36375289dfcf4a260,|||||||,0,0,Linux/Linux 82cae269cfa953032fbb8980a7d554d60fb00b17,Linux/Linux 82cae269cfa953032fbb8980a7d554d60fb00b17,,Unknown,,Unknown,Remote Code Execution (RCE),
CVE-2023-44487,"The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.",,,0,0,0,0,,,,,,,,,,,cisco,Other_Product,*,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,197,427,http://www.openwall.com/lists/oss-security/2023/10/10/6|http://www.openwall.com/lists/oss-security/2023/10/10/7|http://www.openwall.com/lists/oss-security/2023/10/13/4|http://www.openwall.com/lists/oss-security/2023/10/13/4|http://www.openwall.com/lists/oss-security/2023/10/13/9|http://www.openwall.com/lists/oss-security/2023/10/13/9|http://www.openwall.com/lists/oss-security/2023/10/18/4|http://www.openwall.com/lists/oss-security/2023/10/18/4|http://www.openwall.com/lists/oss-security/2023/10/18/8|http://www.openwall.com/lists/oss-security/2023/10/18/8|http://www.openwall.com/lists/oss-security/2023/10/19/6|http://www.openwall.com/lists/oss-security/2023/10/19/6|http://www.openwall.com/lists/oss-security/2023/10/20/8|http://www.openwall.com/lists/oss-security/2023/10/20/8|https://access.redhat.com/security/cve/cve-2023-44487|https://access.redhat.com/security/cve/cve-2023-44487|https://arstechnica.com/security/2023/10/how-ddosers-used-the-http-2-protocol-to-deliver-attacks-of-unprecedented-size/|https://arstechnica.com/security/2023/10/how-ddosers-used-the-http-2-protocol-to-deliver-attacks-of-unprecedented-size/|https://aws.amazon.com/security/security-bulletins/AWS-2023-011/|https://aws.amazon.com/security/security-bulletins/AWS-2023-011/|https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/|https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/|https://blog.cloudflare.com/zero-day-rapid-reset-http2-record-breaking-ddos-attack/|https://blog.cloudflare.com/zero-day-rapid-reset-http2-record-breaking-ddos-attack/|https://blog.litespeedtech.com/2023/10/11/rapid-reset-http-2-vulnerablilty/|https://blog.litespeedtech.com/2023/10/11/rapid-reset-http-2-vulnerablilty/|https://blog.qualys.com/vulnerabilities-threat-research/2023/10/10/cve-2023-44487-http-2-rapid-reset-attack|https://blog.qualys.com/vulnerabilities-threat-research/2023/10/10/cve-2023-44487-http-2-rapid-reset-attack|https://blog.vespa.ai/cve-2023-44487/|https://blog.vespa.ai/cve-2023-44487/|https://bugzilla.proxmox.com/show_bug.cgi?id=4988|https://bugzilla.proxmox.com/show_bug.cgi?id=4988|https://bugzilla.redhat.com/show_bug.cgi?id=2242803|https://bugzilla.redhat.com/show_bug.cgi?id=2242803|https://bugzilla.suse.com/show_bug.cgi?id=1216123|https://bugzilla.suse.com/show_bug.cgi?id=1216123|https://cgit.freebsd.org/ports/commit/?id=c64c329c2c1752f46b73e3e6ce9f4329be6629f9|https://cgit.freebsd.org/ports/commit/?id=c64c329c2c1752f46b73e3e6ce9f4329be6629f9|https://cloud.google.com/blog/products/identity-security/google-cloud-mitigated-largest-ddos-attack-peaking-above-398-million-rps/|https://cloud.google.com/blog/products/identity-security/google-cloud-mitigated-largest-ddos-attack-peaking-above-398-million-rps/|https://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack|https://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack|https://community.traefik.io/t/is-traefik-vulnerable-to-cve-2023-44487/20125|https://community.traefik.io/t/is-traefik-vulnerable-to-cve-2023-44487/20125|https://discuss.hashicorp.com/t/hcsec-2023-32-vault-consul-and-boundary-affected-by-http-2-rapid-reset-denial-of-service-vulnerability-cve-2023-44487/59715|https://discuss.hashicorp.com/t/hcsec-2023-32-vault-consul-and-boundary-affected-by-http-2-rapid-reset-denial-of-service-vulnerability-cve-2023-44487/59715|https://edg.io/lp/blog/resets-leaks-ddos-and-the-tale-of-a-hidden-cve|https://edg.io/lp/blog/resets-leaks-ddos-and-the-tale-of-a-hidden-cve|https://forums.swift.org/t/swift-nio-http2-security-update-cve-2023-44487-http-2-dos/67764|https://forums.swift.org/t/swift-nio-http2-security-update-cve-2023-44487-http-2-dos/67764|https://gist.github.com/adulau/7c2bfb8e9cdbe4b35a5e131c66a0c088|https://gist.github.com/adulau/7c2bfb8e9cdbe4b35a5e131c66a0c088|https://github.com/advisories/GHSA-qppj-fm5r-hxr3|https://github.com/advisories/GHSA-qppj-fm5r-hxr3|https://github.com/advisories/GHSA-vx74-f528-fxqg|https://github.com/advisories/GHSA-vx74-f528-fxqg|https://github.com/advisories/GHSA-xpw8-rcwv-8f8p|https://github.com/advisories/GHSA-xpw8-rcwv-8f8p|https://github.com/akka/akka-http/issues/4323|https://github.com/akka/akka-http/issues/4323|https://github.com/alibaba/tengine/issues/1872|https://github.com/alibaba/tengine/issues/1872|https://github.com/apache/apisix/issues/10320|https://github.com/apache/apisix/issues/10320|https://github.com/apache/httpd/blob/afcdbeebbff4b0c50ea26cdd16e178c0d1f24152/modules/http2/h2_mplx.c#L1101-L1113|https://github.com/apache/httpd/blob/afcdbeebbff4b0c50ea26cdd16e178c0d1f24152/modules/http2/h2_mplx.c#L1101-L1113|https://github.com/apache/httpd-site/pull/10|https://github.com/apache/httpd-site/pull/10|https://github.com/apache/tomcat/tree/main/java/org/apache/coyote/http2|https://github.com/apache/tomcat/tree/main/java/org/apache/coyote/http2|https://github.com/apache/trafficserver/pull/10564|https://github.com/apache/trafficserver/pull/10564|https://github.com/arkrwn/PoC/tree/main/CVE-2023-44487|https://github.com/arkrwn/PoC/tree/main/CVE-2023-44487|https://github.com/Azure/AKS/issues/3947|https://github.com/Azure/AKS/issues/3947|https://github.com/bcdannyboy/CVE-2023-44487|https://github.com/bcdannyboy/CVE-2023-44487|https://github.com/caddyserver/caddy/issues/5877|https://github.com/caddyserver/caddy/issues/5877|https://github.com/caddyserver/caddy/releases/tag/v2.7.5|https://github.com/caddyserver/caddy/releases/tag/v2.7.5|https://github.com/dotnet/announcements/issues/277|https://github.com/dotnet/announcements/issues/277|https://github.com/dotnet/core/blob/e4613450ea0da7fd2fc6b61dfb2c1c1dec1ce9ec/release-notes/6.0/6.0.23/6.0.23.md?plain=1#L73|https://github.com/dotnet/core/blob/e4613450ea0da7fd2fc6b61dfb2c1c1dec1ce9ec/release-notes/6.0/6.0.23/6.0.23.md?plain=1#L73|https://github.com/eclipse/jetty.project/issues/10679|https://github.com/eclipse/jetty.project/issues/10679|https://github.com/envoyproxy/envoy/pull/30055|https://github.com/envoyproxy/envoy/pull/30055|https://github.com/etcd-io/etcd/issues/16740|https://github.com/etcd-io/etcd/issues/16740|https://github.com/facebook/proxygen/pull/466|https://github.com/facebook/proxygen/pull/466|https://github.com/golang/go/issues/63417|https://github.com/golang/go/issues/63417|https://github.com/grpc/grpc/releases/tag/v1.59.2|https://github.com/grpc/grpc-go/pull/6703|https://github.com/grpc/grpc-go/pull/6703|https://github.com/h2o/h2o/pull/3291|https://github.com/h2o/h2o/pull/3291|https://github.com/h2o/h2o/security/advisories/GHSA-2m7v-gc89-fjqf|https://github.com/h2o/h2o/security/advisories/GHSA-2m7v-gc89-fjqf|https://github.com/haproxy/haproxy/issues/2312|https://github.com/haproxy/haproxy/issues/2312|https://github.com/icing/mod_h2/blob/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a/mod_http2/README.md?plain=1#L239-L244|https://github.com/icing/mod_h2/blob/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a/mod_http2/README.md?plain=1#L239-L244|https://github.com/junkurihara/rust-rpxy/issues/97|https://github.com/junkurihara/rust-rpxy/issues/97|https://github.com/kazu-yamamoto/http2/commit/f61d41a502bd0f60eb24e1ce14edc7b6df6722a1|https://github.com/kazu-yamamoto/http2/commit/f61d41a502bd0f60eb24e1ce14edc7b6df6722a1|https://github.com/kazu-yamamoto/http2/issues/93|https://github.com/kazu-yamamoto/http2/issues/93|https://github.com/Kong/kong/discussions/11741|https://github.com/Kong/kong/discussions/11741|https://github.com/kubernetes/kubernetes/pull/121120|https://github.com/kubernetes/kubernetes/pull/121120|https://github.com/line/armeria/pull/5232|https://github.com/line/armeria/pull/5232|https://github.com/linkerd/website/pull/1695/commits/4b9c6836471bc8270ab48aae6fd2181bc73fd632|https://github.com/linkerd/website/pull/1695/commits/4b9c6836471bc8270ab48aae6fd2181bc73fd632|https://github.com/micrictor/http2-rst-stream|https://github.com/micrictor/http2-rst-stream|https://github.com/microsoft/CBL-Mariner/pull/6381|https://github.com/microsoft/CBL-Mariner/pull/6381|https://github.com/netty/netty/commit/58f75f665aa81a8cbcf6ffa74820042a285c5e61|https://github.com/netty/netty/commit/58f75f665aa81a8cbcf6ffa74820042a285c5e61|https://github.com/nghttp2/nghttp2/pull/1961|https://github.com/nghttp2/nghttp2/pull/1961|https://github.com/nghttp2/nghttp2/releases/tag/v1.57.0|https://github.com/nghttp2/nghttp2/releases/tag/v1.57.0|https://github.com/ninenines/cowboy/issues/1615|https://github.com/ninenines/cowboy/issues/1615|https://github.com/nodejs/node/pull/50121|https://github.com/nodejs/node/pull/50121|https://github.com/openresty/openresty/issues/930|https://github.com/openresty/openresty/issues/930|https://github.com/opensearch-project/data-prepper/issues/3474|https://github.com/opensearch-project/data-prepper/issues/3474|https://github.com/oqtane/oqtane.framework/discussions/3367|https://github.com/oqtane/oqtane.framework/discussions/3367|https://github.com/projectcontour/contour/pull/5826|https://github.com/projectcontour/contour/pull/5826|https://github.com/tempesta-tech/tempesta/issues/1986|https://github.com/tempesta-tech/tempesta/issues/1986|https://github.com/varnishcache/varnish-cache/issues/3996|https://github.com/varnishcache/varnish-cache/issues/3996|https://groups.google.com/g/golang-announce/c/iNNxDTCjZvo|https://groups.google.com/g/golang-announce/c/iNNxDTCjZvo|https://istio.io/latest/news/security/istio-security-2023-004/|https://istio.io/latest/news/security/istio-security-2023-004/|https://linkerd.io/2023/10/12/linkerd-cve-2023-44487/|https://linkerd.io/2023/10/12/linkerd-cve-2023-44487/|https://lists.apache.org/thread/5py8h42mxfsn8l1wy6o41xwhsjlsd87q|https://lists.apache.org/thread/5py8h42mxfsn8l1wy6o41xwhsjlsd87q|https://lists.debian.org/debian-lts-announce/2023/10/msg00020.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00020.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00023.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00023.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00024.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00024.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00045.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00045.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00047.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00047.html|https://lists.debian.org/debian-lts-announce/2023/11/msg00001.html|https://lists.debian.org/debian-lts-announce/2023/11/msg00001.html|https://lists.debian.org/debian-lts-announce/2023/11/msg00012.html|https://lists.debian.org/debian-lts-announce/2023/11/msg00012.html|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/2MBEPPC36UBVOZZNAXFHKLFGSLCMN5LI/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3N4NJ7FR4X4FPZUGNTQAPSTVB2HB2Y4A/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BFQD3KUEMFBHPAPBGLWQC34L4OWL5HAZ/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/CLB4TW7KALB3EEQWNWCN7OUIWWVWWCG2/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E72T67UPDRXHIDLO3OROR25YAMN4GGW5/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/FNA62Q767CFAFHBCDKYNPBMZWB7TWYVU/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HT7T2R4MQKLIF4ODV4BDLPARWFPCJ5CZ/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JIZSEFC3YKCGABA2BZW6ZJRMDZJMB7PJ/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JMEXY22BFG5Q64HQCM5CK2Q7KDKVV4TY/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KSEGD2IWKNUO3DWY4KQGUQM5BISRWHQE/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LKYHSZQFDNR7RSA7LHVLLIAQMVYCUGBG/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LNMZJCDHGLJJLXO4OXWJMTVQRNWOC7UL/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/VHUHTSXLXGXS7JYKBXTA3VINUPHTNGVU/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/VSRDIV77HNKUSM7SJC5BKE5JSHLHU2NK/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WE2I52RHNNU42PX6NZ2RBUHSFFJ2LVZX/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WLPRQ5TWUQQXYWBJM7ECYDAIL2YVKIUH/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/X6QXN4ORIVF6XBW4WWFE7VNPVC74S45Y/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XFOIBB4YFICHDM7IBOP7PWXW3FX4HLL2/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZB43REMKRQR62NJEI7I5NQ4FSXNLBKRT/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZKQSIKIAT5TJ3WSLU3RDBQ35YX4GY4V3/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZLU6U2R2IC2K64NDPNMV55AUAO65MAF4/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2MBEPPC36UBVOZZNAXFHKLFGSLCMN5LI/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3N4NJ7FR4X4FPZUGNTQAPSTVB2HB2Y4A/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BFQD3KUEMFBHPAPBGLWQC34L4OWL5HAZ/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CLB4TW7KALB3EEQWNWCN7OUIWWVWWCG2/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E72T67UPDRXHIDLO3OROR25YAMN4GGW5/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNA62Q767CFAFHBCDKYNPBMZWB7TWYVU/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HT7T2R4MQKLIF4ODV4BDLPARWFPCJ5CZ/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JIZSEFC3YKCGABA2BZW6ZJRMDZJMB7PJ/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JMEXY22BFG5Q64HQCM5CK2Q7KDKVV4TY/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KSEGD2IWKNUO3DWY4KQGUQM5BISRWHQE/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LKYHSZQFDNR7RSA7LHVLLIAQMVYCUGBG/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LNMZJCDHGLJJLXO4OXWJMTVQRNWOC7UL/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VHUHTSXLXGXS7JYKBXTA3VINUPHTNGVU/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VSRDIV77HNKUSM7SJC5BKE5JSHLHU2NK/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WE2I52RHNNU42PX6NZ2RBUHSFFJ2LVZX/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WLPRQ5TWUQQXYWBJM7ECYDAIL2YVKIUH/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/X6QXN4ORIVF6XBW4WWFE7VNPVC74S45Y/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XFOIBB4YFICHDM7IBOP7PWXW3FX4HLL2/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZB43REMKRQR62NJEI7I5NQ4FSXNLBKRT/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZKQSIKIAT5TJ3WSLU3RDBQ35YX4GY4V3/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZLU6U2R2IC2K64NDPNMV55AUAO65MAF4/|https://lists.w3.org/Archives/Public/ietf-http-wg/2023OctDec/0025.html|https://lists.w3.org/Archives/Public/ietf-http-wg/2023OctDec/0025.html|https://mailman.nginx.org/pipermail/nginx-devel/2023-October/S36Q5HBXR7CAIMPLLPRSSSYR4PCMWILK.html|https://mailman.nginx.org/pipermail/nginx-devel/2023-October/S36Q5HBXR7CAIMPLLPRSSSYR4PCMWILK.html|https://martinthomson.github.io/h2-stream-limits/draft-thomson-httpbis-h2-stream-limits.html|https://martinthomson.github.io/h2-stream-limits/draft-thomson-httpbis-h2-stream-limits.html|https://msrc.microsoft.com/blog/2023/10/microsoft-response-to-distributed-denial-of-service-ddos-attacks-against-http/2/|https://msrc.microsoft.com/blog/2023/10/microsoft-response-to-distributed-denial-of-service-ddos-attacks-against-http/2/|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-44487|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-44487|https://my.f5.com/manage/s/article/K000137106|https://my.f5.com/manage/s/article/K000137106|https://netty.io/news/2023/10/10/4-1-100-Final.html|https://netty.io/news/2023/10/10/4-1-100-Final.html|https://news.ycombinator.com/item?id=37830987|https://news.ycombinator.com/item?id=37830987|https://news.ycombinator.com/item?id=37830998|https://news.ycombinator.com/item?id=37830998|https://news.ycombinator.com/item?id=37831062|https://news.ycombinator.com/item?id=37831062|https://news.ycombinator.com/item?id=37837043|https://news.ycombinator.com/item?id=37837043|https://openssf.org/blog/2023/10/10/http-2-rapid-reset-vulnerability-highlights-need-for-rapid-response/|https://openssf.org/blog/2023/10/10/http-2-rapid-reset-vulnerability-highlights-need-for-rapid-response/|https://seanmonstar.com/post/730794151136935936/hyper-http2-rapid-reset-unaffected|https://seanmonstar.com/post/730794151136935936/hyper-http2-rapid-reset-unaffected|https://security.gentoo.org/glsa/202311-09|https://security.gentoo.org/glsa/202311-09|https://security.netapp.com/advisory/ntap-20231016-0001/|https://security.netapp.com/advisory/ntap-20231016-0001/|https://security.netapp.com/advisory/ntap-20240426-0007/|https://security.netapp.com/advisory/ntap-20240426-0007/|https://security.netapp.com/advisory/ntap-20240621-0006/|https://security.netapp.com/advisory/ntap-20240621-0006/|https://security.netapp.com/advisory/ntap-20240621-0007/|https://security.netapp.com/advisory/ntap-20240621-0007/|https://security.paloaltonetworks.com/CVE-2023-44487|https://security.paloaltonetworks.com/CVE-2023-44487|https://tomcat.apache.org/security-10.html#Fixed_in_Apache_Tomcat_10.1.14|https://tomcat.apache.org/security-10.html#Fixed_in_Apache_Tomcat_10.1.14|https://ubuntu.com/security/CVE-2023-44487|https://ubuntu.com/security/CVE-2023-44487|https://www.bleepingcomputer.com/news/security/new-http-2-rapid-reset-zero-day-attack-breaks-ddos-records/|https://www.bleepingcomputer.com/news/security/new-http-2-rapid-reset-zero-day-attack-breaks-ddos-records/|https://www.cisa.gov/news-events/alerts/2023/10/10/http2-rapid-reset-vulnerability-cve-2023-44487|https://www.cisa.gov/news-events/alerts/2023/10/10/http2-rapid-reset-vulnerability-cve-2023-44487|https://www.darkreading.com/cloud/internet-wide-zero-day-bug-fuels-largest-ever-ddos-event|https://www.darkreading.com/cloud/internet-wide-zero-day-bug-fuels-largest-ever-ddos-event|https://www.debian.org/security/2023/dsa-5521|https://www.debian.org/security/2023/dsa-5521|https://www.debian.org/security/2023/dsa-5522|https://www.debian.org/security/2023/dsa-5522|https://www.debian.org/security/2023/dsa-5540|https://www.debian.org/security/2023/dsa-5540|https://www.debian.org/security/2023/dsa-5549|https://www.debian.org/security/2023/dsa-5549|https://www.debian.org/security/2023/dsa-5558|https://www.debian.org/security/2023/dsa-5558|https://www.debian.org/security/2023/dsa-5570|https://www.debian.org/security/2023/dsa-5570|https://www.haproxy.com/blog/haproxy-is-not-affected-by-the-http-2-rapid-reset-attack-cve-2023-44487|https://www.haproxy.com/blog/haproxy-is-not-affected-by-the-http-2-rapid-reset-attack-cve-2023-44487|https://www.netlify.com/blog/netlify-successfully-mitigates-cve-2023-44487/|https://www.netlify.com/blog/netlify-successfully-mitigates-cve-2023-44487/|https://www.nginx.com/blog/http-2-rapid-reset-attack-impacting-f5-nginx-products/|https://www.nginx.com/blog/http-2-rapid-reset-attack-impacting-f5-nginx-products/|https://www.openwall.com/lists/oss-security/2023/10/10/6|https://www.openwall.com/lists/oss-security/2023/10/10/6|https://www.phoronix.com/news/HTTP2-Rapid-Reset-Attack|https://www.phoronix.com/news/HTTP2-Rapid-Reset-Attack|https://www.theregister.com/2023/10/10/http2_rapid_reset_zeroday/|https://www.theregister.com/2023/10/10/http2_rapid_reset_zeroday/|https://www.vicarius.io/vsociety/posts/rapid-reset-cve-2023-44487-dos-in-http2-understanding-the-root-cause|https://github.com/dotnet/core/blob/e4613450ea0da7fd2fc6b61dfb2c1c1dec1ce9ec/release-notes/6.0/6.0.23/6.0.23.md?plain=1#L73|https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/|https://aws.amazon.com/security/security-bulletins/AWS-2023-011/|https://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack|https://www.nginx.com/blog/http-2-rapid-reset-attack-impacting-f5-nginx-products/|https://cloud.google.com/blog/products/identity-security/google-cloud-mitigated-largest-ddos-attack-peaking-above-398-million-rps/|https://news.ycombinator.com/item?id=37831062|https://blog.cloudflare.com/zero-day-rapid-reset-http2-record-breaking-ddos-attack/|https://www.phoronix.com/news/HTTP2-Rapid-Reset-Attack|https://github.com/envoyproxy/envoy/pull/30055|https://github.com/haproxy/haproxy/issues/2312|https://github.com/eclipse/jetty.project/issues/10679|https://forums.swift.org/t/swift-nio-http2-security-update-cve-2023-44487-http-2-dos/67764|https://github.com/nghttp2/nghttp2/pull/1961|https://github.com/netty/netty/commit/58f75f665aa81a8cbcf6ffa74820042a285c5e61|https://github.com/alibaba/tengine/issues/1872|https://github.com/apache/tomcat/tree/main/java/org/apache/coyote/http2|https://news.ycombinator.com/item?id=37830987|https://news.ycombinator.com/item?id=37830998|https://github.com/caddyserver/caddy/issues/5877|https://www.bleepingcomputer.com/news/security/new-http-2-rapid-reset-zero-day-attack-breaks-ddos-records/|https://github.com/bcdannyboy/CVE-2023-44487|https://github.com/grpc/grpc-go/pull/6703|https://github.com/icing/mod_h2/blob/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a/mod_http2/README.md?plain=1#L239-L244|https://github.com/nghttp2/nghttp2/releases/tag/v1.57.0|https://mailman.nginx.org/pipermail/nginx-devel/2023-October/S36Q5HBXR7CAIMPLLPRSSSYR4PCMWILK.html|https://my.f5.com/manage/s/article/K000137106|https://msrc.microsoft.com/blog/2023/10/microsoft-response-to-distributed-denial-of-service-ddos-attacks-against-http/2/|https://bugzilla.proxmox.com/show_bug.cgi?id=4988|https://cgit.freebsd.org/ports/commit/?id=c64c329c2c1752f46b73e3e6ce9f4329be6629f9|http://www.openwall.com/lists/oss-security/2023/10/10/7|http://www.openwall.com/lists/oss-security/2023/10/10/6|https://seanmonstar.com/post/730794151136935936/hyper-http2-rapid-reset-unaffected|https://github.com/microsoft/CBL-Mariner/pull/6381|https://groups.google.com/g/golang-announce/c/iNNxDTCjZvo|https://github.com/facebook/proxygen/pull/466|https://gist.github.com/adulau/7c2bfb8e9cdbe4b35a5e131c66a0c088|https://github.com/micrictor/http2-rst-stream|https://edg.io/lp/blog/resets-leaks-ddos-and-the-tale-of-a-hidden-cve|https://openssf.org/blog/2023/10/10/http-2-rapid-reset-vulnerability-highlights-need-for-rapid-response/|https://github.com/h2o/h2o/security/advisories/GHSA-2m7v-gc89-fjqf|https://github.com/h2o/h2o/pull/3291|https://github.com/nodejs/node/pull/50121|https://github.com/dotnet/announcements/issues/277|https://github.com/golang/go/issues/63417|https://github.com/advisories/GHSA-vx74-f528-fxqg|https://github.com/apache/trafficserver/pull/10564|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-44487|https://tomcat.apache.org/security-10.html#Fixed_in_Apache_Tomcat_10.1.14|https://lists.apache.org/thread/5py8h42mxfsn8l1wy6o41xwhsjlsd87q|https://www.openwall.com/lists/oss-security/2023/10/10/6|https://www.haproxy.com/blog/haproxy-is-not-affected-by-the-http-2-rapid-reset-attack-cve-2023-44487|https://github.com/opensearch-project/data-prepper/issues/3474|https://github.com/kubernetes/kubernetes/pull/121120|https://github.com/oqtane/oqtane.framework/discussions/3367|https://github.com/advisories/GHSA-xpw8-rcwv-8f8p|https://netty.io/news/2023/10/10/4-1-100-Final.html|https://www.cisa.gov/news-events/alerts/2023/10/10/http2-rapid-reset-vulnerability-cve-2023-44487|https://www.theregister.com/2023/10/10/http2_rapid_reset_zeroday/|https://blog.qualys.com/vulnerabilities-threat-research/2023/10/10/cve-2023-44487-http-2-rapid-reset-attack|https://news.ycombinator.com/item?id=37837043|https://github.com/kazu-yamamoto/http2/issues/93|https://martinthomson.github.io/h2-stream-limits/draft-thomson-httpbis-h2-stream-limits.html|https://github.com/kazu-yamamoto/http2/commit/f61d41a502bd0f60eb24e1ce14edc7b6df6722a1|https://github.com/apache/httpd/blob/afcdbeebbff4b0c50ea26cdd16e178c0d1f24152/modules/http2/h2_mplx.c#L1101-L1113|https://www.debian.org/security/2023/dsa-5522|https://www.debian.org/security/2023/dsa-5521|https://access.redhat.com/security/cve/cve-2023-44487|https://github.com/ninenines/cowboy/issues/1615|https://github.com/varnishcache/varnish-cache/issues/3996|https://github.com/tempesta-tech/tempesta/issues/1986|https://blog.vespa.ai/cve-2023-44487/|https://github.com/etcd-io/etcd/issues/16740|https://www.darkreading.com/cloud/internet-wide-zero-day-bug-fuels-largest-ever-ddos-event|https://istio.io/latest/news/security/istio-security-2023-004/|https://github.com/junkurihara/rust-rpxy/issues/97|https://bugzilla.suse.com/show_bug.cgi?id=1216123|https://bugzilla.redhat.com/show_bug.cgi?id=2242803|https://ubuntu.com/security/CVE-2023-44487|https://community.traefik.io/t/is-traefik-vulnerable-to-cve-2023-44487/20125|https://github.com/advisories/GHSA-qppj-fm5r-hxr3|https://github.com/apache/httpd-site/pull/10|https://github.com/projectcontour/contour/pull/5826|https://github.com/linkerd/website/pull/1695/commits/4b9c6836471bc8270ab48aae6fd2181bc73fd632|https://github.com/line/armeria/pull/5232|https://blog.litespeedtech.com/2023/10/11/rapid-reset-http-2-vulnerablilty/|https://security.paloaltonetworks.com/CVE-2023-44487|https://github.com/akka/akka-http/issues/4323|https://github.com/openresty/openresty/issues/930|https://github.com/apache/apisix/issues/10320|https://github.com/Azure/AKS/issues/3947|https://github.com/Kong/kong/discussions/11741|https://github.com/arkrwn/PoC/tree/main/CVE-2023-44487|https://www.netlify.com/blog/netlify-successfully-mitigates-cve-2023-44487/|https://github.com/caddyserver/caddy/releases/tag/v2.7.5|https://lists.debian.org/debian-lts-announce/2023/10/msg00020.html|http://www.openwall.com/lists/oss-security/2023/10/13/4|http://www.openwall.com/lists/oss-security/2023/10/13/9|https://arstechnica.com/security/2023/10/how-ddosers-used-the-http-2-protocol-to-deliver-attacks-of-unprecedented-size/|https://lists.w3.org/Archives/Public/ietf-http-wg/2023OctDec/0025.html|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JMEXY22BFG5Q64HQCM5CK2Q7KDKVV4TY/|https://linkerd.io/2023/10/12/linkerd-cve-2023-44487/|https://lists.debian.org/debian-lts-announce/2023/10/msg00023.html|https://security.netapp.com/advisory/ntap-20231016-0001/|https://lists.debian.org/debian-lts-announce/2023/10/msg00024.html|http://www.openwall.com/lists/oss-security/2023/10/18/4|http://www.openwall.com/lists/oss-security/2023/10/18/8|http://www.openwall.com/lists/oss-security/2023/10/19/6|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZKQSIKIAT5TJ3WSLU3RDBQ35YX4GY4V3/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JIZSEFC3YKCGABA2BZW6ZJRMDZJMB7PJ/|http://www.openwall.com/lists/oss-security/2023/10/20/8|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WLPRQ5TWUQQXYWBJM7ECYDAIL2YVKIUH/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E72T67UPDRXHIDLO3OROR25YAMN4GGW5/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BFQD3KUEMFBHPAPBGLWQC34L4OWL5HAZ/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZLU6U2R2IC2K64NDPNMV55AUAO65MAF4/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/X6QXN4ORIVF6XBW4WWFE7VNPVC74S45Y/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LKYHSZQFDNR7RSA7LHVLLIAQMVYCUGBG/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNA62Q767CFAFHBCDKYNPBMZWB7TWYVU/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LNMZJCDHGLJJLXO4OXWJMTVQRNWOC7UL/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KSEGD2IWKNUO3DWY4KQGUQM5BISRWHQE/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CLB4TW7KALB3EEQWNWCN7OUIWWVWWCG2/|https://lists.debian.org/debian-lts-announce/2023/10/msg00045.html|https://www.debian.org/security/2023/dsa-5540|https://lists.debian.org/debian-lts-announce/2023/10/msg00047.html|https://discuss.hashicorp.com/t/hcsec-2023-32-vault-consul-and-boundary-affected-by-http-2-rapid-reset-denial-of-service-vulnerability-cve-2023-44487/59715|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VHUHTSXLXGXS7JYKBXTA3VINUPHTNGVU/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VSRDIV77HNKUSM7SJC5BKE5JSHLHU2NK/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3N4NJ7FR4X4FPZUGNTQAPSTVB2HB2Y4A/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZB43REMKRQR62NJEI7I5NQ4FSXNLBKRT/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HT7T2R4MQKLIF4ODV4BDLPARWFPCJ5CZ/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XFOIBB4YFICHDM7IBOP7PWXW3FX4HLL2/|https://lists.debian.org/debian-lts-announce/2023/11/msg00001.html|https://www.debian.org/security/2023/dsa-5549|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2MBEPPC36UBVOZZNAXFHKLFGSLCMN5LI/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WE2I52RHNNU42PX6NZ2RBUHSFFJ2LVZX/|https://www.debian.org/security/2023/dsa-5558|https://lists.debian.org/debian-lts-announce/2023/11/msg00012.html|https://security.gentoo.org/glsa/202311-09|https://www.debian.org/security/2023/dsa-5570|https://security.netapp.com/advisory/ntap-20240426-0007/|https://security.netapp.com/advisory/ntap-20240621-0006/|https://security.netapp.com/advisory/ntap-20240621-0007/|https://github.com/grpc/grpc/releases/tag/v1.59.2,||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||,0,0,cisco/prime_network_registrar *,cisco/prime_network_registrar *,,Unknown,High,Unknown,Denial of Service (DoS),
CVE-2021-1675,,,,0,0,0,0,,,,,,,,,,,Microsoft,Windows Server 2012 R2 (Server Core installation),6.3.0,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,L,L,N,R,U,H,H,H,42,15,http://packetstormsecurity.com/files/163349/Microsoft-PrintNightmare-Proof-Of-Concept.html|http://packetstormsecurity.com/files/163349/Microsoft-PrintNightmare-Proof-Of-Concept.html|http://packetstormsecurity.com/files/163351/PrintNightmare-Windows-Spooler-Service-Remote-Code-Execution.html|http://packetstormsecurity.com/files/163351/PrintNightmare-Windows-Spooler-Service-Remote-Code-Execution.html|http://packetstormsecurity.com/files/167261/Print-Spooler-Remote-DLL-Injection.html|http://packetstormsecurity.com/files/167261/Print-Spooler-Remote-DLL-Injection.html|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-1675|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-1675|https://www.kb.cert.org/vuls/id/383432|https://www.kb.cert.org/vuls/id/383432|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-1675|https://www.kb.cert.org/vuls/id/383432|http://packetstormsecurity.com/files/163349/Microsoft-PrintNightmare-Proof-Of-Concept.html|http://packetstormsecurity.com/files/163351/PrintNightmare-Windows-Spooler-Service-Remote-Code-Execution.html|http://packetstormsecurity.com/files/167261/Print-Spooler-Remote-DLL-Injection.html,||||||||||||||,0,0,Microsoft/Windows Server 2012 R2 (Server Core installation) 6.3.0,Microsoft/Windows Server 2012 R2 (Server Core installation) 6.3.0,,Unknown,High,Unknown,Privilege Escalation,
CVE-2021-46836,Implementation of the WLAN module interfaces has the information disclosure vulnerability. Successful exploitation of this vulnerability may affect data confidentiality.,,,0,0,0,0,,,,,,,,,,,Huawei,HarmonyOS,2,,,,,,7.5,3.9,3.6,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,N,L,N,N,U,H,N,N,6,6,https://consumer.huawei.com/en/support/bulletin/2022/9/|https://consumer.huawei.com/en/support/bulletin/2022/9/|https://device.harmonyos.com/en/docs/security/update/security-bulletins-phones-202209-0000001392278845|https://device.harmonyos.com/en/docs/security/update/security-bulletins-phones-202209-0000001392278845|https://device.harmonyos.com/en/docs/security/update/security-bulletins-phones-202209-0000001392278845|https://consumer.huawei.com/en/support/bulletin/2022/9/,|||||,0,0,Huawei/HarmonyOS 2.0,Huawei/HarmonyOS 2.0,,Unknown,High,Unknown,Remote Code Execution (RCE),
CVE-2025-21821,"In the Linux kernel, the following vulnerability has been resolved:

fbdev: omap: use threaded IRQ for LCD DMA

When using touchscreen and framebuffer, Nokia 770 crashes easily with:

    BUG: scheduling while atomic: irq/144-ads7846/82/0x00010000
    Modules linked in: usb_f_ecm g_ether usb_f_rndis u_ether libcomposite configfs omap_udc ohci_omap ohci_hcd
    CPU: 0 UID: 0 PID: 82 Comm: irq/144-ads7846 Not tainted 6.12.7-770 #2
    Hardware name: Nokia 770
    Call trace:
     unwind_backtrace from show_stack+0x10/0x14
     show_stack from dump_stack_lvl+0x54/0x5c
     dump_stack_lvl from __schedule_bug+0x50/0x70
     __schedule_bug from __schedule+0x4d4/0x5bc
     __schedule from schedule+0x34/0xa0
     schedule from schedule_preempt_disabled+0xc/0x10
     schedule_preempt_disabled from __mutex_lock.constprop.0+0x218/0x3b4
     __mutex_lock.constprop.0 from clk_prepare_lock+0x38/0xe4
     clk_prepare_lock from clk_set_rate+0x18/0x154
     clk_set_rate from sossi_read_data+0x4c/0x168
     sossi_read_data from hwa742_read_reg+0x5c/0x8c
     hwa742_read_reg from send_frame_handler+0xfc/0x300
     send_frame_handler from process_pending_requests+0x74/0xd0
     process_pending_requests from lcd_dma_irq_handler+0x50/0x74
     lcd_dma_irq_handler from __handle_irq_event_percpu+0x44/0x130
     __handle_irq_event_percpu from handle_irq_event+0x28/0x68
     handle_irq_event from handle_level_irq+0x9c/0x170
     handle_level_irq from generic_handle_domain_irq+0x2c/0x3c
     generic_handle_domain_irq from omap1_handle_irq+0x40/0x8c
     omap1_handle_irq from generic_handle_arch_irq+0x28/0x3c
     generic_handle_arch_irq from call_with_stack+0x1c/0x24
     call_with_stack from __irq_svc+0x94/0xa8
    Exception stack(0xc5255da0 to 0xc5255de8)
    5da0: 00000001 c22fc620 00000000 00000000 c08384a8 c106fc00 00000000 c240c248
    5dc0: c113a600 c3f6ec30 00000001 00000000 c22fc620 c5255df0 c22fc620 c0279a94
    5de0: 60000013 ffffffff
     __irq_svc from clk_prepare_lock+0x4c/0xe4
     clk_prepare_lock from clk_get_rate+0x10/0x74
     clk_get_rate from uwire_setup_transfer+0x40/0x180
     uwire_setup_transfer from spi_bitbang_transfer_one+0x2c/0x9c
     spi_bitbang_transfer_one from spi_transfer_one_message+0x2d0/0x664
     spi_transfer_one_message from __spi_pump_transfer_message+0x29c/0x498
     __spi_pump_transfer_message from __spi_sync+0x1f8/0x2e8
     __spi_sync from spi_sync+0x24/0x40
     spi_sync from ads7846_halfd_read_state+0x5c/0x1c0
     ads7846_halfd_read_state from ads7846_irq+0x58/0x348
     ads7846_irq from irq_thread_fn+0x1c/0x78
     irq_thread_fn from irq_thread+0x120/0x228
     irq_thread from kthread+0xc8/0xe8
     kthread from ret_from_fork+0x14/0x28

As a quick fix, switch to a threaded IRQ which provides a stable system.",,,0,0,0,0,,,,,,,,,,,Linux,Linux,6.14,,,,,,0,,,,,,,,,,,,6,10,https://git.kernel.org/stable/c/7bbbd311dd503653a2cc86d9226740883051dc92|https://git.kernel.org/stable/c/8392ea100f0b86c234c739c6662f39f0ccc0cefd|https://git.kernel.org/stable/c/aa8e22cbedeb626f2a6bda0aea362353d627cd0a|https://git.kernel.org/stable/c/e4b6b665df815b4841e71b72f06446884e8aad40|https://git.kernel.org/stable/c/fb6a5edb60921887d7d10619fcdcbee9759552cb|https://git.kernel.org/stable/c/7bbbd311dd503653a2cc86d9226740883051dc92|https://git.kernel.org/stable/c/fb6a5edb60921887d7d10619fcdcbee9759552cb|https://git.kernel.org/stable/c/aa8e22cbedeb626f2a6bda0aea362353d627cd0a|https://git.kernel.org/stable/c/8392ea100f0b86c234c739c6662f39f0ccc0cefd|https://git.kernel.org/stable/c/e4b6b665df815b4841e71b72f06446884e8aad40,|||||||||,0,0,Linux/Linux 6.14,Linux/Linux 6.14,,Unknown,,Unknown,Information Disclosure,
CVE-2022-21577,"Vulnerability in the Oracle FLEXCUBE Universal Banking product of Oracle Financial Services Applications (component: Infrastructure). Supported versions that are affected are 12.1-12.4, 14.0-14.3 and 14.5. Difficult to exploit vulnerability allows low privileged attacker with network access via HTTP to compromise Oracle FLEXCUBE Universal Banking. Successful attacks require human interaction from a person other than the attacker. Successful attacks of this vulnerability can result in unauthorized creation, deletion or modification access to critical data or all Oracle FLEXCUBE Universal Banking accessible data as well as unauthorized access to critical data or complete access to all Oracle FLEXCUBE Universal Banking accessible data. CVSS 3.1 Base Score 6.4 (Confidentiality and Integrity impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:N).",,,0,0,0,0,,,,,,,,,,,oracle,Other_Product,*,,,,,,6.4,,,CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:N,N,H,L,R,U,H,H,N,5,3,https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujul2022.html,||,0,0,oracle/flexcube_universal_banking *,oracle/flexcube_universal_banking *,,Unknown,Medium,Unknown,Denial of Service (DoS),
CVE-2022-26934,,,,0,0,0,0,,,,,,,,,,,Microsoft,Windows Server 2008 R2 Service Pack 1,6.1.7601.0,,,,,,6.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N/E:U/RL:O/RC:C,N,L,N,R,U,H,N,N,54,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-26934|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2022-26934|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-26934,||,0,0,Microsoft/Windows Server 2008 R2 Service Pack 1 6.1.7601.0,Microsoft/Windows Server 2008 R2 Service Pack 1 6.1.7601.0,,Unknown,Medium,Unknown,Privilege Escalation,
CVE-2024-45341,"A certificate with a URI which has a IPv6 address with a zone ID may incorrectly satisfy a URI name constraint that applies to the certificate chain. Certificates containing URIs are not permitted in the web PKI, so this only affects users of private PKIs which make use of URIs.",,,0,0,0,0,,,,,,,,,,,Other_Vendor,Other_Product,1.23.0-0,,,,,,6.1,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N,N,L,N,R,C,L,L,N,3,11,https://go.dev/cl/643099|https://go.dev/issue/71156|https://groups.google.com/g/golang-dev/c/bG8cv1muIBM/m/G461hA6lCgAJ|https://groups.google.com/g/golang-dev/c/CAWXhan3Jww/m/bk9LAa-lCgAJ|https://pkg.go.dev/vuln/GO-2025-3373|https://security.netapp.com/advisory/ntap-20250221-0004/|https://go.dev/cl/643099|https://go.dev/issue/71156|https://groups.google.com/g/golang-dev/c/bG8cv1muIBM/m/G461hA6lCgAJ|https://groups.google.com/g/golang-dev/c/CAWXhan3Jww/m/bk9LAa-lCgAJ|https://pkg.go.dev/vuln/GO-2025-3373,||||||||||,0,0,Go standard library/crypto/x509 1.23.0-0,Go standard library/crypto/x509 1.23.0-0,,Unknown,Medium,Unknown,Remote Code Execution (RCE),
CVE-2025-37742,"In the Linux kernel, the following vulnerability has been resolved:

jfs: Fix uninit-value access of imap allocated in the diMount() function

syzbot reports that hex_dump_to_buffer is using uninit-value:

=====================================================
BUG: KMSAN: uninit-value in hex_dump_to_buffer+0x888/0x1100 lib/hexdump.c:171
hex_dump_to_buffer+0x888/0x1100 lib/hexdump.c:171
print_hex_dump+0x13d/0x3e0 lib/hexdump.c:276
diFree+0x5ba/0x4350 fs/jfs/jfs_imap.c:876
jfs_evict_inode+0x510/0x550 fs/jfs/inode.c:156
evict+0x723/0xd10 fs/inode.c:796
iput_final fs/inode.c:1946 [inline]
iput+0x97b/0xdb0 fs/inode.c:1972
txUpdateMap+0xf3e/0x1150 fs/jfs/jfs_txnmgr.c:2367
txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]
jfs_lazycommit+0x627/0x11d0 fs/jfs/jfs_txnmgr.c:2733
kthread+0x6b9/0xef0 kernel/kthread.c:464
ret_from_fork+0x6d/0x90 arch/x86/kernel/process.c:148
ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244

Uninit was created at:
slab_post_alloc_hook mm/slub.c:4121 [inline]
slab_alloc_node mm/slub.c:4164 [inline]
__kmalloc_cache_noprof+0x8e3/0xdf0 mm/slub.c:4320
kmalloc_noprof include/linux/slab.h:901 [inline]
diMount+0x61/0x7f0 fs/jfs/jfs_imap.c:105
jfs_mount+0xa8e/0x11d0 fs/jfs/jfs_mount.c:176
jfs_fill_super+0xa47/0x17c0 fs/jfs/super.c:523
get_tree_bdev_flags+0x6ec/0x910 fs/super.c:1636
get_tree_bdev+0x37/0x50 fs/super.c:1659
jfs_get_tree+0x34/0x40 fs/jfs/super.c:635
vfs_get_tree+0xb1/0x5a0 fs/super.c:1814
do_new_mount+0x71f/0x15e0 fs/namespace.c:3560
path_mount+0x742/0x1f10 fs/namespace.c:3887
do_mount fs/namespace.c:3900 [inline]
__do_sys_mount fs/namespace.c:4111 [inline]
__se_sys_mount+0x71f/0x800 fs/namespace.c:4088
__x64_sys_mount+0xe4/0x150 fs/namespace.c:4088
x64_sys_call+0x39bf/0x3c30 arch/x86/include/generated/asm/syscalls_64.h:166
do_syscall_x64 arch/x86/entry/common.c:52 [inline]
do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83
entry_SYSCALL_64_after_hwframe+0x77/0x7f
=====================================================

The reason is that imap is not properly initialized after memory
allocation. It will cause the snprintf() function to write uninitialized
data into linebuf within hex_dump_to_buffer().

Fix this by using kzalloc instead of kmalloc to clear its content at the
beginning in diMount().",,,0,0,0,0,,,,,,,,,,,Linux,Linux,6.1.135,,,,,,0,,,,,,,,,,,,8,28,https://git.kernel.org/stable/c/067347e00a3a7d04afed93f080c6c131e5dd15ee|https://git.kernel.org/stable/c/4f10732712fce33e53703ffe5ed9155f23814097|https://git.kernel.org/stable/c/63148ce4904faa668daffdd1d3c1199ae315ef2c|https://git.kernel.org/stable/c/7057f3aab47629d38e54eae83505813cf0da1e4b|https://git.kernel.org/stable/c/9629d7d66c621671d9a47afe27ca9336bfc8a9ea|https://git.kernel.org/stable/c/cab1852368dd74d629ee02abdbc559218ca64dde|https://git.kernel.org/stable/c/d0d7eca253ccd0619b3d2b683ffe32218ebca9ac|https://git.kernel.org/stable/c/067347e00a3a7d04afed93f080c6c131e5dd15ee|https://git.kernel.org/stable/c/4f10732712fce33e53703ffe5ed9155f23814097|https://git.kernel.org/stable/c/63148ce4904faa668daffdd1d3c1199ae315ef2c|https://git.kernel.org/stable/c/7057f3aab47629d38e54eae83505813cf0da1e4b|https://git.kernel.org/stable/c/9629d7d66c621671d9a47afe27ca9336bfc8a9ea|https://git.kernel.org/stable/c/cab1852368dd74d629ee02abdbc559218ca64dde|https://git.kernel.org/stable/c/d0d7eca253ccd0619b3d2b683ffe32218ebca9ac|https://git.kernel.org/stable/c/067347e00a3a7d04afed93f080c6c131e5dd15ee|https://git.kernel.org/stable/c/4f10732712fce33e53703ffe5ed9155f23814097|https://git.kernel.org/stable/c/63148ce4904faa668daffdd1d3c1199ae315ef2c|https://git.kernel.org/stable/c/7057f3aab47629d38e54eae83505813cf0da1e4b|https://git.kernel.org/stable/c/9629d7d66c621671d9a47afe27ca9336bfc8a9ea|https://git.kernel.org/stable/c/cab1852368dd74d629ee02abdbc559218ca64dde|https://git.kernel.org/stable/c/d0d7eca253ccd0619b3d2b683ffe32218ebca9ac|https://git.kernel.org/stable/c/4f10732712fce33e53703ffe5ed9155f23814097|https://git.kernel.org/stable/c/cab1852368dd74d629ee02abdbc559218ca64dde|https://git.kernel.org/stable/c/067347e00a3a7d04afed93f080c6c131e5dd15ee|https://git.kernel.org/stable/c/63148ce4904faa668daffdd1d3c1199ae315ef2c|https://git.kernel.org/stable/c/7057f3aab47629d38e54eae83505813cf0da1e4b|https://git.kernel.org/stable/c/d0d7eca253ccd0619b3d2b683ffe32218ebca9ac|https://git.kernel.org/stable/c/9629d7d66c621671d9a47afe27ca9336bfc8a9ea,|||||||||||||||||||||||||||,0,0,Linux/Linux 6.1.135,Linux/Linux 6.1.135,,Unknown,,Unknown,Denial of Service (DoS),
CVE-2024-29366,A command injection vulnerability exists in the cgibin binary in DIR-845L router firmware <= v1.01KRb03.,,,0,0,0,0,,,,,,,,,,,Other_Vendor,Other_Product,,,,,,,8.8,,,CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,A,L,N,N,U,H,H,H,1,6,https://github.com/20Yiju/DLink/blob/master/DIR-845L/CI.md|https://github.com/20Yiju/DLink/blob/master/DIR-845L/CI.md|https://www.dlink.com/en/security-bulletin/|https://www.dlink.com/en/security-bulletin/|https://www.dlink.com/en/security-bulletin/|https://github.com/20Yiju/DLink/blob/master/DIR-845L/CI.md,|||||,0,0,n/a/n/a n/a,n/a/n/a n/a,,Unknown,High,Unknown,Privilege Escalation,
CVE-2023-6993,"The Custom post types, Custom Fields & more plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the plugin's shortcode and custom post meta in all versions up to, and including, 5.0.4 due to insufficient input sanitization and output escaping on user supplied post meta values. This makes it possible for authenticated attackers with contributor-level and above permissions to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",,,0,0,0,0,,,,,,,,,,,Other_Vendor,Other_Product,*,,,,,,6.4,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N,N,L,L,N,C,L,L,N,1,6,https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&old=3063871%40custom-post-types&new=3063871%40custom-post-types&sfp_email=&sfph_mail=|https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&old=3063871%40custom-post-types&new=3063871%40custom-post-types&sfp_email=&sfph_mail=|https://www.wordfence.com/threat-intel/vulnerabilities/id/2b1449a9-6c89-4dec-8107-86cf8a295025?source=cve|https://www.wordfence.com/threat-intel/vulnerabilities/id/2b1449a9-6c89-4dec-8107-86cf8a295025?source=cve|https://www.wordfence.com/threat-intel/vulnerabilities/id/2b1449a9-6c89-4dec-8107-86cf8a295025?source=cve|https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&old=3063871%40custom-post-types&new=3063871%40custom-post-types&sfp_email=&sfph_mail=,|||||,0,0,"totalpressorg/Custom post types, Custom Fields & more *","totalpressorg/Custom post types, Custom Fields & more *",,Unknown,Medium,Unknown,Information Disclosure,
CVE-2021-0157,Insufficient control flow management in the BIOS firmware for some Intel(R) Processors may allow a privileged user to potentially enable escalation of privilege via local access.,,,0,0,0,0,,,,,,,,,,,intel,Other_Product,-,,,,,,6.7,0.8,5.9,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,L,L,H,N,U,H,H,H,485,3,https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00562.html|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00562.html|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00562.html,||,0,0,intel/core_i7-5960x -,intel/core_i7-5960x -,,Unknown,Medium,Unknown,Remote Code Execution (RCE),
CVE-2021-33761,,,,0,0,0,0,,,,,,,,,,,Microsoft,Other_Product,10.0.0,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,L,L,L,N,U,H,H,H,30,3,https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-33761|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-33761|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-33761,||,0,0,Microsoft/Windows 10 Version 2004 10.0.0,Microsoft/Windows 10 Version 2004 10.0.0,,Unknown,High,Unknown,Denial of Service (DoS),
CVE-2022-39928,,,,0,0,0,0,,,,,,,,,,,Other_Vendor,Other_Product,,,,,,,0,,,,,,,,,,,,0,0,,,0,0,None/None None,None/None None,,Unknown,,Unknown,Privilege Escalation,
CVE-2023-44487,"The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.",,,0,0,0,0,,,,,,,,,,,f5,Other_Product,17.1.0,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,197,427,http://www.openwall.com/lists/oss-security/2023/10/10/6|http://www.openwall.com/lists/oss-security/2023/10/10/7|http://www.openwall.com/lists/oss-security/2023/10/13/4|http://www.openwall.com/lists/oss-security/2023/10/13/4|http://www.openwall.com/lists/oss-security/2023/10/13/9|http://www.openwall.com/lists/oss-security/2023/10/13/9|http://www.openwall.com/lists/oss-security/2023/10/18/4|http://www.openwall.com/lists/oss-security/2023/10/18/4|http://www.openwall.com/lists/oss-security/2023/10/18/8|http://www.openwall.com/lists/oss-security/2023/10/18/8|http://www.openwall.com/lists/oss-security/2023/10/19/6|http://www.openwall.com/lists/oss-security/2023/10/19/6|http://www.openwall.com/lists/oss-security/2023/10/20/8|http://www.openwall.com/lists/oss-security/2023/10/20/8|https://access.redhat.com/security/cve/cve-2023-44487|https://access.redhat.com/security/cve/cve-2023-44487|https://arstechnica.com/security/2023/10/how-ddosers-used-the-http-2-protocol-to-deliver-attacks-of-unprecedented-size/|https://arstechnica.com/security/2023/10/how-ddosers-used-the-http-2-protocol-to-deliver-attacks-of-unprecedented-size/|https://aws.amazon.com/security/security-bulletins/AWS-2023-011/|https://aws.amazon.com/security/security-bulletins/AWS-2023-011/|https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/|https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/|https://blog.cloudflare.com/zero-day-rapid-reset-http2-record-breaking-ddos-attack/|https://blog.cloudflare.com/zero-day-rapid-reset-http2-record-breaking-ddos-attack/|https://blog.litespeedtech.com/2023/10/11/rapid-reset-http-2-vulnerablilty/|https://blog.litespeedtech.com/2023/10/11/rapid-reset-http-2-vulnerablilty/|https://blog.qualys.com/vulnerabilities-threat-research/2023/10/10/cve-2023-44487-http-2-rapid-reset-attack|https://blog.qualys.com/vulnerabilities-threat-research/2023/10/10/cve-2023-44487-http-2-rapid-reset-attack|https://blog.vespa.ai/cve-2023-44487/|https://blog.vespa.ai/cve-2023-44487/|https://bugzilla.proxmox.com/show_bug.cgi?id=4988|https://bugzilla.proxmox.com/show_bug.cgi?id=4988|https://bugzilla.redhat.com/show_bug.cgi?id=2242803|https://bugzilla.redhat.com/show_bug.cgi?id=2242803|https://bugzilla.suse.com/show_bug.cgi?id=1216123|https://bugzilla.suse.com/show_bug.cgi?id=1216123|https://cgit.freebsd.org/ports/commit/?id=c64c329c2c1752f46b73e3e6ce9f4329be6629f9|https://cgit.freebsd.org/ports/commit/?id=c64c329c2c1752f46b73e3e6ce9f4329be6629f9|https://cloud.google.com/blog/products/identity-security/google-cloud-mitigated-largest-ddos-attack-peaking-above-398-million-rps/|https://cloud.google.com/blog/products/identity-security/google-cloud-mitigated-largest-ddos-attack-peaking-above-398-million-rps/|https://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack|https://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack|https://community.traefik.io/t/is-traefik-vulnerable-to-cve-2023-44487/20125|https://community.traefik.io/t/is-traefik-vulnerable-to-cve-2023-44487/20125|https://discuss.hashicorp.com/t/hcsec-2023-32-vault-consul-and-boundary-affected-by-http-2-rapid-reset-denial-of-service-vulnerability-cve-2023-44487/59715|https://discuss.hashicorp.com/t/hcsec-2023-32-vault-consul-and-boundary-affected-by-http-2-rapid-reset-denial-of-service-vulnerability-cve-2023-44487/59715|https://edg.io/lp/blog/resets-leaks-ddos-and-the-tale-of-a-hidden-cve|https://edg.io/lp/blog/resets-leaks-ddos-and-the-tale-of-a-hidden-cve|https://forums.swift.org/t/swift-nio-http2-security-update-cve-2023-44487-http-2-dos/67764|https://forums.swift.org/t/swift-nio-http2-security-update-cve-2023-44487-http-2-dos/67764|https://gist.github.com/adulau/7c2bfb8e9cdbe4b35a5e131c66a0c088|https://gist.github.com/adulau/7c2bfb8e9cdbe4b35a5e131c66a0c088|https://github.com/advisories/GHSA-qppj-fm5r-hxr3|https://github.com/advisories/GHSA-qppj-fm5r-hxr3|https://github.com/advisories/GHSA-vx74-f528-fxqg|https://github.com/advisories/GHSA-vx74-f528-fxqg|https://github.com/advisories/GHSA-xpw8-rcwv-8f8p|https://github.com/advisories/GHSA-xpw8-rcwv-8f8p|https://github.com/akka/akka-http/issues/4323|https://github.com/akka/akka-http/issues/4323|https://github.com/alibaba/tengine/issues/1872|https://github.com/alibaba/tengine/issues/1872|https://github.com/apache/apisix/issues/10320|https://github.com/apache/apisix/issues/10320|https://github.com/apache/httpd/blob/afcdbeebbff4b0c50ea26cdd16e178c0d1f24152/modules/http2/h2_mplx.c#L1101-L1113|https://github.com/apache/httpd/blob/afcdbeebbff4b0c50ea26cdd16e178c0d1f24152/modules/http2/h2_mplx.c#L1101-L1113|https://github.com/apache/httpd-site/pull/10|https://github.com/apache/httpd-site/pull/10|https://github.com/apache/tomcat/tree/main/java/org/apache/coyote/http2|https://github.com/apache/tomcat/tree/main/java/org/apache/coyote/http2|https://github.com/apache/trafficserver/pull/10564|https://github.com/apache/trafficserver/pull/10564|https://github.com/arkrwn/PoC/tree/main/CVE-2023-44487|https://github.com/arkrwn/PoC/tree/main/CVE-2023-44487|https://github.com/Azure/AKS/issues/3947|https://github.com/Azure/AKS/issues/3947|https://github.com/bcdannyboy/CVE-2023-44487|https://github.com/bcdannyboy/CVE-2023-44487|https://github.com/caddyserver/caddy/issues/5877|https://github.com/caddyserver/caddy/issues/5877|https://github.com/caddyserver/caddy/releases/tag/v2.7.5|https://github.com/caddyserver/caddy/releases/tag/v2.7.5|https://github.com/dotnet/announcements/issues/277|https://github.com/dotnet/announcements/issues/277|https://github.com/dotnet/core/blob/e4613450ea0da7fd2fc6b61dfb2c1c1dec1ce9ec/release-notes/6.0/6.0.23/6.0.23.md?plain=1#L73|https://github.com/dotnet/core/blob/e4613450ea0da7fd2fc6b61dfb2c1c1dec1ce9ec/release-notes/6.0/6.0.23/6.0.23.md?plain=1#L73|https://github.com/eclipse/jetty.project/issues/10679|https://github.com/eclipse/jetty.project/issues/10679|https://github.com/envoyproxy/envoy/pull/30055|https://github.com/envoyproxy/envoy/pull/30055|https://github.com/etcd-io/etcd/issues/16740|https://github.com/etcd-io/etcd/issues/16740|https://github.com/facebook/proxygen/pull/466|https://github.com/facebook/proxygen/pull/466|https://github.com/golang/go/issues/63417|https://github.com/golang/go/issues/63417|https://github.com/grpc/grpc/releases/tag/v1.59.2|https://github.com/grpc/grpc-go/pull/6703|https://github.com/grpc/grpc-go/pull/6703|https://github.com/h2o/h2o/pull/3291|https://github.com/h2o/h2o/pull/3291|https://github.com/h2o/h2o/security/advisories/GHSA-2m7v-gc89-fjqf|https://github.com/h2o/h2o/security/advisories/GHSA-2m7v-gc89-fjqf|https://github.com/haproxy/haproxy/issues/2312|https://github.com/haproxy/haproxy/issues/2312|https://github.com/icing/mod_h2/blob/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a/mod_http2/README.md?plain=1#L239-L244|https://github.com/icing/mod_h2/blob/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a/mod_http2/README.md?plain=1#L239-L244|https://github.com/junkurihara/rust-rpxy/issues/97|https://github.com/junkurihara/rust-rpxy/issues/97|https://github.com/kazu-yamamoto/http2/commit/f61d41a502bd0f60eb24e1ce14edc7b6df6722a1|https://github.com/kazu-yamamoto/http2/commit/f61d41a502bd0f60eb24e1ce14edc7b6df6722a1|https://github.com/kazu-yamamoto/http2/issues/93|https://github.com/kazu-yamamoto/http2/issues/93|https://github.com/Kong/kong/discussions/11741|https://github.com/Kong/kong/discussions/11741|https://github.com/kubernetes/kubernetes/pull/121120|https://github.com/kubernetes/kubernetes/pull/121120|https://github.com/line/armeria/pull/5232|https://github.com/line/armeria/pull/5232|https://github.com/linkerd/website/pull/1695/commits/4b9c6836471bc8270ab48aae6fd2181bc73fd632|https://github.com/linkerd/website/pull/1695/commits/4b9c6836471bc8270ab48aae6fd2181bc73fd632|https://github.com/micrictor/http2-rst-stream|https://github.com/micrictor/http2-rst-stream|https://github.com/microsoft/CBL-Mariner/pull/6381|https://github.com/microsoft/CBL-Mariner/pull/6381|https://github.com/netty/netty/commit/58f75f665aa81a8cbcf6ffa74820042a285c5e61|https://github.com/netty/netty/commit/58f75f665aa81a8cbcf6ffa74820042a285c5e61|https://github.com/nghttp2/nghttp2/pull/1961|https://github.com/nghttp2/nghttp2/pull/1961|https://github.com/nghttp2/nghttp2/releases/tag/v1.57.0|https://github.com/nghttp2/nghttp2/releases/tag/v1.57.0|https://github.com/ninenines/cowboy/issues/1615|https://github.com/ninenines/cowboy/issues/1615|https://github.com/nodejs/node/pull/50121|https://github.com/nodejs/node/pull/50121|https://github.com/openresty/openresty/issues/930|https://github.com/openresty/openresty/issues/930|https://github.com/opensearch-project/data-prepper/issues/3474|https://github.com/opensearch-project/data-prepper/issues/3474|https://github.com/oqtane/oqtane.framework/discussions/3367|https://github.com/oqtane/oqtane.framework/discussions/3367|https://github.com/projectcontour/contour/pull/5826|https://github.com/projectcontour/contour/pull/5826|https://github.com/tempesta-tech/tempesta/issues/1986|https://github.com/tempesta-tech/tempesta/issues/1986|https://github.com/varnishcache/varnish-cache/issues/3996|https://github.com/varnishcache/varnish-cache/issues/3996|https://groups.google.com/g/golang-announce/c/iNNxDTCjZvo|https://groups.google.com/g/golang-announce/c/iNNxDTCjZvo|https://istio.io/latest/news/security/istio-security-2023-004/|https://istio.io/latest/news/security/istio-security-2023-004/|https://linkerd.io/2023/10/12/linkerd-cve-2023-44487/|https://linkerd.io/2023/10/12/linkerd-cve-2023-44487/|https://lists.apache.org/thread/5py8h42mxfsn8l1wy6o41xwhsjlsd87q|https://lists.apache.org/thread/5py8h42mxfsn8l1wy6o41xwhsjlsd87q|https://lists.debian.org/debian-lts-announce/2023/10/msg00020.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00020.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00023.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00023.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00024.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00024.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00045.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00045.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00047.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00047.html|https://lists.debian.org/debian-lts-announce/2023/11/msg00001.html|https://lists.debian.org/debian-lts-announce/2023/11/msg00001.html|https://lists.debian.org/debian-lts-announce/2023/11/msg00012.html|https://lists.debian.org/debian-lts-announce/2023/11/msg00012.html|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/2MBEPPC36UBVOZZNAXFHKLFGSLCMN5LI/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/3N4NJ7FR4X4FPZUGNTQAPSTVB2HB2Y4A/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BFQD3KUEMFBHPAPBGLWQC34L4OWL5HAZ/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/CLB4TW7KALB3EEQWNWCN7OUIWWVWWCG2/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/E72T67UPDRXHIDLO3OROR25YAMN4GGW5/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/FNA62Q767CFAFHBCDKYNPBMZWB7TWYVU/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HT7T2R4MQKLIF4ODV4BDLPARWFPCJ5CZ/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JIZSEFC3YKCGABA2BZW6ZJRMDZJMB7PJ/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/JMEXY22BFG5Q64HQCM5CK2Q7KDKVV4TY/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/KSEGD2IWKNUO3DWY4KQGUQM5BISRWHQE/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LKYHSZQFDNR7RSA7LHVLLIAQMVYCUGBG/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LNMZJCDHGLJJLXO4OXWJMTVQRNWOC7UL/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/VHUHTSXLXGXS7JYKBXTA3VINUPHTNGVU/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/VSRDIV77HNKUSM7SJC5BKE5JSHLHU2NK/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WE2I52RHNNU42PX6NZ2RBUHSFFJ2LVZX/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WLPRQ5TWUQQXYWBJM7ECYDAIL2YVKIUH/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/X6QXN4ORIVF6XBW4WWFE7VNPVC74S45Y/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XFOIBB4YFICHDM7IBOP7PWXW3FX4HLL2/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZB43REMKRQR62NJEI7I5NQ4FSXNLBKRT/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZKQSIKIAT5TJ3WSLU3RDBQ35YX4GY4V3/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/ZLU6U2R2IC2K64NDPNMV55AUAO65MAF4/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2MBEPPC36UBVOZZNAXFHKLFGSLCMN5LI/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3N4NJ7FR4X4FPZUGNTQAPSTVB2HB2Y4A/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BFQD3KUEMFBHPAPBGLWQC34L4OWL5HAZ/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CLB4TW7KALB3EEQWNWCN7OUIWWVWWCG2/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E72T67UPDRXHIDLO3OROR25YAMN4GGW5/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNA62Q767CFAFHBCDKYNPBMZWB7TWYVU/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HT7T2R4MQKLIF4ODV4BDLPARWFPCJ5CZ/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JIZSEFC3YKCGABA2BZW6ZJRMDZJMB7PJ/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JMEXY22BFG5Q64HQCM5CK2Q7KDKVV4TY/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KSEGD2IWKNUO3DWY4KQGUQM5BISRWHQE/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LKYHSZQFDNR7RSA7LHVLLIAQMVYCUGBG/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LNMZJCDHGLJJLXO4OXWJMTVQRNWOC7UL/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VHUHTSXLXGXS7JYKBXTA3VINUPHTNGVU/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VSRDIV77HNKUSM7SJC5BKE5JSHLHU2NK/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WE2I52RHNNU42PX6NZ2RBUHSFFJ2LVZX/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WLPRQ5TWUQQXYWBJM7ECYDAIL2YVKIUH/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/X6QXN4ORIVF6XBW4WWFE7VNPVC74S45Y/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XFOIBB4YFICHDM7IBOP7PWXW3FX4HLL2/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZB43REMKRQR62NJEI7I5NQ4FSXNLBKRT/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZKQSIKIAT5TJ3WSLU3RDBQ35YX4GY4V3/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZLU6U2R2IC2K64NDPNMV55AUAO65MAF4/|https://lists.w3.org/Archives/Public/ietf-http-wg/2023OctDec/0025.html|https://lists.w3.org/Archives/Public/ietf-http-wg/2023OctDec/0025.html|https://mailman.nginx.org/pipermail/nginx-devel/2023-October/S36Q5HBXR7CAIMPLLPRSSSYR4PCMWILK.html|https://mailman.nginx.org/pipermail/nginx-devel/2023-October/S36Q5HBXR7CAIMPLLPRSSSYR4PCMWILK.html|https://martinthomson.github.io/h2-stream-limits/draft-thomson-httpbis-h2-stream-limits.html|https://martinthomson.github.io/h2-stream-limits/draft-thomson-httpbis-h2-stream-limits.html|https://msrc.microsoft.com/blog/2023/10/microsoft-response-to-distributed-denial-of-service-ddos-attacks-against-http/2/|https://msrc.microsoft.com/blog/2023/10/microsoft-response-to-distributed-denial-of-service-ddos-attacks-against-http/2/|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-44487|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-44487|https://my.f5.com/manage/s/article/K000137106|https://my.f5.com/manage/s/article/K000137106|https://netty.io/news/2023/10/10/4-1-100-Final.html|https://netty.io/news/2023/10/10/4-1-100-Final.html|https://news.ycombinator.com/item?id=37830987|https://news.ycombinator.com/item?id=37830987|https://news.ycombinator.com/item?id=37830998|https://news.ycombinator.com/item?id=37830998|https://news.ycombinator.com/item?id=37831062|https://news.ycombinator.com/item?id=37831062|https://news.ycombinator.com/item?id=37837043|https://news.ycombinator.com/item?id=37837043|https://openssf.org/blog/2023/10/10/http-2-rapid-reset-vulnerability-highlights-need-for-rapid-response/|https://openssf.org/blog/2023/10/10/http-2-rapid-reset-vulnerability-highlights-need-for-rapid-response/|https://seanmonstar.com/post/730794151136935936/hyper-http2-rapid-reset-unaffected|https://seanmonstar.com/post/730794151136935936/hyper-http2-rapid-reset-unaffected|https://security.gentoo.org/glsa/202311-09|https://security.gentoo.org/glsa/202311-09|https://security.netapp.com/advisory/ntap-20231016-0001/|https://security.netapp.com/advisory/ntap-20231016-0001/|https://security.netapp.com/advisory/ntap-20240426-0007/|https://security.netapp.com/advisory/ntap-20240426-0007/|https://security.netapp.com/advisory/ntap-20240621-0006/|https://security.netapp.com/advisory/ntap-20240621-0006/|https://security.netapp.com/advisory/ntap-20240621-0007/|https://security.netapp.com/advisory/ntap-20240621-0007/|https://security.paloaltonetworks.com/CVE-2023-44487|https://security.paloaltonetworks.com/CVE-2023-44487|https://tomcat.apache.org/security-10.html#Fixed_in_Apache_Tomcat_10.1.14|https://tomcat.apache.org/security-10.html#Fixed_in_Apache_Tomcat_10.1.14|https://ubuntu.com/security/CVE-2023-44487|https://ubuntu.com/security/CVE-2023-44487|https://www.bleepingcomputer.com/news/security/new-http-2-rapid-reset-zero-day-attack-breaks-ddos-records/|https://www.bleepingcomputer.com/news/security/new-http-2-rapid-reset-zero-day-attack-breaks-ddos-records/|https://www.cisa.gov/news-events/alerts/2023/10/10/http2-rapid-reset-vulnerability-cve-2023-44487|https://www.cisa.gov/news-events/alerts/2023/10/10/http2-rapid-reset-vulnerability-cve-2023-44487|https://www.darkreading.com/cloud/internet-wide-zero-day-bug-fuels-largest-ever-ddos-event|https://www.darkreading.com/cloud/internet-wide-zero-day-bug-fuels-largest-ever-ddos-event|https://www.debian.org/security/2023/dsa-5521|https://www.debian.org/security/2023/dsa-5521|https://www.debian.org/security/2023/dsa-5522|https://www.debian.org/security/2023/dsa-5522|https://www.debian.org/security/2023/dsa-5540|https://www.debian.org/security/2023/dsa-5540|https://www.debian.org/security/2023/dsa-5549|https://www.debian.org/security/2023/dsa-5549|https://www.debian.org/security/2023/dsa-5558|https://www.debian.org/security/2023/dsa-5558|https://www.debian.org/security/2023/dsa-5570|https://www.debian.org/security/2023/dsa-5570|https://www.haproxy.com/blog/haproxy-is-not-affected-by-the-http-2-rapid-reset-attack-cve-2023-44487|https://www.haproxy.com/blog/haproxy-is-not-affected-by-the-http-2-rapid-reset-attack-cve-2023-44487|https://www.netlify.com/blog/netlify-successfully-mitigates-cve-2023-44487/|https://www.netlify.com/blog/netlify-successfully-mitigates-cve-2023-44487/|https://www.nginx.com/blog/http-2-rapid-reset-attack-impacting-f5-nginx-products/|https://www.nginx.com/blog/http-2-rapid-reset-attack-impacting-f5-nginx-products/|https://www.openwall.com/lists/oss-security/2023/10/10/6|https://www.openwall.com/lists/oss-security/2023/10/10/6|https://www.phoronix.com/news/HTTP2-Rapid-Reset-Attack|https://www.phoronix.com/news/HTTP2-Rapid-Reset-Attack|https://www.theregister.com/2023/10/10/http2_rapid_reset_zeroday/|https://www.theregister.com/2023/10/10/http2_rapid_reset_zeroday/|https://www.vicarius.io/vsociety/posts/rapid-reset-cve-2023-44487-dos-in-http2-understanding-the-root-cause|https://github.com/dotnet/core/blob/e4613450ea0da7fd2fc6b61dfb2c1c1dec1ce9ec/release-notes/6.0/6.0.23/6.0.23.md?plain=1#L73|https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/|https://aws.amazon.com/security/security-bulletins/AWS-2023-011/|https://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack|https://www.nginx.com/blog/http-2-rapid-reset-attack-impacting-f5-nginx-products/|https://cloud.google.com/blog/products/identity-security/google-cloud-mitigated-largest-ddos-attack-peaking-above-398-million-rps/|https://news.ycombinator.com/item?id=37831062|https://blog.cloudflare.com/zero-day-rapid-reset-http2-record-breaking-ddos-attack/|https://www.phoronix.com/news/HTTP2-Rapid-Reset-Attack|https://github.com/envoyproxy/envoy/pull/30055|https://github.com/haproxy/haproxy/issues/2312|https://github.com/eclipse/jetty.project/issues/10679|https://forums.swift.org/t/swift-nio-http2-security-update-cve-2023-44487-http-2-dos/67764|https://github.com/nghttp2/nghttp2/pull/1961|https://github.com/netty/netty/commit/58f75f665aa81a8cbcf6ffa74820042a285c5e61|https://github.com/alibaba/tengine/issues/1872|https://github.com/apache/tomcat/tree/main/java/org/apache/coyote/http2|https://news.ycombinator.com/item?id=37830987|https://news.ycombinator.com/item?id=37830998|https://github.com/caddyserver/caddy/issues/5877|https://www.bleepingcomputer.com/news/security/new-http-2-rapid-reset-zero-day-attack-breaks-ddos-records/|https://github.com/bcdannyboy/CVE-2023-44487|https://github.com/grpc/grpc-go/pull/6703|https://github.com/icing/mod_h2/blob/0a864782af0a942aa2ad4ed960a6b32cd35bcf0a/mod_http2/README.md?plain=1#L239-L244|https://github.com/nghttp2/nghttp2/releases/tag/v1.57.0|https://mailman.nginx.org/pipermail/nginx-devel/2023-October/S36Q5HBXR7CAIMPLLPRSSSYR4PCMWILK.html|https://my.f5.com/manage/s/article/K000137106|https://msrc.microsoft.com/blog/2023/10/microsoft-response-to-distributed-denial-of-service-ddos-attacks-against-http/2/|https://bugzilla.proxmox.com/show_bug.cgi?id=4988|https://cgit.freebsd.org/ports/commit/?id=c64c329c2c1752f46b73e3e6ce9f4329be6629f9|http://www.openwall.com/lists/oss-security/2023/10/10/7|http://www.openwall.com/lists/oss-security/2023/10/10/6|https://seanmonstar.com/post/730794151136935936/hyper-http2-rapid-reset-unaffected|https://github.com/microsoft/CBL-Mariner/pull/6381|https://groups.google.com/g/golang-announce/c/iNNxDTCjZvo|https://github.com/facebook/proxygen/pull/466|https://gist.github.com/adulau/7c2bfb8e9cdbe4b35a5e131c66a0c088|https://github.com/micrictor/http2-rst-stream|https://edg.io/lp/blog/resets-leaks-ddos-and-the-tale-of-a-hidden-cve|https://openssf.org/blog/2023/10/10/http-2-rapid-reset-vulnerability-highlights-need-for-rapid-response/|https://github.com/h2o/h2o/security/advisories/GHSA-2m7v-gc89-fjqf|https://github.com/h2o/h2o/pull/3291|https://github.com/nodejs/node/pull/50121|https://github.com/dotnet/announcements/issues/277|https://github.com/golang/go/issues/63417|https://github.com/advisories/GHSA-vx74-f528-fxqg|https://github.com/apache/trafficserver/pull/10564|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-44487|https://tomcat.apache.org/security-10.html#Fixed_in_Apache_Tomcat_10.1.14|https://lists.apache.org/thread/5py8h42mxfsn8l1wy6o41xwhsjlsd87q|https://www.openwall.com/lists/oss-security/2023/10/10/6|https://www.haproxy.com/blog/haproxy-is-not-affected-by-the-http-2-rapid-reset-attack-cve-2023-44487|https://github.com/opensearch-project/data-prepper/issues/3474|https://github.com/kubernetes/kubernetes/pull/121120|https://github.com/oqtane/oqtane.framework/discussions/3367|https://github.com/advisories/GHSA-xpw8-rcwv-8f8p|https://netty.io/news/2023/10/10/4-1-100-Final.html|https://www.cisa.gov/news-events/alerts/2023/10/10/http2-rapid-reset-vulnerability-cve-2023-44487|https://www.theregister.com/2023/10/10/http2_rapid_reset_zeroday/|https://blog.qualys.com/vulnerabilities-threat-research/2023/10/10/cve-2023-44487-http-2-rapid-reset-attack|https://news.ycombinator.com/item?id=37837043|https://github.com/kazu-yamamoto/http2/issues/93|https://martinthomson.github.io/h2-stream-limits/draft-thomson-httpbis-h2-stream-limits.html|https://github.com/kazu-yamamoto/http2/commit/f61d41a502bd0f60eb24e1ce14edc7b6df6722a1|https://github.com/apache/httpd/blob/afcdbeebbff4b0c50ea26cdd16e178c0d1f24152/modules/http2/h2_mplx.c#L1101-L1113|https://www.debian.org/security/2023/dsa-5522|https://www.debian.org/security/2023/dsa-5521|https://access.redhat.com/security/cve/cve-2023-44487|https://github.com/ninenines/cowboy/issues/1615|https://github.com/varnishcache/varnish-cache/issues/3996|https://github.com/tempesta-tech/tempesta/issues/1986|https://blog.vespa.ai/cve-2023-44487/|https://github.com/etcd-io/etcd/issues/16740|https://www.darkreading.com/cloud/internet-wide-zero-day-bug-fuels-largest-ever-ddos-event|https://istio.io/latest/news/security/istio-security-2023-004/|https://github.com/junkurihara/rust-rpxy/issues/97|https://bugzilla.suse.com/show_bug.cgi?id=1216123|https://bugzilla.redhat.com/show_bug.cgi?id=2242803|https://ubuntu.com/security/CVE-2023-44487|https://community.traefik.io/t/is-traefik-vulnerable-to-cve-2023-44487/20125|https://github.com/advisories/GHSA-qppj-fm5r-hxr3|https://github.com/apache/httpd-site/pull/10|https://github.com/projectcontour/contour/pull/5826|https://github.com/linkerd/website/pull/1695/commits/4b9c6836471bc8270ab48aae6fd2181bc73fd632|https://github.com/line/armeria/pull/5232|https://blog.litespeedtech.com/2023/10/11/rapid-reset-http-2-vulnerablilty/|https://security.paloaltonetworks.com/CVE-2023-44487|https://github.com/akka/akka-http/issues/4323|https://github.com/openresty/openresty/issues/930|https://github.com/apache/apisix/issues/10320|https://github.com/Azure/AKS/issues/3947|https://github.com/Kong/kong/discussions/11741|https://github.com/arkrwn/PoC/tree/main/CVE-2023-44487|https://www.netlify.com/blog/netlify-successfully-mitigates-cve-2023-44487/|https://github.com/caddyserver/caddy/releases/tag/v2.7.5|https://lists.debian.org/debian-lts-announce/2023/10/msg00020.html|http://www.openwall.com/lists/oss-security/2023/10/13/4|http://www.openwall.com/lists/oss-security/2023/10/13/9|https://arstechnica.com/security/2023/10/how-ddosers-used-the-http-2-protocol-to-deliver-attacks-of-unprecedented-size/|https://lists.w3.org/Archives/Public/ietf-http-wg/2023OctDec/0025.html|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JMEXY22BFG5Q64HQCM5CK2Q7KDKVV4TY/|https://linkerd.io/2023/10/12/linkerd-cve-2023-44487/|https://lists.debian.org/debian-lts-announce/2023/10/msg00023.html|https://security.netapp.com/advisory/ntap-20231016-0001/|https://lists.debian.org/debian-lts-announce/2023/10/msg00024.html|http://www.openwall.com/lists/oss-security/2023/10/18/4|http://www.openwall.com/lists/oss-security/2023/10/18/8|http://www.openwall.com/lists/oss-security/2023/10/19/6|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZKQSIKIAT5TJ3WSLU3RDBQ35YX4GY4V3/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JIZSEFC3YKCGABA2BZW6ZJRMDZJMB7PJ/|http://www.openwall.com/lists/oss-security/2023/10/20/8|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WLPRQ5TWUQQXYWBJM7ECYDAIL2YVKIUH/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E72T67UPDRXHIDLO3OROR25YAMN4GGW5/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BFQD3KUEMFBHPAPBGLWQC34L4OWL5HAZ/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZLU6U2R2IC2K64NDPNMV55AUAO65MAF4/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/X6QXN4ORIVF6XBW4WWFE7VNPVC74S45Y/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LKYHSZQFDNR7RSA7LHVLLIAQMVYCUGBG/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNA62Q767CFAFHBCDKYNPBMZWB7TWYVU/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LNMZJCDHGLJJLXO4OXWJMTVQRNWOC7UL/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KSEGD2IWKNUO3DWY4KQGUQM5BISRWHQE/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CLB4TW7KALB3EEQWNWCN7OUIWWVWWCG2/|https://lists.debian.org/debian-lts-announce/2023/10/msg00045.html|https://www.debian.org/security/2023/dsa-5540|https://lists.debian.org/debian-lts-announce/2023/10/msg00047.html|https://discuss.hashicorp.com/t/hcsec-2023-32-vault-consul-and-boundary-affected-by-http-2-rapid-reset-denial-of-service-vulnerability-cve-2023-44487/59715|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VHUHTSXLXGXS7JYKBXTA3VINUPHTNGVU/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VSRDIV77HNKUSM7SJC5BKE5JSHLHU2NK/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3N4NJ7FR4X4FPZUGNTQAPSTVB2HB2Y4A/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZB43REMKRQR62NJEI7I5NQ4FSXNLBKRT/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HT7T2R4MQKLIF4ODV4BDLPARWFPCJ5CZ/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XFOIBB4YFICHDM7IBOP7PWXW3FX4HLL2/|https://lists.debian.org/debian-lts-announce/2023/11/msg00001.html|https://www.debian.org/security/2023/dsa-5549|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2MBEPPC36UBVOZZNAXFHKLFGSLCMN5LI/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WE2I52RHNNU42PX6NZ2RBUHSFFJ2LVZX/|https://www.debian.org/security/2023/dsa-5558|https://lists.debian.org/debian-lts-announce/2023/11/msg00012.html|https://security.gentoo.org/glsa/202311-09|https://www.debian.org/security/2023/dsa-5570|https://security.netapp.com/advisory/ntap-20240426-0007/|https://security.netapp.com/advisory/ntap-20240621-0006/|https://security.netapp.com/advisory/ntap-20240621-0007/|https://github.com/grpc/grpc/releases/tag/v1.59.2,||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||,0,0,f5/big-ip_global_traffic_manager 17.1.0,f5/big-ip_global_traffic_manager 17.1.0,,Unknown,High,Unknown,Denial of Service (DoS),
CVE-2022-49832,"In the Linux kernel, the following vulnerability has been resolved:

pinctrl: devicetree: fix null pointer dereferencing in pinctrl_dt_to_map

Here is the BUG report by KASAN about null pointer dereference:

BUG: KASAN: null-ptr-deref in strcmp+0x2e/0x50
Read of size 1 at addr 0000000000000000 by task python3/2640
Call Trace:
 strcmp
 __of_find_property
 of_find_property
 pinctrl_dt_to_map

kasprintf() would return NULL pointer when kmalloc() fail to allocate.
So directly return ENOMEM, if kasprintf() return NULL pointer.",,,0,0,0,0,,,,,,,,,,,Linux,Linux,0,,,,,,0,,,,,,,,,,,,11,32,https://git.kernel.org/stable/c/040f726fecd88121f3b95e70369785ad452dddf9|https://git.kernel.org/stable/c/5834a3a98cd266ad35a229923c0adbd0addc8d68|https://git.kernel.org/stable/c/777430aa4ddccaa5accec6db90ffc1d47f00d471|https://git.kernel.org/stable/c/91d5c5060ee24fe8da88cd585bb43b843d2f0dce|https://git.kernel.org/stable/c/97e5b508e96176f1a73888ed89df396d7041bfcb|https://git.kernel.org/stable/c/a988dcd3dd9e691c5ccc3324b209688f3b5453e9|https://git.kernel.org/stable/c/aaf552c5d53abe4659176e099575fe870d2e4768|https://git.kernel.org/stable/c/b4d9f55cd38435358bc16d580612bc0d798d7b4c|https://git.kernel.org/stable/c/040f726fecd88121f3b95e70369785ad452dddf9|https://git.kernel.org/stable/c/5834a3a98cd266ad35a229923c0adbd0addc8d68|https://git.kernel.org/stable/c/777430aa4ddccaa5accec6db90ffc1d47f00d471|https://git.kernel.org/stable/c/91d5c5060ee24fe8da88cd585bb43b843d2f0dce|https://git.kernel.org/stable/c/97e5b508e96176f1a73888ed89df396d7041bfcb|https://git.kernel.org/stable/c/a988dcd3dd9e691c5ccc3324b209688f3b5453e9|https://git.kernel.org/stable/c/aaf552c5d53abe4659176e099575fe870d2e4768|https://git.kernel.org/stable/c/b4d9f55cd38435358bc16d580612bc0d798d7b4c|https://git.kernel.org/stable/c/040f726fecd88121f3b95e70369785ad452dddf9|https://git.kernel.org/stable/c/5834a3a98cd266ad35a229923c0adbd0addc8d68|https://git.kernel.org/stable/c/777430aa4ddccaa5accec6db90ffc1d47f00d471|https://git.kernel.org/stable/c/91d5c5060ee24fe8da88cd585bb43b843d2f0dce|https://git.kernel.org/stable/c/97e5b508e96176f1a73888ed89df396d7041bfcb|https://git.kernel.org/stable/c/a988dcd3dd9e691c5ccc3324b209688f3b5453e9|https://git.kernel.org/stable/c/aaf552c5d53abe4659176e099575fe870d2e4768|https://git.kernel.org/stable/c/b4d9f55cd38435358bc16d580612bc0d798d7b4c|https://git.kernel.org/stable/c/aaf552c5d53abe4659176e099575fe870d2e4768|https://git.kernel.org/stable/c/b4d9f55cd38435358bc16d580612bc0d798d7b4c|https://git.kernel.org/stable/c/a988dcd3dd9e691c5ccc3324b209688f3b5453e9|https://git.kernel.org/stable/c/040f726fecd88121f3b95e70369785ad452dddf9|https://git.kernel.org/stable/c/777430aa4ddccaa5accec6db90ffc1d47f00d471|https://git.kernel.org/stable/c/97e5b508e96176f1a73888ed89df396d7041bfcb|https://git.kernel.org/stable/c/5834a3a98cd266ad35a229923c0adbd0addc8d68|https://git.kernel.org/stable/c/91d5c5060ee24fe8da88cd585bb43b843d2f0dce,|||||||||||||||||||||||||||||||,0,0,Linux/Linux 0,Linux/Linux 0,,Unknown,,Unknown,Remote Code Execution (RCE),
CVE-2023-49241,API permission control vulnerability in the network management module. Successful exploitation of this vulnerability may affect service confidentiality.,,,0,0,0,0,,,,,,,,,,,Huawei,HarmonyOS,3.0.0,,,,,,7.5,3.9,3.6,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,N,L,N,N,U,H,N,N,16,6,https://consumer.huawei.com/en/support/bulletin/2023/12/|https://consumer.huawei.com/en/support/bulletin/2023/12/|https://device.harmonyos.com/en/docs/security/update/security-bulletins-202312-0000001758430245|https://device.harmonyos.com/en/docs/security/update/security-bulletins-202312-0000001758430245|https://consumer.huawei.com/en/support/bulletin/2023/12/|https://device.harmonyos.com/en/docs/security/update/security-bulletins-202312-0000001758430245,|||||,0,0,Huawei/HarmonyOS 3.0.0,Huawei/HarmonyOS 3.0.0,,Unknown,High,Unknown,Information Disclosure,
CVE-2024-39220,"BAS-IP AV-01D, AV-01MD, AV-01MFD, AV-01ED, AV-01KD, AV-01BD, AV-01KBD, AV-02D, AV-02IDE, AV-02IDR, AV-02IPD, AV-02FDE, AV-02FDR, AV-03D, AV-03BD, AV-04AFD, AV-04ASD, AV-04FD, AV-04SD, AV-05FD, AV-05SD, AA-07BD, AA-07BDI, BA-04BD, BA-04MD, BA-08BD, BA-08MD, BA-12BD, BA-12MD, CR-02BD before firmware v3.9.2 allows authenticated attackers to read SIP account passwords via a crafted GET request.",,,0,0,0,0,,,,,,,,,,,Other_Vendor,Other_Product,,,,,,,6.5,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N,N,L,H,N,U,H,H,N,1,6,https://bas-ip.com/bsa-000001|https://bas-ip.com/bsa-000001|https://github.com/DrieVlad/BAS-IP-vulnerabilities|https://github.com/DrieVlad/BAS-IP-vulnerabilities|https://bas-ip.com/bsa-000001|https://github.com/DrieVlad/BAS-IP-vulnerabilities,|||||,0,0,n/a/n/a n/a,n/a/n/a n/a,,Unknown,Medium,Unknown,Denial of Service (DoS),
CVE-2025-20170,"A vulnerability in the SNMP subsystem of Cisco IOS Software and Cisco IOS XE Software could allow an authenticated, remote attacker to cause a DoS condition on an affected device.

This vulnerability is due to improper error handling when parsing SNMP requests. An attacker could exploit this vulnerability by sending a crafted SNMP request to an affected device. A successful exploit could allow the attacker to cause the device to reload unexpectedly, resulting in a DoS condition.&nbsp;
This vulnerability affects SNMP versions 1, 2c, and 3. To exploit this vulnerability through SNMP v2c or earlier, the attacker must know a valid read-write or read-only SNMP community string for the affected system. To exploit this vulnerability through SNMP v3, the attacker must have valid SNMP user credentials for the affected system.",,,0,0,0,0,,,,,,,,,,,Cisco,Cisco IOS XE Software,3.16.2bS,,,,,,7.7,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H,N,L,L,N,C,N,N,H,3395,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-snmp-dos-sdxnSUcW|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-snmp-dos-sdxnSUcW,|,0,0,Cisco/Cisco IOS XE Software 3.16.2bS,Cisco/Cisco IOS XE Software 3.16.2bS,,Unknown,High,Unknown,Privilege Escalation,
CVE-2025-20175,"A vulnerability in the SNMP subsystem of Cisco IOS Software and Cisco IOS XE Software could allow an authenticated, remote attacker to cause a DoS condition on an affected device.

This vulnerability is due to improper error handling when parsing SNMP requests. An attacker could exploit this vulnerability by sending a crafted SNMP request to an affected device. A successful exploit could allow the attacker to cause the device to reload unexpectedly, resulting in a DoS condition.&nbsp;
This vulnerability affects SNMP versions 1, 2c, and 3. To exploit this vulnerability through SNMP v2c or earlier, the attacker must know a valid read-write or read-only SNMP community string for the affected system. To exploit this vulnerability through SNMP v3, the attacker must have valid SNMP user credentials for the affected system.",,,0,0,0,0,,,,,,,,,,,Cisco,IOS,15.1(1)SY4,,,,,,7.7,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H,N,L,L,N,C,N,N,H,1348,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-snmp-dos-sdxnSUcW|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-snmp-dos-sdxnSUcW,|,0,0,Cisco/IOS 15.1(1)SY4,Cisco/IOS 15.1(1)SY4,,Unknown,High,Unknown,Remote Code Execution (RCE),
CVE-2021-47238,"In the Linux kernel, the following vulnerability has been resolved:

net: ipv4: fix memory leak in ip_mc_add1_src

BUG: memory leak
unreferenced object 0xffff888101bc4c00 (size 32):
  comm ""syz-executor527"", pid 360, jiffies 4294807421 (age 19.329s)
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
    01 00 00 00 00 00 00 00 ac 14 14 bb 00 00 02 00 ................
  backtrace:
    [<00000000f17c5244>] kmalloc include/linux/slab.h:558 [inline]
    [<00000000f17c5244>] kzalloc include/linux/slab.h:688 [inline]
    [<00000000f17c5244>] ip_mc_add1_src net/ipv4/igmp.c:1971 [inline]
    [<00000000f17c5244>] ip_mc_add_src+0x95f/0xdb0 net/ipv4/igmp.c:2095
    [<000000001cb99709>] ip_mc_source+0x84c/0xea0 net/ipv4/igmp.c:2416
    [<0000000052cf19ed>] do_ip_setsockopt net/ipv4/ip_sockglue.c:1294 [inline]
    [<0000000052cf19ed>] ip_setsockopt+0x114b/0x30c0 net/ipv4/ip_sockglue.c:1423
    [<00000000477edfbc>] raw_setsockopt+0x13d/0x170 net/ipv4/raw.c:857
    [<00000000e75ca9bb>] __sys_setsockopt+0x158/0x270 net/socket.c:2117
    [<00000000bdb993a8>] __do_sys_setsockopt net/socket.c:2128 [inline]
    [<00000000bdb993a8>] __se_sys_setsockopt net/socket.c:2125 [inline]
    [<00000000bdb993a8>] __x64_sys_setsockopt+0xba/0x150 net/socket.c:2125
    [<000000006a1ffdbd>] do_syscall_64+0x40/0x80 arch/x86/entry/common.c:47
    [<00000000b11467c4>] entry_SYSCALL_64_after_hwframe+0x44/0xae

In commit 24803f38a5c0 (""igmp: do not remove igmp souce list info when set
link down""), the ip_mc_clear_src() in ip_mc_destroy_dev() was removed,
because it was also called in igmpv3_clear_delrec().

Rough callgraph:

inetdev_destroy
-> ip_mc_destroy_dev
     -> igmpv3_clear_delrec
        -> ip_mc_clear_src
-> RCU_INIT_POINTER(dev->ip_ptr, NULL)

However, ip_mc_clear_src() called in igmpv3_clear_delrec() doesn't
release in_dev->mc_list->sources. And RCU_INIT_POINTER() assigns the
NULL to dev->ip_ptr. As a result, in_dev cannot be obtained through
inetdev_by_index() and then in_dev->mc_list->sources cannot be released
by ip_mc_del1_src() in the sock_close. Rough call sequence goes like:

sock_close
-> __sock_release
   -> inet_release
      -> ip_mc_drop_socket
         -> inetdev_by_index
         -> ip_mc_leave_src
            -> ip_mc_del_src
               -> ip_mc_del1_src

So we still need to call ip_mc_clear_src() in ip_mc_destroy_dev() to free
in_dev->mc_list->sources.",,,0,0,0,0,,,,,,,,,,,Linux,Linux,4.14.238,,,,,,5.5,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,14,21,https://git.kernel.org/stable/c/0dc13e75507faa17ac9f7562b4ef7bf8fcd78422|https://git.kernel.org/stable/c/0dc13e75507faa17ac9f7562b4ef7bf8fcd78422|https://git.kernel.org/stable/c/1e28018b5c83d5073f74a6fb72eabe8370b2f501|https://git.kernel.org/stable/c/1e28018b5c83d5073f74a6fb72eabe8370b2f501|https://git.kernel.org/stable/c/3dd2aeac2e9624cff9fa634710837e4f2e352758|https://git.kernel.org/stable/c/3dd2aeac2e9624cff9fa634710837e4f2e352758|https://git.kernel.org/stable/c/6cff57eea3347f79f1867cc53e1093b6614138d8|https://git.kernel.org/stable/c/6cff57eea3347f79f1867cc53e1093b6614138d8|https://git.kernel.org/stable/c/77de6ee73f54a9a89c0afa0bf4c53b239aa9953a|https://git.kernel.org/stable/c/77de6ee73f54a9a89c0afa0bf4c53b239aa9953a|https://git.kernel.org/stable/c/ac31cc837cafb57a271babad8ccffbf733caa076|https://git.kernel.org/stable/c/ac31cc837cafb57a271babad8ccffbf733caa076|https://git.kernel.org/stable/c/d8e2973029b8b2ce477b564824431f3385c77083|https://git.kernel.org/stable/c/d8e2973029b8b2ce477b564824431f3385c77083|https://git.kernel.org/stable/c/0dc13e75507faa17ac9f7562b4ef7bf8fcd78422|https://git.kernel.org/stable/c/6cff57eea3347f79f1867cc53e1093b6614138d8|https://git.kernel.org/stable/c/1e28018b5c83d5073f74a6fb72eabe8370b2f501|https://git.kernel.org/stable/c/3dd2aeac2e9624cff9fa634710837e4f2e352758|https://git.kernel.org/stable/c/ac31cc837cafb57a271babad8ccffbf733caa076|https://git.kernel.org/stable/c/77de6ee73f54a9a89c0afa0bf4c53b239aa9953a|https://git.kernel.org/stable/c/d8e2973029b8b2ce477b564824431f3385c77083,||||||||||||||||||||,0,0,Linux/Linux 4.14.238,Linux/Linux 4.14.238,,Unknown,Medium,Unknown,Information Disclosure,
CVE-2023-45043,"A buffer copy without checking size of input vulnerability has been reported to affect several QNAP operating system versions. If exploited, the vulnerability could allow authenticated administrators to execute code via a network.

We have already fixed the vulnerability in the following versions:
QTS 5.1.4.2596 build 20231128 and later
QuTS hero h5.1.4.2596 build 20231128 and later
",,,0,0,0,0,,,,,,,CWE-120,Buffer Copy without Checking Size of Input ('Classic Buffer Overflow'),Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",qnap,quts_hero,h5.1.0.2466,,,,,,3.8,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:L/A:L,N,L,H,N,U,N,L,L,17,3,https://www.qnap.com/en/security-advisory/qsa-23-27|https://www.qnap.com/en/security-advisory/qsa-23-27|https://www.qnap.com/en/security-advisory/qsa-23-27,||,0,0,qnap/quts_hero h5.1.0.2466,qnap/quts_hero h5.1.0.2466,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Buffer Overflow,Low,Buffer Overflow,Denial of Service (DoS),
CVE-2025-21176,,,,0,0,0,0,,,,,,,CWE-126,Buffer Over-read,Variant,,Microsoft,Other_Product,4.7.0,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,N,L,N,R,U,H,H,H,18,5,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21176|https://www.herodevs.com/vulnerability-directory/cve-2025-21176|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21176|https://www.herodevs.com/vulnerability-directory/cve-2025-21176|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21176,||||,0,0,Microsoft/Microsoft .NET Framework 3.5 AND 4.7.2 4.7.0,Microsoft/Microsoft .NET Framework 3.5 AND 4.7.2 4.7.0,,Buffer Overflow,High,Buffer Overflow,Privilege Escalation,
CVE-2022-33276,Memory corruption due to buffer copy without checking size of input in modem while receiving WMI_REQUEST_STATS_CMDID command.,,,0,0,0,0,,,,,,,CWE-120,Buffer Copy without Checking Size of Input ('Classic Buffer Overflow'),Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.","Qualcomm, Inc.",Snapdragon,WCN7850,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,134,3,https://www.qualcomm.com/company/product-security/bulletins/january-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/january-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/january-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon WCN7850","Qualcomm, Inc./Snapdragon WCN7850","Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Buffer Overflow,High,Buffer Overflow,Remote Code Execution (RCE),
CVE-2023-33018,Memory corruption while using the UIM diag command to get the operators name.,,,0,0,0,0,,,,,,,CWE-190,Integer Overflow or Wraparound,Base,"Ensure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol.; Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  If possible, choose a language or compiler that performs automatic bounds checking.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Use libraries or frameworks that make it easier to handle numbers without unexpected consequences.
                  Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]; Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.
                  Use unsigned integers where possible. This makes it easier to perform validation for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values.; Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, ""not-a-number"" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]
                  Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.","Qualcomm, Inc.",Snapdragon,Snapdragon 7c+ Gen 3 Compute,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,510,3,https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon Snapdragon 7c+ Gen 3 Compute","Qualcomm, Inc./Snapdragon Snapdragon 7c+ Gen 3 Compute","Ensure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol.; Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  If possible, choose a language or compiler that performs automatic bounds checking.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Use libraries or frameworks that make it easier to handle numbers without unexpected consequences.
                  Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]; Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.
                  Use unsigned integers where possible. This makes it easier to perform validation for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values.; Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, ""not-a-number"" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]
                  Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.",Buffer Overflow,High,Buffer Overflow,Denial of Service (DoS),
CVE-2024-20402,"A vulnerability in the SSL VPN feature for Cisco Adaptive Security Appliance (ASA) Software and Cisco Firepower Threat Defense (FTD) Software could allow an unauthenticated, remote attacker to cause an affected device to reload unexpectedly, resulting in a denial of service (DoS) condition.
 This vulnerability is due to a logic error in memory management when the device is handling SSL VPN connections. An attacker could exploit this vulnerability by sending crafted SSL/TLS packets to the SSL VPN server of the affected device. A successful exploit could allow the attacker to cause the device to reload, resulting in a DoS condition.",,,0,0,0,0,,,,,,,CWE-788,Access of Memory Location After End of Buffer,Base,,Cisco,Cisco Adaptive Security Appliance (ASA) Software,9.14.3.1,,,,,,8.6,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H,N,L,N,N,C,N,N,H,282,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-webvpn-dos-hOnB9pH4|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-webvpn-dos-hOnB9pH4,|,0,0,Cisco/Cisco Adaptive Security Appliance (ASA) Software 9.14.3.1,Cisco/Cisco Adaptive Security Appliance (ASA) Software 9.14.3.1,,Buffer Overflow,High,Buffer Overflow,Privilege Escalation,
CVE-2023-33068,Memory corruption in Audio while processing IIR config data from AFE calibration block.,,,0,0,0,0,,,,,,,CWE-120,Buffer Copy without Checking Size of Input ('Classic Buffer Overflow'),Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.","Qualcomm, Inc.",Snapdragon,WCN3990,,,,,,6.7,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,L,L,H,N,U,H,H,H,101,3,https://www.qualcomm.com/company/product-security/bulletins/february-2024-bulletin|https://www.qualcomm.com/company/product-security/bulletins/february-2024-bulletin|https://www.qualcomm.com/company/product-security/bulletins/february-2024-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon WCN3990","Qualcomm, Inc./Snapdragon WCN3990","Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Buffer Overflow,Medium,Buffer Overflow,Remote Code Execution (RCE),
CVE-2023-33107,Memory corruption in Graphics Linux while assigning shared virtual memory region during IOCTL call.,,,0,0,0,0,,,,,,,CWE-190,Integer Overflow or Wraparound,Base,"Ensure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol.; Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  If possible, choose a language or compiler that performs automatic bounds checking.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Use libraries or frameworks that make it easier to handle numbers without unexpected consequences.
                  Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]; Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.
                  Use unsigned integers where possible. This makes it easier to perform validation for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values.; Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, ""not-a-number"" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]
                  Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.","Qualcomm, Inc.",Snapdragon,SXR2230P,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,242,3,https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon SXR2230P","Qualcomm, Inc./Snapdragon SXR2230P","Ensure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol.; Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  If possible, choose a language or compiler that performs automatic bounds checking.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Use libraries or frameworks that make it easier to handle numbers without unexpected consequences.
                  Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]; Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.
                  Use unsigned integers where possible. This makes it easier to perform validation for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values.; Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, ""not-a-number"" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]
                  Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.",Buffer Overflow,High,Buffer Overflow,Information Disclosure,
CVE-2024-21475,Memory corruption when the payload received from firmware is not as per the expected protocol size.,,,0,0,0,0,,,,,,,CWE-119,Improper Restriction of Operations within the Bounds of a Memory Buffer,Class,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.","Qualcomm, Inc.",Snapdragon,SXR2230P,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,470,3,https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2024-bulletin.html,||,0,0,"Qualcomm, Inc./Snapdragon SXR2230P","Qualcomm, Inc./Snapdragon SXR2230P","Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Buffer Overflow,High,Buffer Overflow,Denial of Service (DoS),
CVE-2024-21477,Transient DOS while parsing a protected 802.11az Fine Time Measurement (FTM) frame.,,,0,0,0,0,,,,,,,CWE-126,Buffer Over-read,Variant,,"Qualcomm, Inc.",Snapdragon,SG8275P,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,366,3,https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2024-bulletin.html,||,0,0,"Qualcomm, Inc./Snapdragon SG8275P","Qualcomm, Inc./Snapdragon SG8275P",,Buffer Overflow,High,Buffer Overflow,Privilege Escalation,
CVE-2025-20169,"A vulnerability in the SNMP subsystem of Cisco IOS Software and Cisco IOS XE Software could allow an authenticated, remote attacker to cause a DoS condition on an affected device.

This vulnerability is due to improper error handling when parsing SNMP requests. An attacker could exploit this vulnerability by sending a crafted SNMP request to an affected device. A successful exploit could allow the attacker to cause the device to reload unexpectedly, resulting in a DoS condition.&nbsp;
This vulnerability affects SNMP versions 1, 2c, and 3. To exploit this vulnerability through SNMP v2c or earlier, the attacker must know a valid read-write or read-only SNMP community string for the affected system. To exploit this vulnerability through SNMP v3, the attacker must have valid SNMP user credentials for the affected system.",,,0,0,0,0,,,,,,,CWE-805,Buffer Access with Incorrect Length Value,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the product or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Cisco,IOS,12.2(2)XN,,,,,,7.7,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H,N,L,L,N,C,N,N,H,3395,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-snmp-dos-sdxnSUcW|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-snmp-dos-sdxnSUcW,|,0,0,Cisco/IOS 12.2(2)XN,Cisco/IOS 12.2(2)XN,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the product or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Buffer Overflow,High,Buffer Overflow,Remote Code Execution (RCE),
CVE-2023-28547,Memory corruption in SPS Application while requesting for public key in sorter TA.,,,0,0,0,0,,,,,,,CWE-120,Buffer Copy without Checking Size of Input ('Classic Buffer Overflow'),Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.","Qualcomm, Inc.",Snapdragon,SXR2130,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,602,3,https://docs.qualcomm.com/product/publicresources/securitybulletin/april-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/april-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/april-2024-bulletin.html,||,0,0,"Qualcomm, Inc./Snapdragon SXR2130","Qualcomm, Inc./Snapdragon SXR2130","Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Buffer Overflow,High,Buffer Overflow,Information Disclosure,
CVE-2023-20168,"A vulnerability in TACACS+ and RADIUS remote authentication for Cisco NX-OS Software could allow an unauthenticated, local attacker to cause an affected device to unexpectedly reload. This vulnerability is due to incorrect input validation when processing an authentication attempt if the directed request option is enabled for TACACS+ or RADIUS. An attacker could exploit this vulnerability by entering a crafted string at the login prompt of an affected device. A successful exploit could allow the attacker to cause the affected device to unexpectedly reload, resulting in a denial of service (DoS) condition. ",,,0,0,0,0,,,,,,,CWE-120,Buffer Copy without Checking Size of Input ('Classic Buffer Overflow'),Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Cisco,Cisco NX-OS Software,9.3(10),,,,,,7.1,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H,L,L,N,N,C,N,N,H,688,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nxos-remoteauth-dos-XB6pv74m|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nxos-remoteauth-dos-XB6pv74m|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nxos-remoteauth-dos-XB6pv74m,||,0,0,Cisco/Cisco NX-OS Software 9.3(10),Cisco/Cisco NX-OS Software 9.3(10),"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Buffer Overflow,High,Buffer Overflow,Denial of Service (DoS),
CVE-2025-20169,"A vulnerability in the SNMP subsystem of Cisco IOS Software and Cisco IOS XE Software could allow an authenticated, remote attacker to cause a DoS condition on an affected device.

This vulnerability is due to improper error handling when parsing SNMP requests. An attacker could exploit this vulnerability by sending a crafted SNMP request to an affected device. A successful exploit could allow the attacker to cause the device to reload unexpectedly, resulting in a DoS condition.&nbsp;
This vulnerability affects SNMP versions 1, 2c, and 3. To exploit this vulnerability through SNMP v2c or earlier, the attacker must know a valid read-write or read-only SNMP community string for the affected system. To exploit this vulnerability through SNMP v3, the attacker must have valid SNMP user credentials for the affected system.",,,0,0,0,0,,,,,,,CWE-805,Buffer Access with Incorrect Length Value,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the product or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Cisco,IOS,12.2(33)SCB4,,,,,,7.7,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H,N,L,L,N,C,N,N,H,3395,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-snmp-dos-sdxnSUcW|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-snmp-dos-sdxnSUcW,|,0,0,Cisco/IOS 12.2(33)SCB4,Cisco/IOS 12.2(33)SCB4,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the product or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Buffer Overflow,High,Buffer Overflow,Remote Code Execution (RCE),
CVE-2023-28550,Memory corruption in MPP performance while accessing DSM watermark using external memory address.,,,0,0,0,0,,,,,,,CWE-119,Improper Restriction of Operations within the Bounds of a Memory Buffer,Class,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.","Qualcomm, Inc.",Snapdragon,QCA8337,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,670,3,https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon QCA8337","Qualcomm, Inc./Snapdragon QCA8337","Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Buffer Overflow,High,Buffer Overflow,Privilege Escalation,
CVE-2023-33069,Memory corruption in Audio while processing the calibration data returned from ACDB loader.,,,0,0,0,0,,,,,,,CWE-120,Buffer Copy without Checking Size of Input ('Classic Buffer Overflow'),Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.","Qualcomm, Inc.",Snapdragon,WCN3610,,,,,,6.7,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,L,L,H,N,U,H,H,H,113,3,https://www.qualcomm.com/company/product-security/bulletins/february-2024-bulletin|https://www.qualcomm.com/company/product-security/bulletins/february-2024-bulletin|https://www.qualcomm.com/company/product-security/bulletins/february-2024-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon WCN3610","Qualcomm, Inc./Snapdragon WCN3610","Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that your buffer is as large as you specify.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Buffer Overflow,Medium,Buffer Overflow,Information Disclosure,
CVE-2024-26171,,,,0,0,0,0,,,,,,,CWE-190,Integer Overflow or Wraparound,Base,"Ensure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol.; Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  If possible, choose a language or compiler that performs automatic bounds checking.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Use libraries or frameworks that make it easier to handle numbers without unexpected consequences.
                  Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]; Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.
                  Use unsigned integers where possible. This makes it easier to perform validation for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values.; Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, ""not-a-number"" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]
                  Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.",Microsoft,Windows Server 2012 (Server Core installation),6.2.9200.0,,,,,,6.7,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,L,L,H,N,U,H,H,H,34,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-26171|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-26171|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-26171,||,0,0,Microsoft/Windows Server 2012 (Server Core installation) 6.2.9200.0,Microsoft/Windows Server 2012 (Server Core installation) 6.2.9200.0,"Ensure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol.; Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  If possible, choose a language or compiler that performs automatic bounds checking.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Use libraries or frameworks that make it easier to handle numbers without unexpected consequences.
                  Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]; Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.
                  Use unsigned integers where possible. This makes it easier to perform validation for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values.; Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, ""not-a-number"" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]
                  Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.",Buffer Overflow,Medium,Buffer Overflow,Denial of Service (DoS),
CVE-2023-22461,"The `sanitize-svg` package, a small SVG sanitizer to prevent cross-site scripting attacks, uses a deny-list-pattern to sanitize SVGs to prevent XSS. In doing so, literal `<script>`-tags and on-event handlers were detected in versions prior to 0.4.0. As a result, downstream software that relies on `sanitize-svg` and expects resulting SVGs to be safe, may be vulnerable to cross-site scripting. This vulnerability was addressed in v0.4.0. There are no known workarounds

",,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,< 0.4,,,,,,7.6,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:L/A:N,N,L,L,R,C,H,L,N,4,6,https://github.com/mattkrick/sanitize-svg/commit/b107e453ede7b58adcccae74a3e474c012eec85d|https://github.com/mattkrick/sanitize-svg/commit/b107e453ede7b58adcccae74a3e474c012eec85d|https://github.com/mattkrick/sanitize-svg/security/advisories/GHSA-h857-2g56-468g|https://github.com/mattkrick/sanitize-svg/security/advisories/GHSA-h857-2g56-468g|https://github.com/mattkrick/sanitize-svg/security/advisories/GHSA-h857-2g56-468g|https://github.com/mattkrick/sanitize-svg/commit/b107e453ede7b58adcccae74a3e474c012eec85d,|||||,0,0,mattkrick/sanitize-svg < 0.4,mattkrick/sanitize-svg < 0.4,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),High,Cross-site Scripting (XSS),Remote Code Execution (RCE),
CVE-2023-23877,Auth. (contributor+) Stored Cross-Site Scripting (XSS) vulnerability in bkmacdaddy designs Pinterest RSS Widget plugin <= 2.3.1 versions.,,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,,,,,,,6.5,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:L,N,L,L,R,C,L,L,L,2,3,https://patchstack.com/database/vulnerability/pinterest-rss-widget/wordpress-pinterest-rss-widget-plugin-2-3-1-cross-site-scripting-xss-vulnerability?_s_id=cve|https://patchstack.com/database/vulnerability/pinterest-rss-widget/wordpress-pinterest-rss-widget-plugin-2-3-1-cross-site-scripting-xss-vulnerability?_s_id=cve|https://patchstack.com/database/vulnerability/pinterest-rss-widget/wordpress-pinterest-rss-widget-plugin-2-3-1-cross-site-scripting-xss-vulnerability?_s_id=cve,||,0,0,bkmacdaddy designs/Pinterest RSS Widget n/a,bkmacdaddy designs/Pinterest RSS Widget n/a,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Medium,Cross-site Scripting (XSS),Privilege Escalation,
CVE-2023-28992,"Unauth. Reflected Cross-Site Scripting (XSS) vulnerability in Elliot Sowersby, RelyWP Coupon Affiliates – WooCommerce Affiliate Plugin plugin <= 5.4.3 versions.",,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,*,,,,,,7.1,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:L,N,L,N,R,C,L,L,L,2,3,https://patchstack.com/database/vulnerability/woo-coupon-usage/wordpress-coupon-affiliates-plugin-5-4-3-cross-site-scripting-xss-vulnerability?_s_id=cve|https://patchstack.com/database/vulnerability/woo-coupon-usage/wordpress-coupon-affiliates-plugin-5-4-3-cross-site-scripting-xss-vulnerability?_s_id=cve|https://patchstack.com/database/vulnerability/woo-coupon-usage/wordpress-coupon-affiliates-plugin-5-4-3-cross-site-scripting-xss-vulnerability?_s_id=cve,||,0,0,relywp/coupon_affiliates *,relywp/coupon_affiliates *,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),High,Cross-site Scripting (XSS),Information Disclosure,
CVE-2023-20201,"Multiple vulnerabilities in the web-based management interface of Cisco Prime Infrastructure and Cisco Evolved Programmable Network Manager (EPNM) could allow an authenticated, remote attacker to conduct a stored cross-site scripting (XSS) attack against a user of the interface on an affected device.
 These vulnerabilities are due to insufficient validation of user-supplied input. An attacker could exploit these vulnerabilities by persuading a user of an affected interface to view a page containing malicious HTML or script content. A successful exploit could allow the attacker to execute arbitrary script code in the context of the affected interface or access sensitive, browser-based information. To exploit these vulnerabilities, the attacker must have valid credentials to access the web-based management interface of the affected device.",,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cisco,Cisco Evolved Programmable Network Manager (EPNM),4.0.2,,,,,,4.8,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N,N,L,H,R,C,L,L,N,230,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-pi-epnm-BFjSRJP5|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-pi-epnm-BFjSRJP5|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-pi-epnm-BFjSRJP5,||,0,0,Cisco/Cisco Evolved Programmable Network Manager (EPNM) 4.0.2,Cisco/Cisco Evolved Programmable Network Manager (EPNM) 4.0.2,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Medium,Cross-site Scripting (XSS),Denial of Service (DoS),
CVE-2024-43396,"Khoj is an application that creates personal AI agents. The Automation feature allows a user to insert arbitrary HTML inside the task instructions, resulting in a Stored XSS. The q parameter for the /api/automation endpoint does not get correctly sanitized when rendered on the page, resulting in the ability of users to inject arbitrary HTML/JS. This vulnerability is fixed in 1.15.0.",,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,*,,,,,,5.4,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N,N,L,N,R,U,L,L,N,2,6,https://github.com/khoj-ai/khoj/security/advisories/GHSA-cf72-vg59-4j4h|https://github.com/khoj-ai/khoj/commit/1c7a562880eeb7354325545d2cf6c5d1d1134812|https://github.com/khoj-ai/khoj/commit/55be90cdd2f9d6a09c8bf9ceea52fc36b9201626|https://github.com/khoj-ai/khoj/security/advisories/GHSA-cf72-vg59-4j4h|https://github.com/khoj-ai/khoj/commit/1c7a562880eeb7354325545d2cf6c5d1d1134812|https://github.com/khoj-ai/khoj/commit/55be90cdd2f9d6a09c8bf9ceea52fc36b9201626,|||||,0,0,khoj/khoj *,khoj/khoj *,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Medium,Cross-site Scripting (XSS),Remote Code Execution (RCE),
CVE-2025-3100,"The WP Project Manager – Task, team, and project management plugin featuring kanban board and gantt charts plugin for WordPress is vulnerable to Stored Cross-Site Scripting via SVG File uploads in all versions up to, and including, 2.6.22 due to insufficient input sanitization and output escaping in tasks discussion. This makes it possible for authenticated attackers, with Subscriber-level access and above, and permissions granted by an Administrator, to inject arbitrary web scripts in pages that will execute whenever a user accesses the SVG file.",,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,*,,,,,,6.4,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N,N,L,L,N,C,L,L,N,1,6,https://plugins.trac.wordpress.org/browser/wedevs-project-manager/trunk/src/File/Helper/File.php#L56|https://plugins.trac.wordpress.org/changeset/3268509/wedevs-project-manager/trunk/bootstrap/loaders.php|https://www.wordfence.com/threat-intel/vulnerabilities/id/4d62b087-b0ca-4fa8-921b-5eeb3fa76596?source=cve|https://www.wordfence.com/threat-intel/vulnerabilities/id/4d62b087-b0ca-4fa8-921b-5eeb3fa76596?source=cve|https://plugins.trac.wordpress.org/browser/wedevs-project-manager/trunk/src/File/Helper/File.php#L56|https://plugins.trac.wordpress.org/changeset/3268509/wedevs-project-manager/trunk/bootstrap/loaders.php,|||||,0,0,"wedevs/WP Project Manager – Task, team, and project management plugin featuring kanban board and gantt charts *","wedevs/WP Project Manager – Task, team, and project management plugin featuring kanban board and gantt charts *","Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Medium,Cross-site Scripting (XSS),Privilege Escalation,
CVE-2023-20222,"A vulnerability in the web-based management interface of Cisco Prime Infrastructure and Cisco Evolved Programmable Network Manager (EPNM) could allow an unauthenticated, remote attacker to conduct a cross-site scripting (XSS) attack against a user of the interface on an affected device.
 The vulnerability is due to insufficient validation of user-supplied input by the web-based management interface of an affected system. An attacker could exploit this vulnerability by injecting malicious code into specific pages of the interface. A successful exploit could allow the attacker to execute arbitrary script code in the context of the affected interface or access sensitive, browser-based information.",,,0,0,0,0,,,,,,,CWE-80,Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS),Variant,"Carefully check each input parameter against a rigorous positive specification (allowlist) defining the specific characters and format allowed. All input should be neutralized, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. We often encounter data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.",Cisco,Cisco Prime Infrastructure,3.0.3,,,,,,4.8,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N,N,L,H,R,C,L,L,N,288,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-pi-epnm-storedxss-tTjO62r|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-pi-epnm-storedxss-tTjO62r|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-pi-epnm-storedxss-tTjO62r,||,0,0,Cisco/Cisco Prime Infrastructure 3.0.3,Cisco/Cisco Prime Infrastructure 3.0.3,"Carefully check each input parameter against a rigorous positive specification (allowlist) defining the specific characters and format allowed. All input should be neutralized, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. We often encounter data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.",Cross-site Scripting (XSS),Medium,Cross-site Scripting (XSS),Information Disclosure,
CVE-2021-23860,An error in a page handler of the VRM may lead to a reflected cross site scripting (XSS) in the web-based interface. To exploit this vulnerability an attack must be able to modify the HTTP header that is sent. This issue also affects installations of the DIVAR IP and BVMS with VRM installed.,,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,4,,,,,,5,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:L/I:L/A:L,N,H,N,R,U,L,L,L,11,3,https://psirt.bosch.com/security-advisories/bosch-sa-043434-bt.html|https://psirt.bosch.com/security-advisories/bosch-sa-043434-bt.html|https://psirt.bosch.com/security-advisories/bosch-sa-043434-bt.html,||,0,0,Bosch/VRM 4.0,Bosch/VRM 4.0,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Medium,Cross-site Scripting (XSS),Denial of Service (DoS),
CVE-2023-44310,"Stored cross-site scripting (XSS) vulnerability in Page Tree menu Liferay Portal 7.3.6 through 7.4.3.78, and Liferay DXP 7.3 fix pack 1 through update 23, and 7.4 before update 79 allows remote attackers to inject arbitrary web script or HTML via a crafted payload injected into page's ""Name"" text field.",,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,*,,,,,,9,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H,N,L,L,R,C,H,H,H,6,3,https://liferay.dev/portal/security/known-vulnerabilities/-/asset_publisher/jekt/content/cve-2023-44310|https://liferay.dev/portal/security/known-vulnerabilities/-/asset_publisher/jekt/content/cve-2023-44310|https://liferay.dev/portal/security/known-vulnerabilities/-/asset_publisher/jekt/content/cve-2023-44310,||,0,0,liferay/liferay_portal *,liferay/liferay_portal *,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Critical,Cross-site Scripting (XSS),Remote Code Execution (RCE),
CVE-2022-29168,"Wire is a secure messaging application. Wire is vulnerable to arbitrary HTML and Javascript execution via insufficient escaping when rendering `@mentions` in the wire-webapp. If a user receives and views a malicious message, arbitrary code is injected and executed in the context of the victim allowing the attacker to fully control the user account. Wire-desktop clients that are connected to a vulnerable wire-webapp version are also vulnerable to this attack. The issue has been fixed in wire-webapp 2022-05-04-production.0 and is already deployed on all Wire managed services. On-premise instances of wire-webapp need to be updated to docker tag 2022-05-04-production.0-v0.29.7-0-a6f2ded or wire-server 2022-05-04 (chart/4.11.0) or later. No known workarounds exist.",,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",wire,wire-webapp,2017-09-26-13-00,,,,,,9.6,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H,N,L,N,R,C,H,H,H,674,3,https://github.com/wireapp/wire-webapp/security/advisories/GHSA-jgv3-4j56-fvh6|https://github.com/wireapp/wire-webapp/security/advisories/GHSA-jgv3-4j56-fvh6|https://github.com/wireapp/wire-webapp/security/advisories/GHSA-jgv3-4j56-fvh6,||,0,0,wire/wire-webapp 2017-09-26-13-00,wire/wire-webapp 2017-09-26-13-00,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Critical,Cross-site Scripting (XSS),Privilege Escalation,
CVE-2025-1467,Versions of the package tarteaucitronjs before 1.17.0 are vulnerable to Cross-site Scripting (XSS) via the getElemWidth() and getElemHeight(). This is related to [SNYK-JS-TARTEAUCITRONJS-8366541](https://security.snyk.io/vuln/SNYK-JS-TARTEAUCITRONJS-8366541),,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,0,,,,,,6.1,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N/E:P,N,L,N,R,C,L,L,N,1,8,https://gist.github.com/Rudloff/d48f525215bd5426cbb076116c4422dd|https://github.com/AmauriC/tarteaucitron.js/commit/12490579001d5caa187adcaecb01da570a12076b|https://github.com/AmauriC/tarteaucitron.js/issues/1184|https://security.snyk.io/vuln/SNYK-JS-TARTEAUCITRONJS-8731160|https://security.snyk.io/vuln/SNYK-JS-TARTEAUCITRONJS-8731160|https://github.com/AmauriC/tarteaucitron.js/commit/12490579001d5caa187adcaecb01da570a12076b|https://github.com/AmauriC/tarteaucitron.js/issues/1184|https://gist.github.com/Rudloff/d48f525215bd5426cbb076116c4422dd,|||||||,0,0,n/a/tarteaucitronjs 0,n/a/tarteaucitronjs 0,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Medium,Cross-site Scripting (XSS),Information Disclosure,
CVE-2022-28707,"On F5 BIG-IP 16.1.x versions prior to 16.1.2.2, 15.1.x versions prior to 15.1.5.1, and 14.1.x versions prior to 14.1.4.6, a stored cross-site scripting (XSS) vulnerability exists in an undisclosed page of the BIG-IP Configuration utility (also referred to as the BIG-IP TMUI) that allows an attacker to execute JavaScript in the context of the currently logged-in user. Note: Software versions which have reached End of Technical Support (EoTS) are not evaluated",,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",f5,Other_Product,15.1.4,,,,,,8,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H,N,L,L,R,U,H,H,H,161,3,https://support.f5.com/csp/article/K70300233|https://support.f5.com/csp/article/K70300233|https://support.f5.com/csp/article/K70300233,||,0,0,f5/big-ip_local_traffic_manager 15.1.4,f5/big-ip_local_traffic_manager 15.1.4,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),High,Cross-site Scripting (XSS),Denial of Service (DoS),
CVE-2024-1972,A vulnerability was found in SourceCodester Online Job Portal 1.0 and classified as problematic. Affected by this issue is some unknown functionality of the file /Employer/EditProfile.php. The manipulation of the argument Address leads to cross site scripting. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The identifier of this vulnerability is VDB-255128.,,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,1,,,,,,3.5,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N,N,L,L,R,U,N,L,N,2,9,https://prnt.sc/gtk7Fj43Qwy9|https://prnt.sc/gtk7Fj43Qwy9|https://vuldb.com/?ctiid.255128|https://vuldb.com/?ctiid.255128|https://vuldb.com/?id.255128|https://vuldb.com/?id.255128|https://vuldb.com/?id.255128|https://vuldb.com/?ctiid.255128|https://prnt.sc/gtk7Fj43Qwy9,||||||||,0,0,oretnom23/online_job_portal 1.0,oretnom23/online_job_portal 1.0,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Low,Cross-site Scripting (XSS),Remote Code Execution (RCE),
CVE-2023-20204,"A vulnerability in the web-based management interface of Cisco BroadWorks CommPilot Application Software could allow an authenticated, remote attacker to conduct a cross-site scripting (XSS) attack against a user of the interface.
 This vulnerability exists because the web-based management interface does not properly validate user-supplied input. An attacker could exploit this vulnerability by persuading a user to click a crafted link. A successful exploit could allow the attacker to execute arbitrary script code in the context of the affected interface or access sensitive, browser-based information.",,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cisco,Cisco BroadWorks,24.0 ap382857,,,,,,5.4,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N,N,L,L,R,C,L,L,N,2417,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-commpilot-xss-jC46sezF|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-commpilot-xss-jC46sezF|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-commpilot-xss-jC46sezF,||,0,0,Cisco/Cisco BroadWorks 24.0 ap382857,Cisco/Cisco BroadWorks 24.0 ap382857,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Medium,Cross-site Scripting (XSS),Privilege Escalation,
CVE-2024-2784,"The The Plus Addons for Elementor plugin for WordPress is vulnerable to Stored Cross-Site Scripting via the Hover Card widget in all versions up to, and including, 5.5.4 due to insufficient input sanitization and output escaping on user supplied attributes. This makes it possible for authenticated attackers, with contributor-level access and above, to inject arbitrary web scripts in pages that will execute whenever a user accesses an injected page.",,,0,0,0,0,,,,,,,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,*,,,,,,6.4,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N,N,L,L,N,C,L,L,N,2,6,https://plugins.trac.wordpress.org/changeset/3090866/|https://plugins.trac.wordpress.org/changeset/3090866/|https://www.wordfence.com/threat-intel/vulnerabilities/id/cc6fdb7c-b750-4f03-9785-a9dc7573580d?source=cve|https://www.wordfence.com/threat-intel/vulnerabilities/id/cc6fdb7c-b750-4f03-9785-a9dc7573580d?source=cve|https://www.wordfence.com/threat-intel/vulnerabilities/id/cc6fdb7c-b750-4f03-9785-a9dc7573580d?source=cve|https://plugins.trac.wordpress.org/changeset/3090866/,|||||,0,0,posimyth/the_plus_addons_for_elementor *,posimyth/the_plus_addons_for_elementor *,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.; Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
                  For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
                  Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:
                     
                        HTML body
                        Element attributes (such as src=""XYZ"")
                        URIs
                        JavaScript sections
                        Cascading Style Sheets and style property
                     
                  etc. Note that HTML Entity Encoding is only appropriate for the HTML body.
                  Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.; Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.
                  The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks.; With Struts, write all data from form beans with the bean's filter attribute set to true.; To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (""<3"") would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the ""<"" character, which would need to be escaped or otherwise handled. In this case, stripping the ""<"" might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.
                  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cross-site Scripting (XSS),Medium,Cross-site Scripting (XSS),Information Disclosure,
CVE-2022-2274,The OpenSSL 3.0.4 release introduced a serious bug in the RSA implementation for X86_64 CPUs supporting the AVX512IFMA instructions. This issue makes the RSA implementation with 2048 bit private keys incorrect on such machines and memory corruption will happen during the computation. As a consequence of the memory corruption an attacker may be able to trigger a remote code execution on the machine performing the computation. SSL/TLS servers or other servers using 2048 bit RSA private keys running on machines supporting AVX512IFMA instructions of the X86_64 architecture are affected by this issue.,,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Other_Vendor,Other_Product,Affects OpenSSL 3.0.4,,,,,,9.8,3.9,5.9,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,N,L,N,N,U,H,H,H,3,12,https://git.openssl.org/gitweb/?p=openssl.git%3Ba=commitdiff%3Bh=4d8a88c134df634ba610ff8db1eb8478ac5fd345|https://git.openssl.org/gitweb/?p=openssl.git%3Ba=commitdiff%3Bh=4d8a88c134df634ba610ff8db1eb8478ac5fd345|https://github.com/openssl/openssl/issues/18625|https://github.com/openssl/openssl/issues/18625|https://security.netapp.com/advisory/ntap-20220715-0010/|https://security.netapp.com/advisory/ntap-20220715-0010/|https://www.openssl.org/news/secadv/20220705.txt|https://www.openssl.org/news/secadv/20220705.txt|https://github.com/openssl/openssl/issues/18625|https://git.openssl.org/gitweb/?p=openssl.git%3Ba=commitdiff%3Bh=4d8a88c134df634ba610ff8db1eb8478ac5fd345|https://www.openssl.org/news/secadv/20220705.txt|https://security.netapp.com/advisory/ntap-20220715-0010/,|||||||||||,0,0,OpenSSL/OpenSSL Affects OpenSSL 3.0.4,OpenSSL/OpenSSL Affects OpenSSL 3.0.4,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,Critical,Out-of-bounds Write,Buffer Overflow,
CVE-2023-24854,Memory Corruption in WLAN HOST while parsing QMI WLAN Firmware response message.,,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.","Qualcomm, Inc.",Snapdragon,AR8035,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,326,3,https://www.qualcomm.com/company/product-security/bulletins/july-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/july-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/july-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon AR8035","Qualcomm, Inc./Snapdragon AR8035","Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,High,Out-of-bounds Write,Denial of Service (DoS),
CVE-2024-44390,Tenda FH1206 V1.2.0.8(8155)_EN contains a Buffer Overflow vulnerability via the function formWrlsafeset.,,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Other_Vendor,Other_Product,,,,,,,8,,,CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,A,L,L,N,U,H,H,H,1,2,https://github.com/GroundCTL2MajorTom/pocs/blob/main/tenda_FH1206_buffer_overflow8.md|https://github.com/GroundCTL2MajorTom/pocs/blob/main/tenda_FH1206_buffer_overflow8.md,|,0,0,n/a/n/a n/a,n/a/n/a n/a,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,High,Out-of-bounds Write,Remote Code Execution (RCE),
CVE-2021-24042,"The calling logic for WhatsApp for Android prior to v2.21.23, WhatsApp Business for Android prior to v2.21.23, WhatsApp for iOS prior to v2.21.230, WhatsApp Business for iOS prior to v2.21.230, WhatsApp for KaiOS prior to v2.2143, WhatsApp Desktop prior to v2.2146 could have allowed an out-of-bounds write if a user makes a 1:1 call to a malicious actor.",,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Other_Vendor,Other_Product,v2.21.23,,,,,,9.8,3.9,5.9,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,N,L,N,N,U,H,H,H,26,3,https://www.whatsapp.com/security/advisories/2021/|https://www.whatsapp.com/security/advisories/2021/|https://www.whatsapp.com/security/advisories/2021/,||,0,0,Facebook/WhatsApp for Android v2.21.23,Facebook/WhatsApp for Android v2.21.23,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,Critical,Out-of-bounds Write,Privilege Escalation,
CVE-2023-37375,"A vulnerability has been identified in Tecnomatix Plant Simulation V2201 (All versions < V2201.0008), Tecnomatix Plant Simulation V2302 (All versions < V2302.0002). The affected application is vulnerable to stack-based buffer overflow while parsing specially crafted SPP files. This could allow an attacker to execute code in the context of the current process. (ZDI-CAN-21060)",,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Siemens,Other_Product,All versions < V2201.0008,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H/E:P/RL:O/RC:C,L,L,N,R,U,H,H,H,6,3,https://cert-portal.siemens.com/productcert/pdf/ssa-764801.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-764801.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-764801.pdf,||,0,0,Siemens/Tecnomatix Plant Simulation V2201 All versions < V2201.0008,Siemens/Tecnomatix Plant Simulation V2201 All versions < V2201.0008,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,High,Out-of-bounds Write,Information Disclosure,
CVE-2022-42944,A malicious crafted dwf or .pct file when consumed through DesignReview.exe application could lead to memory corruption vulnerability by read access violation. This vulnerability in conjunction with other vulnerabilities could lead to code execution in the context of the current process.,,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",autodesk,Other_Product,2022,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,L,L,N,R,U,H,H,H,52,5,https://www.autodesk.com/trust/security-advisories/adsk-sa-2022-0004|https://www.autodesk.com/trust/security-advisories/adsk-sa-2022-0004|https://www.autodesk.com/trust/security-advisories/adsk-sa-2022-0004|https://www.autodesk.com/trust/security-advisories/adsk-sa-2022-0004|https://www.autodesk.com/trust/security-advisories/adsk-sa-2022-0004,||||,0,0,autodesk/autocad_mep 2022,autodesk/autocad_mep 2022,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,High,Out-of-bounds Write,Cross-Site Scripting (XSS),
CVE-2022-33233,Memory corruption due to configuration weakness in modem wile sending command to write protected files.,,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.","Qualcomm, Inc.",Snapdragon,WCN3610,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,402,3,https://www.qualcomm.com/company/product-security/bulletins/february-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/february-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/february-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon WCN3610","Qualcomm, Inc./Snapdragon WCN3610","Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,High,Out-of-bounds Write,SQL Injection,
CVE-2023-20109,"A vulnerability in the Cisco Group Encrypted Transport VPN (GET VPN) feature of Cisco IOS Software and Cisco IOS XE Software could allow an authenticated, remote attacker who has administrative control of either a group member or a key server to execute arbitrary code on an affected device or cause the device to crash.
 This vulnerability is due to insufficient validation of attributes in the Group Domain of Interpretation (GDOI) and G-IKEv2 protocols of the GET VPN feature. An attacker could exploit this vulnerability by either compromising an installed key server or modifying the configuration of a group member to point to a key server that is controlled by the attacker. A successful exploit could allow the attacker to execute arbitrary code and gain full control of the affected system or cause the affected system to reload, resulting in a denial of service (DoS) condition. For more information, see the Details [""#details""] section of this advisory.",,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",cisco,ios,15.6\(3\)m3a,,,,,,6.6,,,CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:H/A:H,N,H,H,N,U,H,H,H,2076,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-getvpn-rce-g8qR68sx|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-getvpn-rce-g8qR68sx|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-getvpn-rce-g8qR68sx,||,0,0,cisco/ios 15.6\(3\)m3a,cisco/ios 15.6\(3\)m3a,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,Medium,Out-of-bounds Write,Denial of Service (DoS),
CVE-2021-39682,"In mgm_alloc_page of memory_group_manager.c, there is a possible out of bounds write due to an incorrect bounds check. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-201677538References: N/A",,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Other_Vendor,Android,Android kernel,,,,,,7.8,1.8,5.9,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,2,3,https://source.android.com/security/bulletin/pixel/2022-01-01|https://source.android.com/security/bulletin/pixel/2022-01-01|https://source.android.com/security/bulletin/pixel/2022-01-01,||,0,0,n/a/Android Android kernel,n/a/Android Android kernel,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,High,Out-of-bounds Write,Remote Code Execution (RCE),
CVE-2024-23155,"A maliciously crafted MODEL file, when parsed in atf_asm_interface.dll through Autodesk applications, can be used to cause a Heap-based Buffer Overflow. A malicious actor can leverage this vulnerability to cause a crash or execute arbitrary code in the context of the current process.",,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Autodesk,Other_Product,2025,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,L,L,N,R,U,H,H,H,90,5,https://www.autodesk.com/trust/security-advisories/adsk-sa-2024-0010|https://www.autodesk.com/trust/security-advisories/adsk-sa-2024-0010|https://www.autodesk.com/trust/security-advisories/adsk-sa-2024-0010|https://www.autodesk.com/trust/security-advisories/adsk-sa-2024-0010|https://www.autodesk.com/trust/security-advisories/adsk-sa-2024-0010,||||,0,0,Autodesk/Civil 3D 2025,Autodesk/Civil 3D 2025,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,High,Out-of-bounds Write,Privilege Escalation,
CVE-2023-28538,Memory corruption in WIN Product while invoking WinAcpi update driver in the UEFI region.,,,0,0,0,0,,,,,,,CWE-787,Out-of-bounds Write,Base,"Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.","Qualcomm, Inc.",Snapdragon,Snapdragon XR1 Platform,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,260,3,https://www.qualcomm.com/company/product-security/bulletins/september-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/september-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/september-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon Snapdragon XR1 Platform","Qualcomm, Inc./Snapdragon Snapdragon XR1 Platform","Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.
                  Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Consider adhering to the following rules when allocating and managing an application's memory:
                     
                        Double check that the buffer is as large as specified.
                        When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.
                        Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.
                        If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.   
	          For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].; Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",Out-of-bounds Write,High,Out-of-bounds Write,Buffer Overflow,
CVE-2024-23353,"Transient DOS while decoding attach reject message received by UE, when IEI is set to ESM_IEI.",,,0,0,0,0,,,,,,,CWE-125,Out-of-bounds Read,Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.","Qualcomm, Inc.",Snapdragon,SW5100P,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,488,2,https://docs.qualcomm.com/product/publicresources/securitybulletin/august-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/august-2024-bulletin.html,|,0,0,"Qualcomm, Inc./Snapdragon SW5100P","Qualcomm, Inc./Snapdragon SW5100P","Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.",Out-of-bounds Read,High,Out-of-bounds Read,Denial of Service (DoS),
CVE-2022-42387,This vulnerability allows remote attackers to disclose sensitive information on affected installations of PDF-XChange Editor. User interaction is required to exploit this vulnerability in that the target must visit a malicious page or open a malicious file. The specific flaw exists within the parsing of U3D files. Crafted data in a U3D file can trigger a read past the end of an allocated buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of the current process. Was ZDI-CAN-18656.,,,0,0,0,0,,,,,,,CWE-125,Out-of-bounds Read,Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.",Other_Vendor,Other_Product,*,,,,,,3.3,,,CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N,L,L,N,R,U,L,N,N,2,6,https://www.tracker-software.com/product/pdf-xchange-editor/history|https://www.tracker-software.com/product/pdf-xchange-editor/history|https://www.zerodayinitiative.com/advisories/ZDI-22-1378/|https://www.zerodayinitiative.com/advisories/ZDI-22-1378/|https://www.tracker-software.com/product/pdf-xchange-editor/history|https://www.zerodayinitiative.com/advisories/ZDI-22-1378/,|||||,0,0,pdf-xchange/pdf-xchange_editor *,pdf-xchange/pdf-xchange_editor *,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.",Out-of-bounds Read,Low,Out-of-bounds Read,Remote Code Execution (RCE),
CVE-2024-33050,Transient DOS while parsing MBSSID during new IE generation in beacon/probe frame when IE length check is either missing or improper.,,,0,0,0,0,,,,,,,CWE-125,Out-of-bounds Read,Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.","Qualcomm, Inc.",Snapdragon,Snapdragon 695 5G Mobile Platform,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,514,2,https://docs.qualcomm.com/product/publicresources/securitybulletin/september-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/september-2024-bulletin.html,|,0,0,"Qualcomm, Inc./Snapdragon Snapdragon 695 5G Mobile Platform","Qualcomm, Inc./Snapdragon Snapdragon 695 5G Mobile Platform","Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.",Out-of-bounds Read,High,Out-of-bounds Read,Privilege Escalation,
CVE-2023-21669,Information Disclosure in WLAN HOST while sending DPP action frame to peer with an invalid source address.,,,0,0,0,0,,,,,,,CWE-125,Out-of-bounds Read,Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.","Qualcomm, Inc.",Snapdragon,QCA6391,,,,,,8.2,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:L,N,L,N,N,U,H,N,L,120,3,https://www.qualcomm.com/company/product-security/bulletins/june-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/june-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/june-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon QCA6391","Qualcomm, Inc./Snapdragon QCA6391","Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.",Out-of-bounds Read,High,Out-of-bounds Read,Information Disclosure,
CVE-2022-40524,Memory corruption due to buffer over-read in Modem while processing SetNativeHandle RTP service.,,,0,0,0,0,,,,,,,CWE-125,Out-of-bounds Read,Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.","Qualcomm, Inc.",Snapdragon,QCA6574AU,,,,,,6.7,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,L,L,H,N,U,H,H,H,76,3,https://www.qualcomm.com/company/product-security/bulletins/september-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/september-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/september-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon QCA6574AU","Qualcomm, Inc./Snapdragon QCA6574AU","Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.",Out-of-bounds Read,Medium,Out-of-bounds Read,Cross-Site Scripting (XSS),
CVE-2025-21324,,,,0,0,0,0,,,,,,,CWE-125,Out-of-bounds Read,Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.",microsoft,windows_10_21h2,*,,,,,,6.6,,,CVSS:3.1/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,P,L,L,N,U,H,H,H,43,2,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21324|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21324,|,0,0,microsoft/windows_10_21h2 *,microsoft/windows_10_21h2 *,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.",Out-of-bounds Read,Medium,Out-of-bounds Read,SQL Injection,
CVE-2025-39735,"In the Linux kernel, the following vulnerability has been resolved:

jfs: fix slab-out-of-bounds read in ea_get()

During the ""size_check"" label in ea_get(), the code checks if the extended
attribute list (xattr) size matches ea_size. If not, it logs
""ea_get: invalid extended attribute"" and calls print_hex_dump().

Here, EALIST_SIZE(ea_buf->xattr) returns 4110417968, which exceeds
INT_MAX (2,147,483,647). Then ea_size is clamped:

	int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));

Although clamp_t aims to bound ea_size between 0 and 4110417968, the upper
limit is treated as an int, causing an overflow above 2^31 - 1. This leads
""size"" to wrap around and become negative (-184549328).

The ""size"" is then passed to print_hex_dump() (called ""len"" in
print_hex_dump()), it is passed as type size_t (an unsigned
type), this is then stored inside a variable called
""int remaining"", which is then assigned to ""int linelen"" which
is then passed to hex_dump_to_buffer(). In print_hex_dump()
the for loop, iterates through 0 to len-1, where len is
18446744073525002176, calling hex_dump_to_buffer()
on each iteration:

	for (i = 0; i < len; i += rowsize) {
		linelen = min(remaining, rowsize);
		remaining -= rowsize;

		hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,
				   linebuf, sizeof(linebuf), ascii);

		...
	}

The expected stopping condition (i < len) is effectively broken
since len is corrupted and very large. This eventually leads to
the ""ptr+i"" being passed to hex_dump_to_buffer() to get closer
to the end of the actual bounds of ""ptr"", eventually an out of
bounds access is done in hex_dump_to_buffer() in the following
for loop:

	for (j = 0; j < len; j++) {
			if (linebuflen < lx + 2)
				goto overflow2;
			ch = ptr[j];
		...
	}

To fix this we should validate ""EALIST_SIZE(ea_buf->xattr)""
before it is utilised.",,,0,0,0,0,,,,,,,CWE-125,Out-of-bounds Read,Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.",Linux,Linux,4ea25fa8747fb8b1e5a11d87b852023ecf7ae420,,,,,,7.1,1.8,5.2,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H,L,L,L,N,U,H,N,H,21,18,https://git.kernel.org/stable/c/0beddc2a3f9b9cf7d8887973041e36c2d0fa3652|https://git.kernel.org/stable/c/16d3d36436492aa248b2d8045e75585ebcc2f34d|https://git.kernel.org/stable/c/3d6fd5b9c6acbc005e53d0211c7381f566babec1|https://git.kernel.org/stable/c/46e2c031aa59ea65128991cbca474bd5c0c2ecdb|https://git.kernel.org/stable/c/50afcee7011155933d8d5e8832f52eeee018cfd3|https://git.kernel.org/stable/c/5263822558a8a7c0d0248d5679c2dcf4d5cda61f|https://git.kernel.org/stable/c/78c9cbde8880ec02d864c166bcb4fe989ce1d95f|https://git.kernel.org/stable/c/a8c31808925b11393a6601f534bb63bac5366bab|https://git.kernel.org/stable/c/fdf480da5837c23b146c4743c18de97202fcab37|https://git.kernel.org/stable/c/3d6fd5b9c6acbc005e53d0211c7381f566babec1|https://git.kernel.org/stable/c/50afcee7011155933d8d5e8832f52eeee018cfd3|https://git.kernel.org/stable/c/78c9cbde8880ec02d864c166bcb4fe989ce1d95f|https://git.kernel.org/stable/c/46e2c031aa59ea65128991cbca474bd5c0c2ecdb|https://git.kernel.org/stable/c/a8c31808925b11393a6601f534bb63bac5366bab|https://git.kernel.org/stable/c/0beddc2a3f9b9cf7d8887973041e36c2d0fa3652|https://git.kernel.org/stable/c/16d3d36436492aa248b2d8045e75585ebcc2f34d|https://git.kernel.org/stable/c/5263822558a8a7c0d0248d5679c2dcf4d5cda61f|https://git.kernel.org/stable/c/fdf480da5837c23b146c4743c18de97202fcab37,|||||||||||||||||,0,0,Linux/Linux 4ea25fa8747fb8b1e5a11d87b852023ecf7ae420,Linux/Linux 4ea25fa8747fb8b1e5a11d87b852023ecf7ae420,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.; Use a language that provides appropriate memory abstractions.",Out-of-bounds Read,High,Out-of-bounds Read,Denial of Service (DoS),
CVE-2024-21472,Memory corruption in Kernel while handling GPU operations.,,,0,0,0,0,,,,,,,CWE-416,Use After Free,Variant,"Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.","Qualcomm, Inc.",Snapdragon,SA9000P,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,39,3,https://docs.qualcomm.com/product/publicresources/securitybulletin/april-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/april-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/april-2024-bulletin.html,||,0,0,"Qualcomm, Inc./Snapdragon SA9000P","Qualcomm, Inc./Snapdragon SA9000P","Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",Use After Free,High,Use After Free,Remote Code Execution (RCE),
CVE-2022-4181,Use after free in Forms in Google Chrome prior to 108.0.5359.71 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High),,,0,0,0,0,,,,,,,CWE-416,Use After Free,Variant,"Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",google,chrome,*,,,,,,8.8,2.8,5.9,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,N,L,N,R,U,H,H,H,2,12,https://chromereleases.googleblog.com/2022/11/stable-channel-update-for-desktop_29.html|https://chromereleases.googleblog.com/2022/11/stable-channel-update-for-desktop_29.html|https://crbug.com/1382581|https://crbug.com/1382581|https://security.gentoo.org/glsa/202305-10|https://security.gentoo.org/glsa/202305-10|https://security.gentoo.org/glsa/202311-11|https://security.gentoo.org/glsa/202311-11|https://chromereleases.googleblog.com/2022/11/stable-channel-update-for-desktop_29.html|https://crbug.com/1382581|https://security.gentoo.org/glsa/202305-10|https://security.gentoo.org/glsa/202311-11,|||||||||||,0,0,google/chrome *,google/chrome *,"Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",Use After Free,High,Use After Free,Privilege Escalation,
CVE-2025-26601,"A use-after-free flaw was found in X.Org and Xwayland. When changing an alarm, the values of the change mask are evaluated one after the other, changing the trigger values as requested, and eventually, SyncInitTrigger() is called. If one of the changes triggers an error, the function will return early, not adding the new sync object, possibly causing a use-after-free when the alarm eventually triggers.",,,0,0,0,0,,,,,,,CWE-416,Use After Free,Variant,"Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",Red Hat,Other_Product,0:1.11.0-8.el8_4.12,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,23,39,https://access.redhat.com/errata/RHSA-2025:2500|https://access.redhat.com/errata/RHSA-2025:2502|https://access.redhat.com/errata/RHSA-2025:2861|https://access.redhat.com/errata/RHSA-2025:2862|https://access.redhat.com/errata/RHSA-2025:2865|https://access.redhat.com/errata/RHSA-2025:2866|https://access.redhat.com/errata/RHSA-2025:2873|https://access.redhat.com/errata/RHSA-2025:2874|https://access.redhat.com/errata/RHSA-2025:2875|https://access.redhat.com/errata/RHSA-2025:2879|https://access.redhat.com/errata/RHSA-2025:2880|https://access.redhat.com/security/cve/CVE-2025-26601|https://bugzilla.redhat.com/show_bug.cgi?id=2345251|https://access.redhat.com/errata/RHSA-2025:2500|https://access.redhat.com/errata/RHSA-2025:2502|https://access.redhat.com/errata/RHSA-2025:2861|https://access.redhat.com/errata/RHSA-2025:2862|https://access.redhat.com/errata/RHSA-2025:2865|https://access.redhat.com/errata/RHSA-2025:2866|https://access.redhat.com/errata/RHSA-2025:2873|https://access.redhat.com/errata/RHSA-2025:2874|https://access.redhat.com/errata/RHSA-2025:2875|https://access.redhat.com/errata/RHSA-2025:2879|https://access.redhat.com/errata/RHSA-2025:2880|https://access.redhat.com/security/cve/CVE-2025-26601|https://bugzilla.redhat.com/show_bug.cgi?id=2345251|https://access.redhat.com/errata/RHSA-2025:2500|https://access.redhat.com/errata/RHSA-2025:2502|https://access.redhat.com/errata/RHSA-2025:2861|https://access.redhat.com/errata/RHSA-2025:2862|https://access.redhat.com/errata/RHSA-2025:2865|https://access.redhat.com/errata/RHSA-2025:2866|https://access.redhat.com/errata/RHSA-2025:2873|https://access.redhat.com/errata/RHSA-2025:2874|https://access.redhat.com/errata/RHSA-2025:2875|https://access.redhat.com/errata/RHSA-2025:2879|https://access.redhat.com/errata/RHSA-2025:2880|https://access.redhat.com/security/cve/CVE-2025-26601|https://bugzilla.redhat.com/show_bug.cgi?id=2345251,||||||||||||||||||||||||||||||||||||||,0,0,Red Hat/Red Hat Enterprise Linux 8.4 Advanced Mission Critical Update Support 0:1.11.0-8.el8_4.12,Red Hat/Red Hat Enterprise Linux 8.4 Advanced Mission Critical Update Support 0:1.11.0-8.el8_4.12,"Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",Use After Free,High,Use After Free,Buffer Overflow,
CVE-2023-33120,Memory corruption in Audio when memory map command is executed consecutively in ADSP.,,,0,0,0,0,,,,,,,CWE-416,Use After Free,Variant,"Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.","Qualcomm, Inc.",Snapdragon,WCD9326,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,232,3,https://www.qualcomm.com/company/product-security/bulletins/january-2024-bulletin|https://www.qualcomm.com/company/product-security/bulletins/january-2024-bulletin|https://www.qualcomm.com/company/product-security/bulletins/january-2024-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon WCD9326","Qualcomm, Inc./Snapdragon WCD9326","Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",Use After Free,High,Use After Free,Denial of Service (DoS),
CVE-2025-26600,"A use-after-free flaw was found in X.Org and Xwayland. When a device is removed while still frozen, the events queued for that device remain while the device is freed. Replaying the events will cause a use-after-free.",,,0,0,0,0,,,,,,,CWE-416,Use After Free,Variant,"Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",Red Hat,Other_Product,0:1.12.0-6.el8_6.13,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,23,39,https://access.redhat.com/errata/RHSA-2025:2500|https://access.redhat.com/errata/RHSA-2025:2502|https://access.redhat.com/errata/RHSA-2025:2861|https://access.redhat.com/errata/RHSA-2025:2862|https://access.redhat.com/errata/RHSA-2025:2865|https://access.redhat.com/errata/RHSA-2025:2866|https://access.redhat.com/errata/RHSA-2025:2873|https://access.redhat.com/errata/RHSA-2025:2874|https://access.redhat.com/errata/RHSA-2025:2875|https://access.redhat.com/errata/RHSA-2025:2879|https://access.redhat.com/errata/RHSA-2025:2880|https://access.redhat.com/security/cve/CVE-2025-26600|https://bugzilla.redhat.com/show_bug.cgi?id=2345252|https://access.redhat.com/errata/RHSA-2025:2500|https://access.redhat.com/errata/RHSA-2025:2502|https://access.redhat.com/errata/RHSA-2025:2861|https://access.redhat.com/errata/RHSA-2025:2862|https://access.redhat.com/errata/RHSA-2025:2865|https://access.redhat.com/errata/RHSA-2025:2866|https://access.redhat.com/errata/RHSA-2025:2873|https://access.redhat.com/errata/RHSA-2025:2874|https://access.redhat.com/errata/RHSA-2025:2875|https://access.redhat.com/errata/RHSA-2025:2879|https://access.redhat.com/errata/RHSA-2025:2880|https://access.redhat.com/security/cve/CVE-2025-26600|https://bugzilla.redhat.com/show_bug.cgi?id=2345252|https://access.redhat.com/errata/RHSA-2025:2500|https://access.redhat.com/errata/RHSA-2025:2502|https://access.redhat.com/errata/RHSA-2025:2861|https://access.redhat.com/errata/RHSA-2025:2862|https://access.redhat.com/errata/RHSA-2025:2865|https://access.redhat.com/errata/RHSA-2025:2866|https://access.redhat.com/errata/RHSA-2025:2873|https://access.redhat.com/errata/RHSA-2025:2874|https://access.redhat.com/errata/RHSA-2025:2875|https://access.redhat.com/errata/RHSA-2025:2879|https://access.redhat.com/errata/RHSA-2025:2880|https://access.redhat.com/security/cve/CVE-2025-26600|https://bugzilla.redhat.com/show_bug.cgi?id=2345252,||||||||||||||||||||||||||||||||||||||,0,0,Red Hat/Red Hat Enterprise Linux 8.6 Advanced Mission Critical Update Support 0:1.12.0-6.el8_6.13,Red Hat/Red Hat Enterprise Linux 8.6 Advanced Mission Critical Update Support 0:1.12.0-6.el8_6.13,"Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",Use After Free,High,Use After Free,Remote Code Execution (RCE),
CVE-2024-50121,"In the Linux kernel, the following vulnerability has been resolved:

nfsd: cancel nfsd_shrinker_work using sync mode in nfs4_state_shutdown_net

In the normal case, when we excute `echo 0 > /proc/fs/nfsd/threads`, the
function `nfs4_state_destroy_net` in `nfs4_state_shutdown_net` will
release all resources related to the hashed `nfs4_client`. If the
`nfsd_client_shrinker` is running concurrently, the `expire_client`
function will first unhash this client and then destroy it. This can
lead to the following warning. Additionally, numerous use-after-free
errors may occur as well.

nfsd_client_shrinker         echo 0 > /proc/fs/nfsd/threads

expire_client                nfsd_shutdown_net
  unhash_client                ...
                               nfs4_state_shutdown_net
                                 /* won't wait shrinker exit */
  /*                             cancel_work(&nn->nfsd_shrinker_work)
   * nfsd_file for this          /* won't destroy unhashed client1 */
   * client1 still alive         nfs4_state_destroy_net
   */

                               nfsd_file_cache_shutdown
                                 /* trigger warning */
                                 kmem_cache_destroy(nfsd_file_slab)
                                 kmem_cache_destroy(nfsd_file_mark_slab)
  /* release nfsd_file and mark */
  __destroy_client

====================================================================
BUG nfsd_file (Not tainted): Objects remaining in nfsd_file on
__kmem_cache_shutdown()
--------------------------------------------------------------------
CPU: 4 UID: 0 PID: 764 Comm: sh Not tainted 6.12.0-rc3+ #1

 dump_stack_lvl+0x53/0x70
 slab_err+0xb0/0xf0
 __kmem_cache_shutdown+0x15c/0x310
 kmem_cache_destroy+0x66/0x160
 nfsd_file_cache_shutdown+0xac/0x210 [nfsd]
 nfsd_destroy_serv+0x251/0x2a0 [nfsd]
 nfsd_svc+0x125/0x1e0 [nfsd]
 write_threads+0x16a/0x2a0 [nfsd]
 nfsctl_transaction_write+0x74/0xa0 [nfsd]
 vfs_write+0x1a5/0x6d0
 ksys_write+0xc1/0x160
 do_syscall_64+0x5f/0x170
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

====================================================================
BUG nfsd_file_mark (Tainted: G    B   W         ): Objects remaining
nfsd_file_mark on __kmem_cache_shutdown()
--------------------------------------------------------------------

 dump_stack_lvl+0x53/0x70
 slab_err+0xb0/0xf0
 __kmem_cache_shutdown+0x15c/0x310
 kmem_cache_destroy+0x66/0x160
 nfsd_file_cache_shutdown+0xc8/0x210 [nfsd]
 nfsd_destroy_serv+0x251/0x2a0 [nfsd]
 nfsd_svc+0x125/0x1e0 [nfsd]
 write_threads+0x16a/0x2a0 [nfsd]
 nfsctl_transaction_write+0x74/0xa0 [nfsd]
 vfs_write+0x1a5/0x6d0
 ksys_write+0xc1/0x160
 do_syscall_64+0x5f/0x170
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

To resolve this issue, cancel `nfsd_shrinker_work` using synchronous
mode in nfs4_state_shutdown_net.",,,0,0,0,0,,,,,,,CWE-416,Use After Free,Variant,"Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",Linux,Linux,2bbf10861d51dae76c6da7113516d0071c782653,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,14,12,https://git.kernel.org/stable/c/36775f42e039b01d4abe8998bf66771a37d3cdcc|https://git.kernel.org/stable/c/5ade4382de16c34d9259cb548f36ec5c4555913c|https://git.kernel.org/stable/c/add1df5eba163a3a6ece11cb85890e2e410baaea|https://git.kernel.org/stable/c/d5ff2fb2e7167e9483846e34148e60c0c016a1f6|https://git.kernel.org/stable/c/f67138dd338cb564ade7d3755c8cd4f68b46d397|https://git.kernel.org/stable/c/f965dc0f099a54fca100acf6909abe52d0c85328|https://git.kernel.org/stable/c/f67138dd338cb564ade7d3755c8cd4f68b46d397|https://git.kernel.org/stable/c/5ade4382de16c34d9259cb548f36ec5c4555913c|https://git.kernel.org/stable/c/36775f42e039b01d4abe8998bf66771a37d3cdcc|https://git.kernel.org/stable/c/f965dc0f099a54fca100acf6909abe52d0c85328|https://git.kernel.org/stable/c/add1df5eba163a3a6ece11cb85890e2e410baaea|https://git.kernel.org/stable/c/d5ff2fb2e7167e9483846e34148e60c0c016a1f6,|||||||||||,0,0,Linux/Linux 2bbf10861d51dae76c6da7113516d0071c782653,Linux/Linux 2bbf10861d51dae76c6da7113516d0071c782653,"Choose a language that provides automatic memory management.; When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",Use After Free,High,Use After Free,Privilege Escalation,
CVE-2024-20381,"A vulnerability in the JSON-RPC API feature in Cisco Crosswork Network Services Orchestrator (NSO) and ConfD that is used by the web-based management interfaces of Cisco Optical Site Manager and Cisco RV340 Dual WAN Gigabit VPN Routers could allow an authenticated, remote attacker to modify the configuration of an affected application or device.&nbsp;

This vulnerability is due to improper authorization checks on the API. An attacker with privileges sufficient to access the affected application or device could exploit this vulnerability by sending malicious requests to the JSON-RPC API. A successful exploit could allow the attacker to make unauthorized modifications to the configuration of the affected application or device, including creating new user accounts or elevating their own privileges on an affected system.",,,0,0,0,0,,,,,,,CWE-285,Improper Authorization,Class,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that you perform access control checks related to your business logic. These checks may be different than the access control checks that you apply to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",Cisco,Cisco IOS XR Software,7.9.21,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,N,L,L,N,U,H,H,H,542,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nso-auth-bypass-QnTEesp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nso-auth-bypass-QnTEesp,|,0,0,Cisco/Cisco IOS XR Software 7.9.21,Cisco/Cisco IOS XR Software 7.9.21,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that you perform access control checks related to your business logic. These checks may be different than the access control checks that you apply to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",Access Control Issues,High,Access Control Issues,Information Disclosure,
CVE-2024-20381,"A vulnerability in the JSON-RPC API feature in Cisco Crosswork Network Services Orchestrator (NSO) and ConfD that is used by the web-based management interfaces of Cisco Optical Site Manager and Cisco RV340 Dual WAN Gigabit VPN Routers could allow an authenticated, remote attacker to modify the configuration of an affected application or device.&nbsp;

This vulnerability is due to improper authorization checks on the API. An attacker with privileges sufficient to access the affected application or device could exploit this vulnerability by sending malicious requests to the JSON-RPC API. A successful exploit could allow the attacker to make unauthorized modifications to the configuration of the affected application or device, including creating new user accounts or elevating their own privileges on an affected system.",,,0,0,0,0,,,,,,,CWE-285,Improper Authorization,Class,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that you perform access control checks related to your business logic. These checks may be different than the access control checks that you apply to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",Cisco,Other_Product,5.8.9,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,N,L,L,N,U,H,H,H,542,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nso-auth-bypass-QnTEesp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nso-auth-bypass-QnTEesp,|,0,0,Cisco/Cisco Network Services Orchestrator 5.8.9,Cisco/Cisco Network Services Orchestrator 5.8.9,"Divide the product into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully mapping roles with data and functionality. Use role-based access control (RBAC) to enforce the roles at the appropriate boundaries.
                  Note that this approach may not protect against horizontal authorization, i.e., it will not protect a user from attacking others with the same role.; Ensure that you perform access control checks related to your business logic. These checks may be different than the access control checks that you apply to more generic resources such as files, connections, processes, memory, and database records. For example, a database may restrict access for medical records to a specific database user, but each record might only be intended to be accessible to the patient and the patient's doctor.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using authorization frameworks such as the JAAS Authorization Framework [REF-233] and the OWASP ESAPI Access Control feature [REF-45].; For web applications, make sure that the access control mechanism is enforced correctly at the server side on every page. Users should not be able to access any unauthorized functionality or information by simply requesting direct access to that page.
                  One way to do this is to ensure that all pages containing sensitive information are not cached, and that all such pages restrict access to requests that are accompanied by an active and authenticated session token associated with a user who has the required permissions to access that page.; Use the access control capabilities of your operating system and server environment and define your access control lists accordingly. Use a ""default deny"" policy when defining these ACLs.",Access Control Issues,High,Access Control Issues,Information Disclosure,
CVE-2022-39894,Improper access control vulnerability in ContactListStartActivityHelper in Phone prior to SMR Dec-2022 Release 1 allows to access sensitive information via implicit intent.,,,0,0,0,0,,,,,,,CWE-284,Improper Access Control,Pillar,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Other_Vendor,Other_Product,"Q(10), R(11), S(12)",,,,,,4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N,L,L,N,N,U,L,N,N,4,3,https://security.samsungmobile.com/securityUpdate.smsb?year=2022&month=12|https://security.samsungmobile.com/securityUpdate.smsb?year=2022&month=12|https://security.samsungmobile.com/securityUpdate.smsb?year=2022&month=12,||,0,0,"Samsung Mobile/Samsung Mobile Devices Q(10), R(11), S(12)","Samsung Mobile/Samsung Mobile Devices Q(10), R(11), S(12)","Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Access Control Issues,Medium,Access Control Issues,Cross-Site Scripting (XSS),
CVE-2024-28016,"Improper Access Controlvulnerability in NEC Corporation Aterm WG1800HP4, WG1200HS3, WG1900HP2, WG1200HP3, WG1800HP3, WG1200HS2, WG1900HP, WG1200HP2, W1200EX(-MS), WG1200HS, WG1200HP, WF300HP2, W300P, WF800HP, WR8165N, WG2200HP, WF1200HP2, WG1800HP2, WF1200HP, WG600HP, WG300HP, WF300HP, WG1800HP, WG1400HP, WR8175N, WR9300N, WR8750N, WR8160N, WR9500N, WR8600N, WR8370N, WR8170N, WR8700N, WR8300N, WR8150N, WR4100N, WR4500N, WR8100N, WR8500N, CR2500P, WR8400N, WR8200N, WR1200H, WR7870S, WR6670S, WR7850S, WR6650S, WR6600H, WR7800H, WM3400RN, WM3450RN, WM3500R, WM3600R, WM3800R, WR8166N, MR01LN MR02LN, WG1810HP(JE) and WG1810HP(MF) all versions allows a attacker to get device informations via the internet.",,,0,0,0,0,,,,,,,CWE-284,Improper Access Control,Pillar,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Other_Vendor,Other_Product,all versions,,,,,,6,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:L/A:L,N,L,H,N,U,H,L,L,59,3,https://https://jpn.nec.com/security-info/secinfo/nv24-001_en.html|https://jpn.nec.com/security-info/secinfo/nv24-001_en.html|https://jpn.nec.com/security-info/secinfo/nv24-001_en.html,||,0,0,NEC Corporation/WG1200HP3 all versions,NEC Corporation/WG1200HP3 all versions,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Access Control Issues,Medium,Access Control Issues,SQL Injection,
CVE-2024-8485,"The REST API TO MiniProgram plugin for WordPress is vulnerable to privilege escalation via account takeovr in all versions up to, and including, 4.7.1 via the updateUserInfo() due to missing validation on the 'openid' user controlled key that determines what user will be updated. This makes it possible for unauthenticated attackers to update arbitrary user's accounts, including their email to a @weixin.com email, which can the be leveraged to reset the password of the user's account, including administrators.",,,0,0,0,0,,,,,,,CWE-639,Authorization Bypass Through User-Controlled Key,Base,"For each and every data access, ensure that the user has sufficient privilege to access the record that is being requested.; Make sure that the key that is used in the lookup of a specific user's record is not controllable externally by the user or that any tampering can be detected.; Use encryption in order to make it more difficult to guess other legitimate values of the key or associate a digital signature with the key so that the server can verify that there has been no tampering.",Other_Vendor,Other_Product,*,,,,,,9.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,N,L,N,N,U,H,H,H,2,4,https://plugins.trac.wordpress.org/browser/rest-api-to-miniprogram/tags/4.7.0/includes/api/ram-rest-weixin-controller.php#L264|https://www.wordfence.com/threat-intel/vulnerabilities/id/b53066d3-2ff3-4460-896a-facd77455914?source=cve|https://www.wordfence.com/threat-intel/vulnerabilities/id/b53066d3-2ff3-4460-896a-facd77455914?source=cve|https://plugins.trac.wordpress.org/browser/rest-api-to-miniprogram/tags/4.7.0/includes/api/ram-rest-weixin-controller.php#L264,|||,0,0,xjb/REST API TO MiniProgram *,xjb/REST API TO MiniProgram *,"For each and every data access, ensure that the user has sufficient privilege to access the record that is being requested.; Make sure that the key that is used in the lookup of a specific user's record is not controllable externally by the user or that any tampering can be detected.; Use encryption in order to make it more difficult to guess other legitimate values of the key or associate a digital signature with the key so that the server can verify that there has been no tampering.",Access Control Issues,Critical,Access Control Issues,Denial of Service (DoS),
CVE-2023-21554,,,,0,0,0,0,,,,,,,CWE-20,Improper Input Validation,Class,"Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language.  This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]; Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; Understand all the potential areas where untrusted inputs can enter the product, including but not limited to: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.",Microsoft,Windows Server 2012 (Server Core installation),6.2.9200.0,,,,,,9.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,N,L,N,N,U,H,H,H,37,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-21554|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-21554|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-21554,||,0,0,Microsoft/Windows Server 2012 (Server Core installation) 6.2.9200.0,Microsoft/Windows Server 2012 (Server Core installation) 6.2.9200.0,"Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language.  This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]; Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; Understand all the potential areas where untrusted inputs can enter the product, including but not limited to: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.",Improper Input Validation,Critical,Improper Input Validation,Remote Code Execution (RCE),
CVE-2023-33104,Transient DOS while processing PDU Release command with a parameter PDU ID out of range.,,,0,0,0,0,,,,,,,CWE-20,Improper Input Validation,Class,"Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language.  This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]; Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; Understand all the potential areas where untrusted inputs can enter the product, including but not limited to: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.","Qualcomm, Inc.",Snapdragon,Snapdragon 4 Gen 2 Mobile Platform,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,101,3,https://www.qualcomm.com/company/product-security/bulletins/march-2024-bulletin|https://www.qualcomm.com/company/product-security/bulletins/march-2024-bulletin|https://www.qualcomm.com/company/product-security/bulletins/march-2024-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon Snapdragon 4 Gen 2 Mobile Platform","Qualcomm, Inc./Snapdragon Snapdragon 4 Gen 2 Mobile Platform","Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language.  This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]; Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; Understand all the potential areas where untrusted inputs can enter the product, including but not limited to: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.",Improper Input Validation,High,Improper Input Validation,Privilege Escalation,
CVE-2022-33876,"Multiple instances of improper input validation vulnerability in Fortinet FortiADC version 7.1.0, version 7.0.0 through 7.0.2 and version 6.2.4 and below allows an authenticated attacker to retrieve files with specific extension from the underlying Linux system via crafted HTTP requests.",,,0,0,0,0,,,,,,,CWE-20,Improper Input Validation,Class,"Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language.  This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]; Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; Understand all the potential areas where untrusted inputs can enter the product, including but not limited to: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.",Fortinet,Other_Product,6.0.0,,,,,,5.1,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N/E:P/RL:X/RC:C,N,L,L,N,U,L,L,N,14,3,https://fortiguard.com/psirt/FG-IR-22-253|https://fortiguard.com/psirt/FG-IR-22-253|https://fortiguard.com/psirt/FG-IR-22-253,||,0,0,Fortinet/FortiADC 6.0.0,Fortinet/FortiADC 6.0.0,"Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language.  This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]; Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; Understand all the potential areas where untrusted inputs can enter the product, including but not limited to: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.",Improper Input Validation,Medium,Improper Input Validation,Buffer Overflow,
CVE-2023-28574,Memory corruption in core services when Diag handler receives a command to configure event listeners.,,,0,0,0,0,,,,,,,CWE-20,Improper Input Validation,Class,"Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language.  This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]; Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; Understand all the potential areas where untrusted inputs can enter the product, including but not limited to: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.","Qualcomm, Inc.",Snapdragon,QCA6698AQ,,,,,,9,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:H,L,L,N,N,C,N,H,H,152,3,https://www.qualcomm.com/company/product-security/bulletins/november-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/november-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/november-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon QCA6698AQ","Qualcomm, Inc./Snapdragon QCA6698AQ","Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language.  This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]; Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; Understand all the potential areas where untrusted inputs can enter the product, including but not limited to: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.",Improper Input Validation,Critical,Improper Input Validation,Denial of Service (DoS),
CVE-2023-33014,Information disclosure in Core services while processing a Diag command.,,,0,0,0,0,,,,,,,CWE-20,Improper Input Validation,Class,"Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language.  This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]; Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; Understand all the potential areas where untrusted inputs can enter the product, including but not limited to: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.","Qualcomm, Inc.",Snapdragon,QCN6024,,,,,,7.6,,,CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H,P,L,N,N,C,H,H,H,37,3,https://www.qualcomm.com/company/product-security/bulletins/january-2024-bulletin|https://www.qualcomm.com/company/product-security/bulletins/january-2024-bulletin|https://www.qualcomm.com/company/product-security/bulletins/january-2024-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon QCN6024","Qualcomm, Inc./Snapdragon QCN6024","Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build ""recognizers"" for that language.  This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]; Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).; Understand all the potential areas where untrusted inputs can enter the product, including but not limited to: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.
                  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.",Improper Input Validation,High,Improper Input Validation,Remote Code Execution (RCE),
CVE-2024-49121,,,,0,0,0,0,,,,,,,CWE-476,NULL Pointer Dereference,Base,"For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished.; Select a programming language that is not susceptible to these issues.; Check the results of all functions that return a value and verify that the value is non-null before acting upon it.; Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.; Explicitly initialize all variables and other data stores, either during declaration or just before the first usage.",Microsoft,Windows 11 version 22H3,10.0.22631.0,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H/E:U/RL:O/RC:C,N,L,N,N,U,N,N,H,43,2,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-49121|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-49121,|,0,0,Microsoft/Windows 11 version 22H3 10.0.22631.0,Microsoft/Windows 11 version 22H3 10.0.22631.0,"For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished.; Select a programming language that is not susceptible to these issues.; Check the results of all functions that return a value and verify that the value is non-null before acting upon it.; Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.; Explicitly initialize all variables and other data stores, either during declaration or just before the first usage.",NULL Pointer Dereference,High,NULL Pointer Dereference,Privilege Escalation,
CVE-2024-36011,"In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: HCI: Fix potential null-ptr-deref

Fix potential null-ptr-deref in hci_le_big_sync_established_evt().",,,0,0,0,0,,,,,,,CWE-476,NULL Pointer Dereference,Base,"For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished.; Select a programming language that is not susceptible to these issues.; Check the results of all functions that return a value and verify that the value is non-null before acting upon it.; Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.; Explicitly initialize all variables and other data stores, either during declaration or just before the first usage.",Linux,Linux,6.6.31,,,,,,5.5,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,10,15,https://git.kernel.org/stable/c/1f7ebb69c1d65732bcac2fda9d15421f76f01e81|https://git.kernel.org/stable/c/1f7ebb69c1d65732bcac2fda9d15421f76f01e81|https://git.kernel.org/stable/c/9f3be61f55d4eedc20eedc56c0f04a5ce2b4a55a|https://git.kernel.org/stable/c/9f3be61f55d4eedc20eedc56c0f04a5ce2b4a55a|https://git.kernel.org/stable/c/d2706004a1b8b526592e823d7e52551b518a7941|https://git.kernel.org/stable/c/d2706004a1b8b526592e823d7e52551b518a7941|https://git.kernel.org/stable/c/1f7ebb69c1d65732bcac2fda9d15421f76f01e81|https://git.kernel.org/stable/c/1f7ebb69c1d65732bcac2fda9d15421f76f01e81|https://git.kernel.org/stable/c/9f3be61f55d4eedc20eedc56c0f04a5ce2b4a55a|https://git.kernel.org/stable/c/9f3be61f55d4eedc20eedc56c0f04a5ce2b4a55a|https://git.kernel.org/stable/c/d2706004a1b8b526592e823d7e52551b518a7941|https://git.kernel.org/stable/c/d2706004a1b8b526592e823d7e52551b518a7941|https://git.kernel.org/stable/c/1f7ebb69c1d65732bcac2fda9d15421f76f01e81|https://git.kernel.org/stable/c/9f3be61f55d4eedc20eedc56c0f04a5ce2b4a55a|https://git.kernel.org/stable/c/d2706004a1b8b526592e823d7e52551b518a7941,||||||||||||||,0,0,Linux/Linux 6.6.31,Linux/Linux 6.6.31,"For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished.; Select a programming language that is not susceptible to these issues.; Check the results of all functions that return a value and verify that the value is non-null before acting upon it.; Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.; Explicitly initialize all variables and other data stores, either during declaration or just before the first usage.",NULL Pointer Dereference,Medium,NULL Pointer Dereference,Information Disclosure,
CVE-2021-0111,NULL pointer dereference in the firmware for some Intel(R) Processors may allow a privileged user to potentially enable an escalation of privilege via local access.,,,0,0,0,0,,,,,,,CWE-476,NULL Pointer Dereference,Base,"For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished.; Select a programming language that is not susceptible to these issues.; Check the results of all functions that return a value and verify that the value is non-null before acting upon it.; Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.; Explicitly initialize all variables and other data stores, either during declaration or just before the first usage.",intel,Other_Product,-,,,,,,6.7,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,L,L,H,N,U,H,H,H,682,10,https://security.netapp.com/advisory/ntap-20220210-0007/|https://security.netapp.com/advisory/ntap-20220210-0007/|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00527.html|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00527.html|https://security.netapp.com/advisory/ntap-20220210-0007/|https://security.netapp.com/advisory/ntap-20220210-0007/|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00527.html|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00527.html|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00527.html|https://security.netapp.com/advisory/ntap-20220210-0007/,|||||||||,0,0,intel/atom_c3708 -,intel/atom_c3708 -,"For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished.; Select a programming language that is not susceptible to these issues.; Check the results of all functions that return a value and verify that the value is non-null before acting upon it.; Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.; Explicitly initialize all variables and other data stores, either during declaration or just before the first usage.",NULL Pointer Dereference,Medium,NULL Pointer Dereference,Cross-Site Scripting (XSS),
CVE-2021-27630,"SAP NetWeaver ABAP Server and ABAP Platform (Enqueue Server), versions - KRNL32NUC - 7.22,7.22EXT, KRNL64NUC - 7.22,7.22EXT,7.49, KRNL64UC - 8.04,7.22,7.22EXT,7.49,7.53,7.73, KERNEL - 7.22,8.04,7.49,7.53,7.73, allows an unauthenticated attacker without specific knowledge of the system to send a specially crafted packet over a network which will trigger an internal error in the system due to improper input validation in method EnqConvUniToSrvReq() causing the system to crash and rendering it unavailable. In this attack, no data in the system can be viewed or modified.",,,0,0,0,0,,,,,,,CWE-476,NULL Pointer Dereference,Base,"For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished.; Select a programming language that is not susceptible to these issues.; Check the results of all functions that return a value and verify that the value is non-null before acting upon it.; Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.; Explicitly initialize all variables and other data stores, either during declaration or just before the first usage.",SAP SE,Other_Product,< KRNL32NUC - 7.22,,,,,,7.5,,,CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,30,6,https://launchpad.support.sap.com/#/notes/3020104|https://launchpad.support.sap.com/#/notes/3020104|https://wiki.scn.sap.com/wiki/pages/viewpage.action?pageId=578125999|https://wiki.scn.sap.com/wiki/pages/viewpage.action?pageId=578125999|https://wiki.scn.sap.com/wiki/pages/viewpage.action?pageId=578125999|https://launchpad.support.sap.com/#/notes/3020104,|||||,0,0,SAP SE/SAP NetWeaver ABAP Server and ABAP Platform (Enqueue Server) < KRNL32NUC - 7.22,SAP SE/SAP NetWeaver ABAP Server and ABAP Platform (Enqueue Server) < KRNL32NUC - 7.22,"For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished.; Select a programming language that is not susceptible to these issues.; Check the results of all functions that return a value and verify that the value is non-null before acting upon it.; Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.; Explicitly initialize all variables and other data stores, either during declaration or just before the first usage.",NULL Pointer Dereference,High,NULL Pointer Dereference,SQL Injection,
CVE-2023-33089,Transient DOS when processing a NULL buffer while parsing WLAN vdev.,,,0,0,0,0,,,,,,,CWE-476,NULL Pointer Dereference,Base,"For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished.; Select a programming language that is not susceptible to these issues.; Check the results of all functions that return a value and verify that the value is non-null before acting upon it.; Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.; Explicitly initialize all variables and other data stores, either during declaration or just before the first usage.","Qualcomm, Inc.",Snapdragon,QCN5022,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,228,3,https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/december-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon QCN5022","Qualcomm, Inc./Snapdragon QCN5022","For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished.; Select a programming language that is not susceptible to these issues.; Check the results of all functions that return a value and verify that the value is non-null before acting upon it.; Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.; Explicitly initialize all variables and other data stores, either during declaration or just before the first usage.",NULL Pointer Dereference,High,NULL Pointer Dereference,Denial of Service (DoS),
CVE-2022-20799,"Multiple vulnerabilities in the web-based management interface of Cisco Small Business RV340 and RV345 Routers could allow an authenticated, remote attacker to inject and execute arbitrary commands on the underlying operating system of an affected device. These vulnerabilities are due to insufficient validation of user-supplied input. An attacker could exploit these vulnerabilities by sending malicious input to an affected device. A successful exploit could allow the attacker to execute arbitrary commands on the underlying Linux operating system of the affected device. To exploit these vulnerabilities, an attacker would need to have valid Administrator credentials on the affected device.",,,0,0,0,0,,,,,,,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),Base,"If at all possible, use library calls rather than external processes to recreate the desired functionality.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).; If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like "";"" and "">"" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.; Use runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cisco,Cisco Small Business RV Series Router Firmware,,,,,,,4.7,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:L,N,L,H,N,U,L,L,L,2,3,https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-smb-rv-cmd-inj-8Pv9JMJD|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-smb-rv-cmd-inj-8Pv9JMJD|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-smb-rv-cmd-inj-8Pv9JMJD,||,0,0,Cisco/Cisco Small Business RV Series Router Firmware n/a,Cisco/Cisco Small Business RV Series Router Firmware n/a,"If at all possible, use library calls rather than external processes to recreate the desired functionality.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).; If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like "";"" and "">"" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.; Use runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Command Injection,Medium,Command Injection,Remote Code Execution (RCE),
CVE-2024-20399,"A vulnerability in the CLI of Cisco NX-OS Software could allow an authenticated user in possession of Administrator credentials to execute arbitrary commands as root on the underlying operating system of an affected device.

This vulnerability is due to insufficient validation of arguments that are passed to specific configuration CLI commands. An attacker could exploit this vulnerability by including crafted input as the argument of an affected configuration CLI command. A successful exploit could allow the attacker to execute arbitrary commands on the underlying operating system with the privileges of root.
Note: To successfully exploit this vulnerability on a Cisco NX-OS device, an attacker must have Administrator credentials. The following Cisco devices already allow administrative users to access the underlying operating system through the bash-shell feature, so, for these devices, this vulnerability does not grant any additional privileges:

Nexus 3000 Series Switches
Nexus 7000 Series Switches that are running Cisco NX-OS Software releases 8.1(1) and later
Nexus 9000 Series Switches in standalone NX-OS mode",,,0,0,0,0,,,,,,,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),Base,"If at all possible, use library calls rather than external processes to recreate the desired functionality.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).; If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like "";"" and "">"" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.; Use runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Cisco,Cisco NX-OS Software,7.3(6)D1(1),,,,,,6,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N,L,L,H,N,U,H,H,N,318,4,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nxos-cmd-injection-xD9OhyOP|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nxos-cmd-injection-xD9OhyOP|https://www.sygnia.co/threat-reports-and-advisories/china-nexus-threat-group-velvet-ant-exploits-cisco-0-day/|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-nxos-cmd-injection-xD9OhyOP,|||,0,0,Cisco/Cisco NX-OS Software 7.3(6)D1(1),Cisco/Cisco NX-OS Software 7.3(6)D1(1),"If at all possible, use library calls rather than external processes to recreate the desired functionality.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).; If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like "";"" and "">"" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.; Use runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Command Injection,Medium,Command Injection,Privilege Escalation,
CVE-2024-1628,OS command injection vulnerabilities in GE HealthCare ultrasound devices,,,0,0,0,0,,,,,,,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),Base,"If at all possible, use library calls rather than external processes to recreate the desired functionality.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).; If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like "";"" and "">"" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.; Use runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,0,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,33,3,https://securityupdate.gehealthcare.com/|https://securityupdate.gehealthcare.com/|https://securityupdate.gehealthcare.com/,||,0,0,GE HealthCare/Voluson Expert 22 0,GE HealthCare/Voluson Expert 22 0,"If at all possible, use library calls rather than external processes to recreate the desired functionality.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).; If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like "";"" and "">"" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.; Use runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Command Injection,High,Command Injection,Buffer Overflow,
CVE-2024-8131,"A vulnerability was found in D-Link DNS-120, DNR-202L, DNS-315L, DNS-320, DNS-320L, DNS-320LW, DNS-321, DNR-322L, DNS-323, DNS-325, DNS-326, DNS-327L, DNR-326, DNS-340L, DNS-343, DNS-345, DNS-726-4, DNS-1100-4, DNS-1200-05 and DNS-1550-04 up to 20240814 and classified as critical. Affected by this issue is the function module_enable_disable of the file /cgi-bin/apkg_mgr.cgi of the component HTTP POST Request Handler. The manipulation of the argument f_module_name leads to command injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. NOTE: This vulnerability only affects products that are no longer supported by the maintainer. NOTE: Vendor was contacted early and confirmed that the product is end-of-life. It should be retired and replaced.",,,0,0,0,0,,,,,,,CWE-77,Improper Neutralization of Special Elements used in a Command ('Command Injection'),Class,"If at all possible, use library calls rather than external processes to recreate the desired functionality.; If possible, ensure that all external commands called from the program are statically created.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; Run time: Run time policy enforcement may be used in an allowlist fashion to prevent use of any non-sanctioned commands.; Assign permissions that prevent the user from accessing/opening privileged files.",D-Link,Other_Product,20240814,,,,,,6.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L,N,L,L,N,U,L,L,L,40,12,https://github.com/BuaaIOTTeam/Iot_Dlink_NAS/blob/main/DNS_module_enable_disable.md|https://supportannouncement.us.dlink.com/security/publication.aspx?name=SAP10383|https://vuldb.com/?ctiid.275702|https://vuldb.com/?id.275702|https://vuldb.com/?submit.396292|https://www.dlink.com/|https://vuldb.com/?id.275702|https://vuldb.com/?ctiid.275702|https://vuldb.com/?submit.396292|https://github.com/BuaaIOTTeam/Iot_Dlink_NAS/blob/main/DNS_module_enable_disable.md|https://supportannouncement.us.dlink.com/security/publication.aspx?name=SAP10383|https://www.dlink.com/,|||||||||||,0,0,D-Link/DNS-323 20240814,D-Link/DNS-323 20240814,"If at all possible, use library calls rather than external processes to recreate the desired functionality.; If possible, ensure that all external commands called from the program are statically created.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; Run time: Run time policy enforcement may be used in an allowlist fashion to prevent use of any non-sanctioned commands.; Assign permissions that prevent the user from accessing/opening privileged files.",Command Injection,Medium,Command Injection,Denial of Service (DoS),
CVE-2024-20358,"A vulnerability in the Cisco Adaptive Security Appliance (ASA) restore functionality that is available in Cisco ASA Software and Cisco Firepower Threat Defense (FTD) Software could allow an authenticated, local attacker to execute arbitrary commands on the underlying operating system with root-level privileges. Administrator-level privileges are required to exploit this vulnerability. This vulnerability exists because the contents of a backup file are improperly sanitized at restore time. An attacker could exploit this vulnerability by restoring a crafted backup file to an affected device. A successful exploit could allow the attacker to execute arbitrary commands on the underlying Linux operating system as root.",,,0,0,0,0,,,,,,,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),Base,"If at all possible, use library calls rather than external processes to recreate the desired functionality.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).; If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like "";"" and "">"" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.; Use runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",cisco,adaptive_security_appliance_software,9.15.1.1,,,,,,6,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N,L,L,H,N,U,H,H,N,534,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-cmd-inj-ZJV8Wysm|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-cmd-inj-ZJV8Wysm|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-cmd-inj-ZJV8Wysm,||,0,0,cisco/adaptive_security_appliance_software 9.15.1.1,cisco/adaptive_security_appliance_software 9.15.1.1,"If at all possible, use library calls rather than external processes to recreate the desired functionality.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).; If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like "";"" and "">"" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.
                  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.; Use runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Command Injection,Medium,Command Injection,Remote Code Execution (RCE),
CVE-2024-36410,"SuiteCRM is an open-source Customer Relationship Management (CRM) software application. In versions prior to 7.14.4 and 8.6.1, poor input validation allows for SQL Injection in EmailUIAjax messages count controller. Versions 7.14.4 and 8.6.1 contain a fix for this issue.",,,0,0,0,0,,,,,,,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
                  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).
                  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.
                  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,">= 8.0.0, < 8.6.1",,,,,,9.6,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:H,N,L,L,N,C,N,H,H,3,3,https://github.com/salesagility/SuiteCRM/security/advisories/GHSA-7jj8-m2wj-m6xq|https://github.com/salesagility/SuiteCRM/security/advisories/GHSA-7jj8-m2wj-m6xq|https://github.com/salesagility/SuiteCRM/security/advisories/GHSA-7jj8-m2wj-m6xq,||,0,0,"salesagility/SuiteCRM >= 8.0.0, < 8.6.1","salesagility/SuiteCRM >= 8.0.0, < 8.6.1","Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
                  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).
                  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.
                  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",SQL Injection,Critical,SQL Injection,Privilege Escalation,
CVE-2023-6611,A vulnerability was found in Tongda OA 2017 up to 11.9. It has been declared as critical. This vulnerability affects unknown code of the file pda/pad/email/delete.php. The manipulation of the argument EMAIL_ID leads to sql injection. The exploit has been disclosed to the public and may be used. Upgrading to version 11.10 is able to address this issue. It is recommended to upgrade the affected component. VDB-247246 is the identifier assigned to this vulnerability. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.,,,0,0,0,0,,,,,,,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
                  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).
                  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.
                  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,2017,,,,,,5.5,,,CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L,A,L,L,N,U,L,L,L,12,9,https://github.com/13223355/cve/blob/main/sql.md|https://github.com/13223355/cve/blob/main/sql.md|https://vuldb.com/?ctiid.247246|https://vuldb.com/?ctiid.247246|https://vuldb.com/?id.247246|https://vuldb.com/?id.247246|https://vuldb.com/?id.247246|https://vuldb.com/?ctiid.247246|https://github.com/13223355/cve/blob/main/sql.md,||||||||,0,0,tongda2000/tongda_office_anywhere 2017,tongda2000/tongda_office_anywhere 2017,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
                  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).
                  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.
                  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",SQL Injection,Medium,SQL Injection,Information Disclosure,
CVE-2021-24662,"The Game Server Status WordPress plugin through 1.0 does not validate or escape the server_id parameter before using it in SQL statement, leading to an Authenticated SQL Injection in an admin page",,,0,0,0,0,,,,,,,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
                  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).
                  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.
                  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Unknown,Other_Product,1,,,,,,7.2,1.2,5.9,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,N,L,H,N,U,H,H,H,2,3,https://wpscan.com/vulnerability/8a74a2a0-3d8c-427f-9a83-0160d652c5f0|https://wpscan.com/vulnerability/8a74a2a0-3d8c-427f-9a83-0160d652c5f0|https://wpscan.com/vulnerability/8a74a2a0-3d8c-427f-9a83-0160d652c5f0,||,0,0,Unknown/Game Server Status 1.0,Unknown/Game Server Status 1.0,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
                  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).
                  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.
                  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",SQL Injection,High,SQL Injection,Cross-Site Scripting (XSS),
CVE-2024-9008,A vulnerability classified as critical was found in SourceCodester Best Online News Portal 1.0. This vulnerability affects unknown code of the file /news-details.php of the component Comment Section. The manipulation of the argument name leads to sql injection. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used.,,,0,0,0,0,,,,,,,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
                  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).
                  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.
                  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,1,,,,,,6.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L,N,L,L,N,U,L,L,L,2,10,https://github.com/gurudattch/CVEs/blob/main/Sourcecodester-News-Portal-Comment-Blind-SQLi.md|https://vuldb.com/?ctiid.278164|https://vuldb.com/?id.278164|https://vuldb.com/?submit.409956|https://www.sourcecodester.com/|https://vuldb.com/?id.278164|https://vuldb.com/?ctiid.278164|https://vuldb.com/?submit.409956|https://github.com/gurudattch/CVEs/blob/main/Sourcecodester-News-Portal-Comment-Blind-SQLi.md|https://www.sourcecodester.com/,|||||||||,0,0,mayurik/best_online_news_portal 1.0,mayurik/best_online_news_portal 1.0,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
                  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).
                  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.
                  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",SQL Injection,Medium,SQL Injection,SQL Injection,
CVE-2023-1571,"A vulnerability, which was classified as critical, was found in DataGear up to 4.5.0. This affects an unknown part of the file /analysisProject/pagingQueryData. The manipulation of the argument queryOrder leads to sql injection. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 4.5.1 is able to address this issue. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-223563.",,,0,0,0,0,,,,,,,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),Base,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
                  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).
                  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.
                  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,4,,,,,,6.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L,N,L,L,N,U,L,L,L,7,9,https://github.com/yangyanglo/ForCVE/blob/main/2023-0x01.md|https://github.com/yangyanglo/ForCVE/blob/main/2023-0x01.md|https://vuldb.com/?ctiid.223563|https://vuldb.com/?ctiid.223563|https://vuldb.com/?id.223563|https://vuldb.com/?id.223563|https://vuldb.com/?id.223563|https://vuldb.com/?ctiid.223563|https://github.com/yangyanglo/ForCVE/blob/main/2023-0x01.md,||||||||,0,0,n/a/DataGear 4.0,n/a/DataGear 4.0,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.; If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.
                  Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using ""exec"" or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.
                  Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).
                  Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.
                  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name ""O'Reilly"" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ""'"" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.
                  When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",SQL Injection,Medium,SQL Injection,Denial of Service (DoS),
CVE-2022-20721,"Multiple vulnerabilities in the Cisco IOx application hosting environment on multiple Cisco platforms could allow an attacker to inject arbitrary commands into the underlying host operating system, execute arbitrary code on the underlying host operating system, install applications without being authenticated, or conduct a cross-site scripting (XSS) attack against a user of the affected software. For more information about these vulnerabilities, see the Details section of this advisory.",,,0,0,0,0,,,,,,,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.
                  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59). This includes:
                     
                        realpath() in C
                        getCanonicalPath() in Java
                        GetFullPath() in ASP.NET
                        realpath() or abs_path() in Perl
                        realpath() in PHP; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately.
                  This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",cisco,ios_xe,16.12.3a,,,,,,5.5,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:H/A:N,N,L,H,N,U,L,H,N,143,6,https://github.com/orangecertcc/security-research/security/advisories/GHSA-p3w5-w45c-c34x|https://github.com/orangecertcc/security-research/security/advisories/GHSA-p3w5-w45c-c34x|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iox-yuXQ6hFj|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iox-yuXQ6hFj|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iox-yuXQ6hFj|https://github.com/orangecertcc/security-research/security/advisories/GHSA-p3w5-w45c-c34x,|||||,0,0,cisco/ios_xe 16.12.3a,cisco/ios_xe 16.12.3a,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.
                  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59). This includes:
                     
                        realpath() in C
                        getCanonicalPath() in Java
                        GetFullPath() in ASP.NET
                        realpath() or abs_path() in Perl
                        realpath() in PHP; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately.
                  This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Path Traversal,Medium,Path Traversal,Remote Code Execution (RCE),
CVE-2022-20722,"Multiple vulnerabilities in the Cisco IOx application hosting environment on multiple Cisco platforms could allow an attacker to inject arbitrary commands into the underlying host operating system, execute arbitrary code on the underlying host operating system, install applications without being authenticated, or conduct a cross-site scripting (XSS) attack against a user of the affected software. For more information about these vulnerabilities, see the Details section of this advisory.",,,0,0,0,0,,,,,,,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.
                  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59). This includes:
                     
                        realpath() in C
                        getCanonicalPath() in Java
                        GetFullPath() in ASP.NET
                        realpath() or abs_path() in Perl
                        realpath() in PHP; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately.
                  This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",cisco,ios_xe,16.6.9,,,,,,5.5,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:H/A:N,N,L,H,N,U,L,H,N,143,6,https://github.com/orangecertcc/security-research/security/advisories/GHSA-2qx4-9cr7-gg38|https://github.com/orangecertcc/security-research/security/advisories/GHSA-2qx4-9cr7-gg38|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iox-yuXQ6hFj|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iox-yuXQ6hFj|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iox-yuXQ6hFj|https://github.com/orangecertcc/security-research/security/advisories/GHSA-2qx4-9cr7-gg38,|||||,0,0,cisco/ios_xe 16.6.9,cisco/ios_xe 16.6.9,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.
                  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59). This includes:
                     
                        realpath() in C
                        getCanonicalPath() in Java
                        GetFullPath() in ASP.NET
                        realpath() or abs_path() in Perl
                        realpath() in PHP; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately.
                  This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Path Traversal,Medium,Path Traversal,Privilege Escalation,
CVE-2023-34982,"
This external control vulnerability, if exploited, could allow a local OS-authenticated user with standard privileges to delete files with System privilege on the machine where these products are installed, resulting in denial of service.

",,,0,0,0,0,,,,,,,CWE-73,External Control of File Name or Path,Base,"When the set of filenames is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames, and reject all other inputs. For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap provide this capability.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict all access to files within a particular directory.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.; Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59).; Use OS-level permissions and run as a low-privileged user to limit the scope of any successful attack.; If you are using PHP, configure your application so that it does not use register_globals. During implementation, develop your application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Other_Vendor,Other_Product,0,,,,,,5.5,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,74,6,https://www.aveva.com/en/support-and-success/cyber-security-updates/|https://www.cisa.gov/news-events/ics-advisories/icsa-23-318-01|https://www.aveva.com/en/support-and-success/cyber-security-updates/|https://www.cisa.gov/news-events/ics-advisories/icsa-23-318-01|https://www.cisa.gov/news-events/ics-advisories/icsa-23-318-01|https://www.aveva.com/en/support-and-success/cyber-security-updates/,|||||,0,0,AVEVA /Worktasks (formerly known as Workflow Management) 0,AVEVA /Worktasks (formerly known as Workflow Management) 0,"When the set of filenames is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames, and reject all other inputs. For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap provide this capability.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict all access to files within a particular directory.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.; Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59).; Use OS-level permissions and run as a low-privileged user to limit the scope of any successful attack.; If you are using PHP, configure your application so that it does not use register_globals. During implementation, develop your application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Path Traversal,Medium,Path Traversal,Buffer Overflow,
CVE-2022-20962,"A vulnerability in the Localdisk Management feature of Cisco Identity Services Engine (ISE) could allow an authenticated, remote attacker to make unauthorized changes to the file system of an affected device.
 This vulnerability is due to insufficient input validation. An attacker could exploit this vulnerability by sending a crafted HTTP request with absolute path sequences. A successful exploit could allow the attacker to upload malicious files to arbitrary locations within the file system. Using this method, it is possible to access the underlying operating system and execute commands with system privileges.",,,0,0,0,0,,,,,,,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.
                  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59). This includes:
                     
                        realpath() in C
                        getCanonicalPath() in Java
                        GetFullPath() in ASP.NET
                        realpath() or abs_path() in Perl
                        realpath() in PHP; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately.
                  This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",cisco,Other_Product,3.1,,,,,,3.8,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N,N,L,H,N,U,L,L,N,8,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ise-path-trav-f6M7cs6r|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ise-path-trav-f6M7cs6r|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ise-path-trav-f6M7cs6r,||,0,0,cisco/identity_services_engine 3.1,cisco/identity_services_engine 3.1,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.
                  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59). This includes:
                     
                        realpath() in C
                        getCanonicalPath() in Java
                        GetFullPath() in ASP.NET
                        realpath() or abs_path() in Perl
                        realpath() in PHP; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately.
                  This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Path Traversal,Low,Path Traversal,Denial of Service (DoS),
CVE-2023-32322,"Ombi is an open source application which allows users to request specific media from popular self-hosted streaming servers. Versions prior to 4.38.2 contain an arbitrary file read vulnerability where an Ombi administrative user may access files available to the Ombi server process on the host operating system. Ombi administrators may not always be local system administrators and so this may violate the security expectations of the system. The arbitrary file read vulnerability was present in `ReadLogFile` and `Download` endpoints in `SystemControllers.cs` as the parameter `logFileName` is not sanitized before being combined with the `Logs` directory. When using `Path.Combine(arg1, arg2, arg3)`, an attacker may be able to escape to folders/files outside of `Path.Combine(arg1, arg2)` by using "".."" in `arg3`. In addition, by specifying an absolute path for `arg3`, `Path.Combine` will completely ignore the first two arguments and just return just `arg3`. This vulnerability can lead to information disclosure. The Ombi `documentation` suggests running Ombi as a Service with Administrator privileges. An attacker targeting such an application may be able to read the files of any Windows user on the host machine and certain system files. This issue has been addressed in commit `b8a8f029` and in release version 4.38.2. Users are advised to upgrade. There are no known workarounds for this vulnerability. This issue is also tracked as GHSL-2023-088.
",,,0,0,0,0,,,,,,,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.
                  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59). This includes:
                     
                        realpath() in C
                        getCanonicalPath() in Java
                        GetFullPath() in ASP.NET
                        realpath() or abs_path() in Perl
                        realpath() in PHP; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately.
                  This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Other_Vendor,Other_Product,< 4.38.2,,,,,,4.9,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N,N,L,H,N,U,H,N,N,2,15,https://docs.ombi.app/guides/installation/#windows|https://github.com/Ombi-app/Ombi/blob/v4.36.1/src/Ombi/Controllers/V2/SystemController.cs#L46|https://github.com/Ombi-app/Ombi/blob/v4.36.1/src/Ombi/Controllers/V2/SystemController.cs#L58|https://github.com/Ombi-app/Ombi/commit/b8a8f029d80454d582bc4a2a05175106809335d0|https://github.com/Ombi-app/Ombi/security/advisories/GHSA-28j3-84m7-gpjp|https://docs.ombi.app/guides/installation/#windows|https://github.com/Ombi-app/Ombi/security/advisories/GHSA-28j3-84m7-gpjp|https://github.com/Ombi-app/Ombi/commit/b8a8f029d80454d582bc4a2a05175106809335d0|https://github.com/Ombi-app/Ombi/blob/v4.36.1/src/Ombi/Controllers/V2/SystemController.cs#L58|https://github.com/Ombi-app/Ombi/blob/v4.36.1/src/Ombi/Controllers/V2/SystemController.cs#L46|https://github.com/Ombi-app/Ombi/security/advisories/GHSA-28j3-84m7-gpjp|https://github.com/Ombi-app/Ombi/commit/b8a8f029d80454d582bc4a2a05175106809335d0|https://docs.ombi.app/guides/installation/#windows|https://github.com/Ombi-app/Ombi/blob/v4.36.1/src/Ombi/Controllers/V2/SystemController.cs#L46|https://github.com/Ombi-app/Ombi/blob/v4.36.1/src/Ombi/Controllers/V2/SystemController.cs#L58,||||||||||||||,0,0,Ombi-app/Ombi < 4.38.2,Ombi-app/Ombi < 4.38.2,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single ""."" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as ""/"" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.
                  Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering ""/"" is insufficient protection if the filesystem also supports the use of ""\"" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ""../"" sequences are removed from the "".../...//"" string in a sequential fashion, two instances of ""../"" would be removed from the original string, but the remaining characters would still form the ""../"" string.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.
                  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes "".."" sequences and symbolic links (CWE-23, CWE-59). This includes:
                     
                        realpath() in C
                        getCanonicalPath() in Java
                        GetFullPath() in ASP.NET
                        realpath() or abs_path() in Perl
                        realpath() in PHP; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""inbox.txt"" and ID 2 could map to ""profile.txt"". Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately.
                  This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.; Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.
                  In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy.; When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.",Path Traversal,Medium,Path Traversal,Remote Code Execution (RCE),
CVE-2024-0157,"Dell Storage Resource Manager, 4.9.0.0 and below, contain(s) a Session Fixation Vulnerability in SRM Windows Host Agent. An adjacent network unauthenticated attacker could potentially exploit this vulnerability, leading to the hijack of a targeted user's application session.",,,0,0,0,0,,,,,,,CWE-400,Uncontrolled Resource Consumption,Class,"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, or
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; Ensure that all failures in resource allocation place the system into a safe posture.",Other_Vendor,Other_Product,*,,,,,,5.9,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,N,H,N,N,U,N,N,H,6,3,https://www.dell.com/support/kbdoc/en-nz/000224070/dsa-2024-143-dell-storage-resource-manager-srm-and-dell-storage-monitoring-and-reporting-smr-security-update-for-multiple-third-party-component-vulnerabilities|https://www.dell.com/support/kbdoc/en-nz/000224070/dsa-2024-143-dell-storage-resource-manager-srm-and-dell-storage-monitoring-and-reporting-smr-security-update-for-multiple-third-party-component-vulnerabilities|https://www.dell.com/support/kbdoc/en-nz/000224070/dsa-2024-143-dell-storage-resource-manager-srm-and-dell-storage-monitoring-and-reporting-smr-security-update-for-multiple-third-party-component-vulnerabilities,||,0,0,dell/storage_monitoring_and_reporting *,dell/storage_monitoring_and_reporting *,"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, or
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; Ensure that all failures in resource allocation place the system into a safe posture.",Resource Exhaustion,Medium,Resource Exhaustion,Privilege Escalation,
CVE-2023-22396,"An Uncontrolled Resource Consumption vulnerability in TCP processing on the Routing Engine (RE) of Juniper Networks Junos OS allows an unauthenticated network-based attacker to send crafted TCP packets destined to the device, resulting in an MBUF leak that ultimately leads to a Denial of Service (DoS). The system does not recover automatically and must be manually restarted to restore service. This issue occurs when crafted TCP packets are sent directly to a configured IPv4 or IPv6 interface on the device. Transit traffic will not trigger this issue. MBUF usage can be monitored through the use of the 'show system buffers' command. For example: user@junos> show system buffers | refresh 5 4054/566/4620 mbufs in use (current/cache/total) ... 4089/531/4620 mbufs in use (current/cache/total) ... 4151/589/4740 mbufs in use (current/cache/total) ... 4213/527/4740 mbufs in use (current/cache/total) This issue affects Juniper Networks Junos OS: 12.3 version 12.3R12-S19 and later versions; 15.1 version 15.1R7-S10 and later versions; 17.3 version 17.3R3-S12 and later versions; 18.4 version 18.4R3-S9 and later versions; 19.1 version 19.1R3-S7 and later versions; 19.2 version 19.2R3-S3 and later versions; 19.3 version 19.3R2-S7, 19.3R3-S3 and later versions prior to 19.3R3-S7; 19.4 version 19.4R2-S7, 19.4R3-S5 and later versions prior to 19.4R3-S10; 20.1 version 20.1R3-S1 and later versions; 20.2 version 20.2R3-S2 and later versions prior to 20.2R3-S6; 20.3 version 20.3R3-S1 and later versions prior to 20.3R3-S6; 20.4 version 20.4R2-S2, 20.4R3 and later versions prior to 20.4R3-S5; 21.1 version 21.1R2 and later versions prior to 21.1R3-S4; 21.2 version 21.2R1-S1, 21.2R2 and later versions prior to 21.2R3-S3; 21.3 versions prior to 21.3R3-S2; 21.4 versions prior to 21.4R3; 22.1 versions prior to 22.1R2-S1, 22.1R3; 22.2 versions prior to 22.2R1-S2, 22.2R2; 22.3 versions prior to 22.3R1-S1, 22.3R2.",,,0,0,0,0,,,,,,,CWE-400,Uncontrolled Resource Consumption,Class,"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, or
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; Ensure that all failures in resource allocation place the system into a safe posture.",juniper,junos,18.4,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,38,3,https://kb.juniper.net/JSA70192|https://kb.juniper.net/JSA70192|https://kb.juniper.net/JSA70192,||,0,0,juniper/junos 18.4,juniper/junos 18.4,"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, or
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; Ensure that all failures in resource allocation place the system into a safe posture.",Resource Exhaustion,High,Resource Exhaustion,Information Disclosure,
CVE-2024-20661,,,,0,0,0,0,,,,,,,CWE-400,Uncontrolled Resource Consumption,Class,"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, or
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; Ensure that all failures in resource allocation place the system into a safe posture.",microsoft,windows_server_2008,-,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H/E:U/RL:O/RC:C,N,L,N,N,U,N,N,H,78,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-20661|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-20661|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-20661,||,0,0,microsoft/windows_server_2008 -,microsoft/windows_server_2008 -,"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, or
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; Ensure that all failures in resource allocation place the system into a safe posture.",Resource Exhaustion,High,Resource Exhaustion,Cross-Site Scripting (XSS),
CVE-2023-27652,An issue found in Ego Studio SuperClean v.1.1.9 and v.1.1.5 allows an attacker to gain privileges cause a denial of service via the update_info field of the _default_.xml file.,,,0,0,0,0,,,,,,,CWE-400,Uncontrolled Resource Consumption,Class,"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, or
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; Ensure that all failures in resource allocation place the system into a safe posture.",Other_Vendor,Other_Product,1.1.5,,,,,,5.5,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,L,L,N,R,U,N,N,H,3,9,http://www.egostudiogroup.com/|http://www.egostudiogroup.com/|https://apkpure.com/cn/super-clean-phone-cleaner/com.egostudio.clean/download|https://apkpure.com/cn/super-clean-phone-cleaner/com.egostudio.clean/download|https://github.com/LianKee/SODA/blob/main/CVEs/CVE-2023-27652/CVE%20detail.md|https://github.com/LianKee/SODA/blob/main/CVEs/CVE-2023-27652/CVE%20detail.md|http://www.egostudiogroup.com/|https://apkpure.com/cn/super-clean-phone-cleaner/com.egostudio.clean/download|https://github.com/LianKee/SODA/blob/main/CVEs/CVE-2023-27652/CVE%20detail.md,||||||||,0,0,egostudiogroup/super_clean 1.1.5,egostudiogroup/super_clean 1.1.5,"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, or
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; Ensure that all failures in resource allocation place the system into a safe posture.",Resource Exhaustion,Medium,Resource Exhaustion,SQL Injection,
CVE-2021-0092,Improper access control in the firmware for some Intel(R) Processors may allow a privileged user to potentially enable a denial of service via local access.,,,0,0,0,0,,,,,,,CWE-400,Uncontrolled Resource Consumption,Class,"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, or
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; Ensure that all failures in resource allocation place the system into a safe posture.",intel,Other_Product,-,,,,,,4.4,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H,L,L,H,N,U,N,N,H,682,10,https://security.netapp.com/advisory/ntap-20220210-0007/|https://security.netapp.com/advisory/ntap-20220210-0007/|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00527.html|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00527.html|https://security.netapp.com/advisory/ntap-20220210-0007/|https://security.netapp.com/advisory/ntap-20220210-0007/|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00527.html|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00527.html|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00527.html|https://security.netapp.com/advisory/ntap-20220210-0007/,|||||||||,0,0,intel/core_i7-7600u -,intel/core_i7-7600u -,"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, or
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; Ensure that all failures in resource allocation place the system into a safe posture.",Resource Exhaustion,Medium,Resource Exhaustion,Denial of Service (DoS),
CVE-2025-24373,"woocommerce-pdf-invoices-packing-slips is an extension which allows users to create, print & automatically email PDF invoices & packing slips for WooCommerce orders. This vulnerability allows unauthorized users to access any PDF document from a store if they: 1. Have access to a guest document link and 2. Replace the URL variable `my-account` with `bulk`. The issue occurs when: 1. The store's document access is set to ""guest."" and 2. The user is logged out. This vulnerability compromises the confidentiality of sensitive documents, affecting all stores using the plugin with the guest access option enabled. This issue has been addressed in version 4.0.0 and all users are advised to upgrade. There are no known workarounds for this vulnerability.",,,0,0,0,0,,,,,,,CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,Class,"Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Other_Vendor,Other_Product,*,,,,,,6.5,2.8,3.6,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N,N,L,L,N,U,H,N,N,2,4,https://github.com/wpovernight/woocommerce-pdf-invoices-packing-slips/commit/6daeff87f8a7f941f0f7cf4637f41d22c4428c30|https://github.com/wpovernight/woocommerce-pdf-invoices-packing-slips/security/advisories/GHSA-3j9m-cp35-94fr|https://github.com/wpovernight/woocommerce-pdf-invoices-packing-slips/security/advisories/GHSA-3j9m-cp35-94fr|https://github.com/wpovernight/woocommerce-pdf-invoices-packing-slips/commit/6daeff87f8a7f941f0f7cf4637f41d22c4428c30,|||,0,0,wpovernight/woocommerce_pdf_invoices\&_packing_slips *,wpovernight/woocommerce_pdf_invoices\&_packing_slips *,"Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Information Disclosure,Medium,Information Disclosure,Remote Code Execution (RCE),
CVE-2022-40523,Information disclosure in Kernel due to indirect branch misprediction.,,,0,0,0,0,,,,,,,CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,Class,"Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.","Qualcomm, Inc.",Snapdragon,Snapdragon AR2 Gen 1 Platform,,,,,,7.1,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N,L,L,N,N,C,H,N,N,358,3,https://www.qualcomm.com/company/product-security/bulletins/june-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/june-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/june-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon Snapdragon AR2 Gen 1 Platform","Qualcomm, Inc./Snapdragon Snapdragon AR2 Gen 1 Platform","Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Information Disclosure,High,Information Disclosure,Privilege Escalation,
CVE-2021-43206,"A server-generated error message containing sensitive information in Fortinet FortiOS 7.0.0 through 7.0.3, 6.4.0 through 6.4.8, 6.2.x, 6.0.x and FortiProxy 7.0.0 through 7.0.1, 2.0.x allows malicious webservers to retrieve a web proxy's client username and IP via same origin HTTP requests triggering proxy-generated HTTP status codes pages.",,,0,0,0,0,,,,,,,CWE-209,Generation of Error Message Containing Sensitive Information,Base,"Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.; Handle exceptions internally and do not display errors containing potentially sensitive information to a user.; Use naming conventions and strong types to make it easier to spot when sensitive data is being used. When creating structures, objects, or other complex entities, separate the sensitive and non-sensitive data as much as possible.; Debugging information should not make its way into a production release.; Debugging information should not make its way into a production release.; Where available, configure the environment to use less verbose error messages. For example, in PHP, disable the display_errors setting during configuration, or at runtime using the error_reporting() function.; Create default error pages or messages that do not leak any information.",fortinet,Other_Product,*,,,,,,4.3,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N/E:P/RL:U/RC:C,N,L,N,R,U,L,N,N,3,3,https://fortiguard.com/psirt/FG-IR-21-231|https://fortiguard.com/psirt/FG-IR-21-231|https://fortiguard.com/psirt/FG-IR-21-231,||,0,0,fortinet/fortiproxy *,fortinet/fortiproxy *,"Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success.
                  If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files.
		  Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.; Handle exceptions internally and do not display errors containing potentially sensitive information to a user.; Use naming conventions and strong types to make it easier to spot when sensitive data is being used. When creating structures, objects, or other complex entities, separate the sensitive and non-sensitive data as much as possible.; Debugging information should not make its way into a production release.; Debugging information should not make its way into a production release.; Where available, configure the environment to use less verbose error messages. For example, in PHP, disable the display_errors setting during configuration, or at runtime using the error_reporting() function.; Create default error pages or messages that do not leak any information.",Information Disclosure,Medium,Information Disclosure,Buffer Overflow,
CVE-2021-22892,"An information disclosure vulnerability exists in the Rocket.Chat server fixed v3.13, v3.12.2 & v3.11.3 that allowed email addresses to be disclosed by enumeration and validation checks.",,,0,0,0,0,,,,,,,CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,Class,"Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Other_Vendor,Other_Product,3.12.4,,,,,,7.5,3.9,3.6,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,N,L,N,N,U,H,N,N,10,3,https://hackerone.com/reports/1089116|https://hackerone.com/reports/1089116|https://hackerone.com/reports/1089116,||,0,0,rocket.chat/rocket.chat 3.12.4,rocket.chat/rocket.chat 3.12.4,"Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Information Disclosure,High,Information Disclosure,Denial of Service (DoS),
CVE-2023-36763,,,,0,0,0,0,,,,,,,CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,Class,"Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Microsoft,Other_Product,16.0.1,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N/E:U/RL:O/RC:C,N,L,N,N,U,H,N,N,8,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-36763|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-36763|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-36763,||,0,0,Microsoft/Microsoft 365 Apps for Enterprise 16.0.1,Microsoft/Microsoft 365 Apps for Enterprise 16.0.1,"Compartmentalize the system to have ""safe"" areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area.
                  Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.",Information Disclosure,High,Information Disclosure,Remote Code Execution (RCE),
CVE-2025-21417,,,,0,0,0,0,,,,,,,CWE-122,Heap-based Buffer Overflow,Variant,"Pre-design: Use a language or compiler that performs automatic bounds checking.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.; Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.",Microsoft,Windows Server 2008 R2 Service Pack 1,6.1.7601.0,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,N,L,N,R,U,H,H,H,43,2,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21417|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21417,|,0,0,Microsoft/Windows Server 2008 R2 Service Pack 1 6.1.7601.0,Microsoft/Windows Server 2008 R2 Service Pack 1 6.1.7601.0,"Pre-design: Use a language or compiler that performs automatic bounds checking.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.; Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.",Heap-based Buffer Overflow,High,Heap-based Buffer Overflow,Privilege Escalation,
CVE-2023-23378,,,,0,0,0,0,,,,,,,CWE-122,Heap-based Buffer Overflow,Variant,"Pre-design: Use a language or compiler that performs automatic bounds checking.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.; Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.",microsoft,Other_Product,*,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H/E:U/RL:U/RC:C,L,L,N,R,U,H,H,H,2,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-23378|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-23378|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-23378,||,0,0,microsoft/print_3d *,microsoft/print_3d *,"Pre-design: Use a language or compiler that performs automatic bounds checking.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.; Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.",Heap-based Buffer Overflow,High,Heap-based Buffer Overflow,Information Disclosure,
CVE-2024-12179,"A maliciously crafted DWFX file, when parsed through Autodesk Navisworks, can be used to cause a Heap-based Overflow vulnerability. A malicious actor can leverage this vulnerability to cause a crash, read sensitive data, or execute arbitrary code in the context of the current process.",,,0,0,0,0,,,,,,,CWE-122,Heap-based Buffer Overflow,Variant,"Pre-design: Use a language or compiler that performs automatic bounds checking.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.; Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.",Autodesk,Other_Product,2025,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,L,L,N,R,U,H,H,H,8,3,https://www.autodesk.com/trust/security-advisories/adsk-sa-2024-0027|https://www.autodesk.com/trust/security-advisories/adsk-sa-2024-0027|https://www.autodesk.com/trust/security-advisories/adsk-sa-2024-0027,||,0,0,Autodesk/Navisworks Manage 2025,Autodesk/Navisworks Manage 2025,"Pre-design: Use a language or compiler that performs automatic bounds checking.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.; Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.",Heap-based Buffer Overflow,High,Heap-based Buffer Overflow,Cross-Site Scripting (XSS),
CVE-2025-21252,,,,0,0,0,0,,,,,,,CWE-122,Heap-based Buffer Overflow,Variant,"Pre-design: Use a language or compiler that performs automatic bounds checking.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.; Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.",microsoft,windows_11_22h2,*,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,N,L,N,R,U,H,H,H,43,2,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21252|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21252,|,0,0,microsoft/windows_11_22h2 *,microsoft/windows_11_22h2 *,"Pre-design: Use a language or compiler that performs automatic bounds checking.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.; Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.",Heap-based Buffer Overflow,High,Heap-based Buffer Overflow,SQL Injection,
CVE-2025-21233,,,,0,0,0,0,,,,,,,CWE-122,Heap-based Buffer Overflow,Variant,"Pre-design: Use a language or compiler that performs automatic bounds checking.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.; Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.",Microsoft,Windows Server 2019,10.0.17763.0,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,N,L,N,R,U,H,H,H,43,2,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21233|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21233,|,0,0,Microsoft/Windows Server 2019 10.0.17763.0,Microsoft/Windows Server 2019 10.0.17763.0,"Pre-design: Use a language or compiler that performs automatic bounds checking.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
		  For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.; Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.",Heap-based Buffer Overflow,High,Heap-based Buffer Overflow,Denial of Service (DoS),
CVE-2024-20433,"A vulnerability in the Resource Reservation Protocol (RSVP) feature of Cisco IOS Software and Cisco IOS XE Software could allow an unauthenticated, remote attacker to cause an affected device to reload unexpectedly, resulting in a denial of service (DoS) condition.
 This vulnerability is due to a buffer overflow when processing crafted RSVP packets. An attacker could exploit this vulnerability by sending RSVP traffic to an affected device. A successful exploit could allow the attacker to cause the affected device to reload, resulting in a DoS condition.",,,0,0,0,0,,,,,,,CWE-121,Stack-based Buffer Overflow,Variant,"Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",Cisco,IOS,12.2(33)CY,,,,,,8.6,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H,N,L,N,N,C,N,N,H,9736,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rsvp-dos-OypvgVZf|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rsvp-dos-OypvgVZf,|,0,0,Cisco/IOS 12.2(33)CY,Cisco/IOS 12.2(33)CY,"Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",Stack-based Buffer Overflow,High,Stack-based Buffer Overflow,Remote Code Execution (RCE),
CVE-2024-20433,"A vulnerability in the Resource Reservation Protocol (RSVP) feature of Cisco IOS Software and Cisco IOS XE Software could allow an unauthenticated, remote attacker to cause an affected device to reload unexpectedly, resulting in a denial of service (DoS) condition.
 This vulnerability is due to a buffer overflow when processing crafted RSVP packets. An attacker could exploit this vulnerability by sending RSVP traffic to an affected device. A successful exploit could allow the attacker to cause the affected device to reload, resulting in a DoS condition.",,,0,0,0,0,,,,,,,CWE-121,Stack-based Buffer Overflow,Variant,"Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",cisco,ios,12.3\(2\)xc3,,,,,,8.6,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H,N,L,N,N,C,N,N,H,9736,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rsvp-dos-OypvgVZf|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rsvp-dos-OypvgVZf,|,0,0,cisco/ios 12.3\(2\)xc3,cisco/ios 12.3\(2\)xc3,"Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",Stack-based Buffer Overflow,High,Stack-based Buffer Overflow,Remote Code Execution (RCE),
CVE-2024-20433,"A vulnerability in the Resource Reservation Protocol (RSVP) feature of Cisco IOS Software and Cisco IOS XE Software could allow an unauthenticated, remote attacker to cause an affected device to reload unexpectedly, resulting in a denial of service (DoS) condition.
 This vulnerability is due to a buffer overflow when processing crafted RSVP packets. An attacker could exploit this vulnerability by sending RSVP traffic to an affected device. A successful exploit could allow the attacker to cause the affected device to reload, resulting in a DoS condition.",,,0,0,0,0,,,,,,,CWE-121,Stack-based Buffer Overflow,Variant,"Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",cisco,ios,15.1\(1\)t5,,,,,,8.6,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H,N,L,N,N,C,N,N,H,9736,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rsvp-dos-OypvgVZf|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rsvp-dos-OypvgVZf,|,0,0,cisco/ios 15.1\(1\)t5,cisco/ios 15.1\(1\)t5,"Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",Stack-based Buffer Overflow,High,Stack-based Buffer Overflow,Remote Code Execution (RCE),
CVE-2024-20433,"A vulnerability in the Resource Reservation Protocol (RSVP) feature of Cisco IOS Software and Cisco IOS XE Software could allow an unauthenticated, remote attacker to cause an affected device to reload unexpectedly, resulting in a denial of service (DoS) condition.
 This vulnerability is due to a buffer overflow when processing crafted RSVP packets. An attacker could exploit this vulnerability by sending RSVP traffic to an affected device. A successful exploit could allow the attacker to cause the affected device to reload, resulting in a DoS condition.",,,0,0,0,0,,,,,,,CWE-121,Stack-based Buffer Overflow,Variant,"Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",Cisco,IOS,12.4(22)XR6,,,,,,8.6,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H,N,L,N,N,C,N,N,H,9736,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rsvp-dos-OypvgVZf|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rsvp-dos-OypvgVZf,|,0,0,Cisco/IOS 12.4(22)XR6,Cisco/IOS 12.4(22)XR6,"Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",Stack-based Buffer Overflow,High,Stack-based Buffer Overflow,Remote Code Execution (RCE),
CVE-2024-20307,"A vulnerability in the IKEv1 fragmentation code of Cisco IOS Software and Cisco IOS XE Software could allow an unauthenticated, remote attacker to cause a heap overflow, resulting in an affected device reloading.
 This vulnerability exists because crafted, fragmented IKEv1 packets are not properly reassembled. An attacker could exploit this vulnerability by sending crafted UDP packets to an affected system. A successful exploit could allow the attacker to cause the affected device to reload, resulting in a DoS condition.
 Note: Only traffic that is directed to the affected system can be used to exploit this vulnerability. This vulnerability can be triggered by IPv4 and IPv6 traffic.",,,0,0,0,0,,,,,,,CWE-121,Stack-based Buffer Overflow,Variant,"Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",Cisco,Cisco IOS XE Software,17.5.1a,,,,,,6.8,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:N/A:H,N,H,N,N,C,N,N,H,365,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ikev1-NO2ccFWz|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ikev1-NO2ccFWz|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ikev1-NO2ccFWz,||,0,0,Cisco/Cisco IOS XE Software 17.5.1a,Cisco/Cisco IOS XE Software 17.5.1a,"Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.  
		 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; Implement and perform bounds checking on input.; Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.; Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code.  
		  Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as ""rebasing"" (for Windows) and ""prelinking"" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.  
	        For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",Stack-based Buffer Overflow,Medium,Stack-based Buffer Overflow,Privilege Escalation,
CVE-2021-1648,,,,0,0,0,0,,,,,,,CWE-269,Improper Privilege Management,Class,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Follow the principle of least privilege when assigning access rights to entities in a software system.; Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.",Microsoft,Windows Server 2019 (Server Core installation),10.0.0,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H/E:P/RL:O/RC:C,L,L,L,N,U,H,H,H,34,4,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-1648|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-1648|https://www.zerodayinitiative.com/advisories/ZDI-21-504/|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-1648,|||,0,0,Microsoft/Windows Server 2019 (Server Core installation) 10.0.0,Microsoft/Windows Server 2019 (Server Core installation) 10.0.0,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Follow the principle of least privilege when assigning access rights to entities in a software system.; Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.",Privilege Escalation,High,Privilege Escalation,Buffer Overflow,
CVE-2023-20216,"A vulnerability in the privilege management functionality of all Cisco BroadWorks server types could allow an authenticated, local attacker to elevate privileges to root on an affected system. 
 This vulnerability is due to incorrect implementation of user role permissions. An attacker could exploit this vulnerability by authenticating to the application as a user with the BWORKS or BWSUPERADMIN role and issuing crafted commands on an affected system. A successful exploit could allow the attacker to execute commands beyond the sphere of their intended access level, including initiating installs or running operating system commands with elevated permissions.
   There are workarounds that address this vulnerability.",,,0,0,0,0,,,,,,,CWE-269,Improper Privilege Management,Class,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Follow the principle of least privilege when assigning access rights to entities in a software system.; Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.",Cisco,Cisco BroadWorks,23.0 ap380099,,,,,,4.4,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:N,L,L,H,N,U,N,H,N,6460,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-priv-esc-qTgUZOsQ|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-priv-esc-qTgUZOsQ|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-priv-esc-qTgUZOsQ,||,0,0,Cisco/Cisco BroadWorks 23.0 ap380099,Cisco/Cisco BroadWorks 23.0 ap380099,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Follow the principle of least privilege when assigning access rights to entities in a software system.; Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.",Privilege Escalation,Medium,Privilege Escalation,Denial of Service (DoS),
CVE-2023-20216,"A vulnerability in the privilege management functionality of all Cisco BroadWorks server types could allow an authenticated, local attacker to elevate privileges to root on an affected system. 
 This vulnerability is due to incorrect implementation of user role permissions. An attacker could exploit this vulnerability by authenticating to the application as a user with the BWORKS or BWSUPERADMIN role and issuing crafted commands on an affected system. A successful exploit could allow the attacker to execute commands beyond the sphere of their intended access level, including initiating installs or running operating system commands with elevated permissions.
   There are workarounds that address this vulnerability.",,,0,0,0,0,,,,,,,CWE-269,Improper Privilege Management,Class,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Follow the principle of least privilege when assigning access rights to entities in a software system.; Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.",Cisco,Cisco BroadWorks,22.0 ap372464,,,,,,4.4,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:N,L,L,H,N,U,N,H,N,6460,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-priv-esc-qTgUZOsQ|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-priv-esc-qTgUZOsQ|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-bw-priv-esc-qTgUZOsQ,||,0,0,Cisco/Cisco BroadWorks 22.0 ap372464,Cisco/Cisco BroadWorks 22.0 ap372464,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Follow the principle of least privilege when assigning access rights to entities in a software system.; Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.",Privilege Escalation,Medium,Privilege Escalation,Denial of Service (DoS),
CVE-2023-20048,"A vulnerability in the web services interface of Cisco Firepower Management Center (FMC) Software could allow an authenticated, remote attacker to execute certain unauthorized configuration commands on a Firepower Threat Defense (FTD) device that is managed by the FMC Software. This vulnerability is due to insufficient authorization of configuration commands that are sent through the web service interface. An attacker could exploit this vulnerability by authenticating to the FMC web services interface and sending a crafted HTTP request to an affected device. A successful exploit could allow the attacker to execute certain configuration commands on the targeted FTD device. To successfully exploit this vulnerability, an attacker would need valid credentials on the FMC Software.",,,0,0,0,0,,,,,,,CWE-269,Improper Privilege Management,Class,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Follow the principle of least privilege when assigning access rights to entities in a software system.; Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.",Cisco,Cisco Firepower Management Center,6.2.3.2,,,,,,9.9,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:L/A:H,N,L,L,N,C,H,L,H,146,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-fmc-cmd-inj-29MP49hN|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-fmc-cmd-inj-29MP49hN|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-fmc-cmd-inj-29MP49hN,||,0,0,Cisco/Cisco Firepower Management Center 6.2.3.2,Cisco/Cisco Firepower Management Center 6.2.3.2,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Follow the principle of least privilege when assigning access rights to entities in a software system.; Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.",Privilege Escalation,Critical,Privilege Escalation,Remote Code Execution (RCE),
CVE-2024-56447,"Vulnerability of improper permission control in the window management module
Impact: Successful exploitation of this vulnerability may affect service confidentiality.",,,0,0,0,0,,,,,,,CWE-269,Improper Privilege Management,Class,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Follow the principle of least privilege when assigning access rights to entities in a software system.; Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.",huawei,emui,14.0.0,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,36,2,https://consumer.huawei.com/en/support/bulletin/2025/1/|https://consumer.huawei.com/en/support/bulletin/2025/1/,|,0,0,huawei/emui 14.0.0,huawei/emui 14.0.0,"Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software.; Follow the principle of least privilege when assigning access rights to entities in a software system.; Consider following the principle of separation of privilege. Require multiple conditions to be met before permitting access to a system resource.",Privilege Escalation,High,Privilege Escalation,Privilege Escalation,
CVE-2021-41372,,,,0,0,0,0,,,,,,,CWE-352,Cross-Site Request Forgery (CSRF),Compound,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]
                  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]; Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.; Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]; Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.; Use the ""double-submitted cookie"" method as described by Felten and Zeller:
                  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.
                  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.
                  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]; Do not use the GET method for any request that triggers a state change.; Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",Microsoft,Other_Product,1.0.0.0,,,,,,7.6,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:L/A:N/E:P/RL:O/RC:C,N,L,L,R,C,H,L,N,6,3,https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-41372|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-41372|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-41372,||,0,0,Microsoft/Power BI Report Server version 1.12.7977.29537 1.0.0.0,Microsoft/Power BI Report Server version 1.12.7977.29537 1.0.0.0,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]
                  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]; Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.; Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]; Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.; Use the ""double-submitted cookie"" method as described by Felten and Zeller:
                  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.
                  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.
                  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]; Do not use the GET method for any request that triggers a state change.; Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",Cross-Site Request Forgery (CSRF),High,Cross-Site Request Forgery (CSRF),Information Disclosure,
CVE-2025-39433,Cross-Site Request Forgery (CSRF) vulnerability in beke_ro Bknewsticker allows Stored XSS. This issue affects Bknewsticker: from n/a through 1.0.5.,,,0,0,0,0,,,,,,,CWE-352,Cross-Site Request Forgery (CSRF),Compound,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]
                  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]; Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.; Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]; Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.; Use the ""double-submitted cookie"" method as described by Felten and Zeller:
                  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.
                  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.
                  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]; Do not use the GET method for any request that triggers a state change.; Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",Other_Vendor,Other_Product,,,,,,,7.1,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:L,N,L,N,R,C,L,L,L,1,2,https://patchstack.com/database/wordpress/plugin/bknewsticker/vulnerability/wordpress-bknewsticker-plugin-1-0-5-cross-site-request-forgery-csrf-vulnerability?_s_id=cve|https://patchstack.com/database/wordpress/plugin/bknewsticker/vulnerability/wordpress-bknewsticker-plugin-1-0-5-cross-site-request-forgery-csrf-vulnerability?_s_id=cve,|,0,0,beke_ro/Bknewsticker n/a,beke_ro/Bknewsticker n/a,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]
                  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]; Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.; Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]; Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.; Use the ""double-submitted cookie"" method as described by Felten and Zeller:
                  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.
                  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.
                  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]; Do not use the GET method for any request that triggers a state change.; Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",Cross-Site Request Forgery (CSRF),High,Cross-Site Request Forgery (CSRF),Cross-Site Scripting (XSS),
CVE-2024-4589,A vulnerability was found in DedeCMS 5.7. It has been declared as problematic. Affected by this vulnerability is an unknown functionality of the file /src/dede/mytag_edit.php. The manipulation leads to cross-site request forgery. The attack can be launched remotely. The exploit has been disclosed to the public and may be used. The associated identifier of this vulnerability is VDB-263311. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.,,,0,0,0,0,,,,,,,CWE-352,Cross-Site Request Forgery (CSRF),Compound,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]
                  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]; Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.; Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]; Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.; Use the ""double-submitted cookie"" method as described by Felten and Zeller:
                  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.
                  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.
                  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]; Do not use the GET method for any request that triggers a state change.; Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",Other_Vendor,Other_Product,5.7,,,,,,4.3,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N,N,L,N,R,U,N,L,N,2,12,https://github.com/Hckwzh/cms/blob/main/20.md|https://github.com/Hckwzh/cms/blob/main/20.md|https://vuldb.com/?ctiid.263311|https://vuldb.com/?ctiid.263311|https://vuldb.com/?id.263311|https://vuldb.com/?id.263311|https://vuldb.com/?submit.324957|https://vuldb.com/?submit.324957|https://vuldb.com/?id.263311|https://vuldb.com/?ctiid.263311|https://vuldb.com/?submit.324957|https://github.com/Hckwzh/cms/blob/main/20.md,|||||||||||,0,0,dedecms/dedecms 5.7,dedecms/dedecms 5.7,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]
                  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]; Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.; Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]; Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.; Use the ""double-submitted cookie"" method as described by Felten and Zeller:
                  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.
                  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.
                  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]; Do not use the GET method for any request that triggers a state change.; Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",Cross-Site Request Forgery (CSRF),Medium,Cross-Site Request Forgery (CSRF),SQL Injection,
CVE-2024-20437,"A vulnerability in the web-based management interface of Cisco IOS XE Software could allow an unauthenticated, remote attacker to perform a cross-site request forgery (CSRF) attack and execute commands on the CLI of an affected device.
 This vulnerability is due to insufficient CSRF protections for the web-based management interface of an affected device. An attacker could exploit this vulnerability by persuading an already authenticated user to follow a crafted link. A successful exploit could allow the attacker to perform arbitrary actions on the affected device with the privileges of the targeted user.",,,0,0,0,0,,,,,,,CWE-352,Cross-Site Request Forgery (CSRF),Compound,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]
                  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]; Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.; Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]; Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.; Use the ""double-submitted cookie"" method as described by Felten and Zeller:
                  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.
                  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.
                  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]; Do not use the GET method for any request that triggers a state change.; Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",Cisco,Cisco IOS XE Software,17.3.2a,,,,,,8.1,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:H,N,L,N,R,U,N,H,H,132,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-webui-csrf-ycUYxkKO|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-webui-csrf-ycUYxkKO,|,0,0,Cisco/Cisco IOS XE Software 17.3.2a,Cisco/Cisco IOS XE Software 17.3.2a,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]
                  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]; Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.; Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]; Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.; Use the ""double-submitted cookie"" method as described by Felten and Zeller:
                  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.
                  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.
                  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]; Do not use the GET method for any request that triggers a state change.; Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",Cross-Site Request Forgery (CSRF),High,Cross-Site Request Forgery (CSRF),Denial of Service (DoS),
CVE-2024-42584,A Cross-Site Request Forgery (CSRF) in the component delete_product.php of Warehouse Inventory System v2.0 allows attackers to escalate privileges.,,,0,0,0,0,,,,,,,CWE-352,Cross-Site Request Forgery (CSRF),Compound,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]
                  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]; Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.; Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]; Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.; Use the ""double-submitted cookie"" method as described by Felten and Zeller:
                  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.
                  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.
                  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]; Do not use the GET method for any request that triggers a state change.; Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",Other_Vendor,Other_Product,2,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,N,L,N,R,U,H,H,H,2,2,https://gist.github.com/topsky979/6037eaac5749430c29cf15fdd9df0ba5|https://gist.github.com/topsky979/6037eaac5749430c29cf15fdd9df0ba5,|,0,0,siamonhasan/warehouse_inventory_system 2.0,siamonhasan/warehouse_inventory_system 2.0,"Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]
                  Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]; Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.; Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]; Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.; Use the ""double-submitted cookie"" method as described by Felten and Zeller:
                  When a user visits a site, the site should generate a pseudorandom value and set it as a cookie on the user's machine. The site should require every form submission to include this value as a form value and also as a cookie value. When a POST request is sent to the site, the request should only be considered valid if the form value and the cookie value are the same.
                  Because of the same-origin policy, an attacker cannot read or modify the value stored in the cookie. To successfully submit a form on behalf of the user, the attacker would have to correctly guess the pseudorandom value. If the pseudorandom value is cryptographically strong, this will be prohibitively difficult.
                  This technique requires Javascript, so it may not work for browsers that have Javascript disabled. [REF-331]; Do not use the GET method for any request that triggers a state change.; Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.",Cross-Site Request Forgery (CSRF),High,Cross-Site Request Forgery (CSRF),Remote Code Execution (RCE),
CVE-2022-23722,"When a password reset mechanism is configured to use the Authentication API with an Authentication Policy, email One-Time Password, PingID or SMS authentication, an existing user can reset another existing user’s password.",,,0,0,0,0,,,,,,,CWE-287,Improper Authentication,Class,Use an authentication framework or library such as the OWASP ESAPI Authentication feature.,Other_Vendor,Other_Product,11,,,,,,6.5,2.8,3.6,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N,N,L,L,N,U,N,H,N,18,6,https://docs.pingidentity.com/bundle/pingfederate-110/page/spk1642790928508.html|https://docs.pingidentity.com/bundle/pingfederate-110/page/spk1642790928508.html|https://www.pingidentity.com/en/resources/downloads/pingfederate.html|https://www.pingidentity.com/en/resources/downloads/pingfederate.html|https://www.pingidentity.com/en/resources/downloads/pingfederate.html|https://docs.pingidentity.com/bundle/pingfederate-110/page/spk1642790928508.html,|||||,0,0,Ping Identity/PingFederate 11.0,Ping Identity/PingFederate 11.0,Use an authentication framework or library such as the OWASP ESAPI Authentication feature.,Authentication Issues,Medium,Authentication Issues,Privilege Escalation,
CVE-2021-23923,An issue was discovered in Devolutions Server before 2020.3. There is Broken Authentication with Windows domain users.,,,0,0,0,0,,,,,,,CWE-287,Improper Authentication,Class,Use an authentication framework or library such as the OWASP ESAPI Authentication feature.,Other_Vendor,Other_Product,,,,,,,8.1,2.8,5.2,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N,N,L,L,N,U,H,H,N,2,3,https://devolutions.net/security/advisories/devo-2021-0002|https://devolutions.net/security/advisories/devo-2021-0002|https://devolutions.net/security/advisories/devo-2021-0002,||,0,0,n/a/n/a n/a,n/a/n/a n/a,Use an authentication framework or library such as the OWASP ESAPI Authentication feature.,Authentication Issues,High,Authentication Issues,Buffer Overflow,
CVE-2023-47256,ConnectWise ScreenConnect through 23.8.4 allows local users to connect to arbitrary relay servers via implicit trust of proxy settings,,,0,0,0,0,,,,,,,CWE-287,Improper Authentication,Class,Use an authentication framework or library such as the OWASP ESAPI Authentication feature.,Other_Vendor,Other_Product,-,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N,L,L,L,N,U,N,H,N,3,6,https://web.archive.org/web/20240208140218/https://gotham-security.com/screenconnect-cve-2023-47256|https://web.archive.org/web/20240208140218/https://gotham-security.com/screenconnect-cve-2023-47256|https://www.connectwise.com/company/trust/security-bulletins/connectwise-screenconnect-23.8-security-fix|https://www.connectwise.com/company/trust/security-bulletins/connectwise-screenconnect-23.8-security-fix|https://www.connectwise.com/company/trust/security-bulletins/connectwise-screenconnect-23.8-security-fix|https://web.archive.org/web/20240208140218/https://gotham-security.com/screenconnect-cve-2023-47256,|||||,0,0,connectwise/automate -,connectwise/automate -,Use an authentication framework or library such as the OWASP ESAPI Authentication feature.,Authentication Issues,Medium,Authentication Issues,Denial of Service (DoS),
CVE-2023-6942,"Missing Authentication for Critical Function vulnerability in Mitsubishi Electric Corporation EZSocket versions 3.0 to 5.92, GT Designer3 Version1(GOT1000) versions 1.325P and prior, GT Designer3 Version1(GOT2000) versions 1.320J and prior, GX Works2 versions 1.11M and later, GX Works3 versions 1.106L and prior, MELSOFT Navigator versions 1.04E to 2.102G, MT Works2 versions 1.190Y and prior, MX Component versions 4.00A to 5.007H and MX OPC Server DA/UA all versions allows a remote unauthenticated attacker to bypass authentication by sending specially crafted packets and connect to the products illegally.",,,0,0,0,0,,,,,,,CWE-306,Missing Authentication for Critical Function,Base,"Divide the software into anonymous, normal, privileged, and administrative areas. Identify which of these areas require a proven user identity, and use a centralized authentication capability.
                  Identify all potential communication channels, or other means of interaction with the software, to ensure that all channels are appropriately protected, including those channels that are assumed to be accessible only by authorized parties. Developers sometimes perform authentication at the primary channel, but open up a secondary channel that is assumed to be private. For example, a login mechanism may be listening on one network port, but after successful authentication, it may open up a second port where it waits for the connection, but avoids authentication because it assumes that only the authenticated party will connect to the port.
                  In general, if the software or protocol allows a single session or user state to persist across multiple connections or channels, authentication and appropriate credential management need to be used throughout.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Where possible, avoid implementing custom, ""grow-your-own"" authentication routines and consider using authentication capabilities as provided by the surrounding framework, operating system, or environment. These capabilities may avoid common weaknesses that are unique to authentication; support automatic auditing and tracking; and make it easier to provide a clear separation between authentication tasks and authorization tasks.
                  In environments such as the World Wide Web, the line between authentication and authorization is sometimes blurred. If custom authentication routines are required instead of those provided by the server, then these routines must be applied to every single page, since these pages could be requested directly.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator [REF-45].; When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to require strong authentication for users who should be allowed to access the data [REF-1297] [REF-1298] [REF-1302].",Other_Vendor,Other_Product,*,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N,N,L,N,N,U,N,H,N,19,9,https://jvn.jp/vu/JVNVU95103362|https://jvn.jp/vu/JVNVU95103362|https://www.cisa.gov/news-events/ics-advisories/icsa-24-030-02|https://www.cisa.gov/news-events/ics-advisories/icsa-24-030-02|https://www.mitsubishielectric.com/en/psirt/vulnerability/pdf/2023-020_en.pdf|https://www.mitsubishielectric.com/en/psirt/vulnerability/pdf/2023-020_en.pdf|https://www.mitsubishielectric.com/en/psirt/vulnerability/pdf/2023-020_en.pdf|https://jvn.jp/vu/JVNVU95103362|https://www.cisa.gov/news-events/ics-advisories/icsa-24-030-02,||||||||,0,0,mitsubishielectric/mt_works2 *,mitsubishielectric/mt_works2 *,"Divide the software into anonymous, normal, privileged, and administrative areas. Identify which of these areas require a proven user identity, and use a centralized authentication capability.
                  Identify all potential communication channels, or other means of interaction with the software, to ensure that all channels are appropriately protected, including those channels that are assumed to be accessible only by authorized parties. Developers sometimes perform authentication at the primary channel, but open up a secondary channel that is assumed to be private. For example, a login mechanism may be listening on one network port, but after successful authentication, it may open up a second port where it waits for the connection, but avoids authentication because it assumes that only the authenticated party will connect to the port.
                  In general, if the software or protocol allows a single session or user state to persist across multiple connections or channels, authentication and appropriate credential management need to be used throughout.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Where possible, avoid implementing custom, ""grow-your-own"" authentication routines and consider using authentication capabilities as provided by the surrounding framework, operating system, or environment. These capabilities may avoid common weaknesses that are unique to authentication; support automatic auditing and tracking; and make it easier to provide a clear separation between authentication tasks and authorization tasks.
                  In environments such as the World Wide Web, the line between authentication and authorization is sometimes blurred. If custom authentication routines are required instead of those provided by the server, then these routines must be applied to every single page, since these pages could be requested directly.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator [REF-45].; When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to require strong authentication for users who should be allowed to access the data [REF-1297] [REF-1298] [REF-1302].",Authentication Issues,High,Authentication Issues,Remote Code Execution (RCE),
CVE-2025-1717,"The Login Me Now plugin for WordPress is vulnerable to authentication bypass in versions up to, and including, 1.7.2. This is due to insecure authentication based on an arbitrary transient name in the 'AutoLogin::listen()' function. This makes it possible for unauthenticated attackers to log in an existing user on the site, even an administrator. Note: this vulnerability requires using a transient name and value from another software, so the plugin is not inherently vulnerable on it's own.",,,0,0,0,0,,,,,,,CWE-306,Missing Authentication for Critical Function,Base,"Divide the software into anonymous, normal, privileged, and administrative areas. Identify which of these areas require a proven user identity, and use a centralized authentication capability.
                  Identify all potential communication channels, or other means of interaction with the software, to ensure that all channels are appropriately protected, including those channels that are assumed to be accessible only by authorized parties. Developers sometimes perform authentication at the primary channel, but open up a secondary channel that is assumed to be private. For example, a login mechanism may be listening on one network port, but after successful authentication, it may open up a second port where it waits for the connection, but avoids authentication because it assumes that only the authenticated party will connect to the port.
                  In general, if the software or protocol allows a single session or user state to persist across multiple connections or channels, authentication and appropriate credential management need to be used throughout.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Where possible, avoid implementing custom, ""grow-your-own"" authentication routines and consider using authentication capabilities as provided by the surrounding framework, operating system, or environment. These capabilities may avoid common weaknesses that are unique to authentication; support automatic auditing and tracking; and make it easier to provide a clear separation between authentication tasks and authorization tasks.
                  In environments such as the World Wide Web, the line between authentication and authorization is sometimes blurred. If custom authentication routines are required instead of those provided by the server, then these routines must be applied to every single page, since these pages could be requested directly.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator [REF-45].; When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to require strong authentication for users who should be allowed to access the data [REF-1297] [REF-1298] [REF-1302].",Other_Vendor,Other_Product,*,,,,,,8.1,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H,N,H,N,N,U,H,H,H,4,4,https://plugins.trac.wordpress.org/browser/login-me-now/tags/1.7.2/app/Logins/BrowserTokenLogin/AutoLogin.php#L24|https://www.wordfence.com/threat-intel/vulnerabilities/id/fc689622-50d6-47c4-a5f6-0314b1a207c9?source=cve|https://www.wordfence.com/threat-intel/vulnerabilities/id/fc689622-50d6-47c4-a5f6-0314b1a207c9?source=cve|https://plugins.trac.wordpress.org/browser/login-me-now/tags/1.7.2/app/Logins/BrowserTokenLogin/AutoLogin.php#L24,|||,0,0,"pluginly/1 click passwordless login, temporary login, social login & user switching – Login Me Now *","pluginly/1 click passwordless login, temporary login, social login & user switching – Login Me Now *","Divide the software into anonymous, normal, privileged, and administrative areas. Identify which of these areas require a proven user identity, and use a centralized authentication capability.
                  Identify all potential communication channels, or other means of interaction with the software, to ensure that all channels are appropriately protected, including those channels that are assumed to be accessible only by authorized parties. Developers sometimes perform authentication at the primary channel, but open up a secondary channel that is assumed to be private. For example, a login mechanism may be listening on one network port, but after successful authentication, it may open up a second port where it waits for the connection, but avoids authentication because it assumes that only the authenticated party will connect to the port.
                  In general, if the software or protocol allows a single session or user state to persist across multiple connections or channels, authentication and appropriate credential management need to be used throughout.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Where possible, avoid implementing custom, ""grow-your-own"" authentication routines and consider using authentication capabilities as provided by the surrounding framework, operating system, or environment. These capabilities may avoid common weaknesses that are unique to authentication; support automatic auditing and tracking; and make it easier to provide a clear separation between authentication tasks and authorization tasks.
                  In environments such as the World Wide Web, the line between authentication and authorization is sometimes blurred. If custom authentication routines are required instead of those provided by the server, then these routines must be applied to every single page, since these pages could be requested directly.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  For example, consider using libraries with authentication capabilities such as OpenSSL or the ESAPI Authenticator [REF-45].; When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to require strong authentication for users who should be allowed to access the data [REF-1297] [REF-1298] [REF-1302].",Authentication Issues,High,Authentication Issues,Privilege Escalation,
CVE-2022-20951,"A vulnerability in the web-based management interface of Cisco BroadWorks CommPilot application could allow an authenticated, remote attacker to perform a server-side request forgery (SSRF) attack on an affected device.
 This vulnerability is due to insufficient validation of user-supplied input. An attacker could exploit this vulnerability by sending a crafted HTTP request to the web interface. A successful exploit could allow the attacker to obtain confidential information from the BroadWorks server and other device on the network.
    
  {{value}} [""%7b%7bvalue%7d%7d""])}]]
",,,0,0,0,0,,,,,,,CWE-918,Server-Side Request Forgery (SSRF),Base,,Cisco,Cisco BroadWorks,23.0 ap366656,,,,,,7.7,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N,N,L,L,N,C,H,N,N,3975,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp,||,0,0,Cisco/Cisco BroadWorks 23.0 ap366656,Cisco/Cisco BroadWorks 23.0 ap366656,,SSRF,High,SSRF,Buffer Overflow,
CVE-2022-20951,"A vulnerability in the web-based management interface of Cisco BroadWorks CommPilot application could allow an authenticated, remote attacker to perform a server-side request forgery (SSRF) attack on an affected device.
 This vulnerability is due to insufficient validation of user-supplied input. An attacker could exploit this vulnerability by sending a crafted HTTP request to the web interface. A successful exploit could allow the attacker to obtain confidential information from the BroadWorks server and other device on the network.
    
  {{value}} [""%7b%7bvalue%7d%7d""])}]]
",,,0,0,0,0,,,,,,,CWE-918,Server-Side Request Forgery (SSRF),Base,,Cisco,Cisco BroadWorks,22.0 ap376953,,,,,,7.7,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N,N,L,L,N,C,H,N,N,3975,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp,||,0,0,Cisco/Cisco BroadWorks 22.0 ap376953,Cisco/Cisco BroadWorks 22.0 ap376953,,SSRF,High,SSRF,Buffer Overflow,
CVE-2022-20958,"A vulnerability in the web-based management interface of Cisco BroadWorks CommPilot application could allow an unauthenticated, remote attacker to perform a server-side request forgery (SSRF) attack on an affected device.
 This vulnerability is due to insufficient validation of user-supplied input. An attacker could exploit this vulnerability by sending a crafted HTTP request to the web interface. A successful exploit could allow the attacker to obtain confidential information from the BroadWorks server and other device on the network.
    
  {{value}} [""%7b%7bvalue%7d%7d""])}]]
",,,0,0,0,0,,,,,,,CWE-918,Server-Side Request Forgery (SSRF),Base,,Cisco,Cisco BroadWorks,24.0 ap382463,,,,,,8.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:H,N,L,L,N,U,H,L,H,2546,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp,||,0,0,Cisco/Cisco BroadWorks 24.0 ap382463,Cisco/Cisco BroadWorks 24.0 ap382463,,SSRF,High,SSRF,Denial of Service (DoS),
CVE-2022-20951,"A vulnerability in the web-based management interface of Cisco BroadWorks CommPilot application could allow an authenticated, remote attacker to perform a server-side request forgery (SSRF) attack on an affected device.
 This vulnerability is due to insufficient validation of user-supplied input. An attacker could exploit this vulnerability by sending a crafted HTTP request to the web interface. A successful exploit could allow the attacker to obtain confidential information from the BroadWorks server and other device on the network.
    
  {{value}} [""%7b%7bvalue%7d%7d""])}]]
",,,0,0,0,0,,,,,,,CWE-918,Server-Side Request Forgery (SSRF),Base,,Cisco,Cisco BroadWorks,22.0 ap375273,,,,,,7.7,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N,N,L,L,N,C,H,N,N,3975,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-broadworks-ssrf-BJeQfpp,||,0,0,Cisco/Cisco BroadWorks 22.0 ap375273,Cisco/Cisco BroadWorks 22.0 ap375273,,SSRF,High,SSRF,Buffer Overflow,
CVE-2021-20346,"IBM Jazz Foundation and IBM Engineering products are vulnerable to server-side request forgery (SSRF). This may allow an authenticated attacker to send unauthorized requests from the system, potentially leading to network enumeration or facilitating other attacks. IBM X-Force ID: 194595.",,,0,0,0,0,,,,,,,CWE-918,Server-Side Request Forgery (SSRF),Base,,IBM,Other_Product,7.0.1,,,,,,5.4,,,CVSS:3.0/C:L/S:U/UI:N/A:N/AC:L/I:L/AV:N/PR:L/RC:C/RL:O/E:U,N,L,L,N,U,L,L,N,47,6,https://exchange.xforce.ibmcloud.com/vulnerabilities/194595|https://exchange.xforce.ibmcloud.com/vulnerabilities/194595|https://www.ibm.com/support/pages/node/6457739|https://www.ibm.com/support/pages/node/6457739|https://www.ibm.com/support/pages/node/6457739|https://exchange.xforce.ibmcloud.com/vulnerabilities/194595,|||||,0,0,IBM/Rational DOORS Next Generation 7.0.1,IBM/Rational DOORS Next Generation 7.0.1,,SSRF,Medium,SSRF,Remote Code Execution (RCE),
CVE-2021-40015,There is a race condition vulnerability in the binder driver subsystem in the kernel.Successful exploitation of this vulnerability may affect kernel stability.,,,0,0,0,0,,,,,,,CWE-362,Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'),Class,"In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.; Use thread-safe capabilities such as the data access abstraction in Spring.; Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.
                  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).; When using multithreading and operating on shared variables, only use thread-safe functions.; Use atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.; Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.; Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.; Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.; Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.",Huawei,Other_Product,10.1.1,,,,,,4.7,1,3.6,CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H,L,H,L,N,U,N,N,H,20,6,https://consumer.huawei.com/en/support/bulletin/2022/2/|https://consumer.huawei.com/en/support/bulletin/2022/2/|https://device.harmonyos.com/en/docs/security/update/security-bulletins-202202-0000001204253396|https://device.harmonyos.com/en/docs/security/update/security-bulletins-202202-0000001204253396|https://consumer.huawei.com/en/support/bulletin/2022/2/|https://device.harmonyos.com/en/docs/security/update/security-bulletins-202202-0000001204253396,|||||,0,0,Huawei/Magic UI 10.1.1,Huawei/Magic UI 10.1.1,"In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.; Use thread-safe capabilities such as the data access abstraction in Spring.; Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.
                  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).; When using multithreading and operating on shared variables, only use thread-safe functions.; Use atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.; Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.; Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.; Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.; Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.",Race Condition,Medium,Race Condition,Privilege Escalation,
CVE-2022-20724,"Multiple vulnerabilities in the Cisco IOx application hosting environment on multiple Cisco platforms could allow an attacker to inject arbitrary commands into the underlying host operating system, execute arbitrary code on the underlying host operating system, install applications without being authenticated, or conduct a cross-site scripting (XSS) attack against a user of the affected software. For more information about these vulnerabilities, see the Details section of this advisory.",,,0,0,0,0,,,,,,,CWE-362,Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'),Class,"In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.; Use thread-safe capabilities such as the data access abstraction in Spring.; Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.
                  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).; When using multithreading and operating on shared variables, only use thread-safe functions.; Use atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.; Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.; Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.; Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.; Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.",cisco,ios_xe,16.3.10,,,,,,5.5,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:H/A:N,N,L,H,N,U,L,H,N,430,6,https://github.com/orangecertcc/security-research/security/advisories/GHSA-xr7h-wjgg-h3rp|https://github.com/orangecertcc/security-research/security/advisories/GHSA-xr7h-wjgg-h3rp|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iox-yuXQ6hFj|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iox-yuXQ6hFj|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-iox-yuXQ6hFj|https://github.com/orangecertcc/security-research/security/advisories/GHSA-xr7h-wjgg-h3rp,|||||,0,0,cisco/ios_xe 16.3.10,cisco/ios_xe 16.3.10,"In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.; Use thread-safe capabilities such as the data access abstraction in Spring.; Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.
                  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).; When using multithreading and operating on shared variables, only use thread-safe functions.; Use atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.; Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.; Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.; Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.; Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.",Race Condition,Medium,Race Condition,Buffer Overflow,
CVE-2022-30198,,,,0,0,0,0,,,,,,,CWE-362,Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'),Class,"In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.; Use thread-safe capabilities such as the data access abstraction in Spring.; Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.
                  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).; When using multithreading and operating on shared variables, only use thread-safe functions.; Use atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.; Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.; Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.; Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.; Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.",microsoft,windows_server_2012,r2,,,,,,8.1,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,N,H,N,N,U,H,H,H,41,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-30198|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2022-30198|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-30198,||,0,0,microsoft/windows_server_2012 r2,microsoft/windows_server_2012 r2,"In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.; Use thread-safe capabilities such as the data access abstraction in Spring.; Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.
                  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).; When using multithreading and operating on shared variables, only use thread-safe functions.; Use atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.; Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.; Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.; Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.; Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.",Race Condition,High,Race Condition,Denial of Service (DoS),
CVE-2023-35360,,,,0,0,0,0,,,,,,,CWE-362,Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'),Class,"In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.; Use thread-safe capabilities such as the data access abstraction in Spring.; Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.
                  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).; When using multithreading and operating on shared variables, only use thread-safe functions.; Use atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.; Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.; Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.; Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.; Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.",Microsoft,Windows 11 version 22H2,10.0.22621.0,,,,,,7,,,CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,L,H,L,N,U,H,H,H,58,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-35360|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-35360|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-35360,||,0,0,Microsoft/Windows 11 version 22H2 10.0.22621.0,Microsoft/Windows 11 version 22H2 10.0.22621.0,"In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.; Use thread-safe capabilities such as the data access abstraction in Spring.; Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.
                  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).; When using multithreading and operating on shared variables, only use thread-safe functions.; Use atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.; Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.; Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.; Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.; Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.",Race Condition,High,Race Condition,Remote Code Execution (RCE),
CVE-2023-3758,"A race condition flaw was found in sssd where the GPO policy is not consistently applied for authenticated users. This may lead to improper authorization issues, granting or denying access to resources inappropriately.",,,0,0,0,0,,,,,,,CWE-362,Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'),Class,"In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.; Use thread-safe capabilities such as the data access abstraction in Spring.; Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.
                  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).; When using multithreading and operating on shared variables, only use thread-safe functions.; Use atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.; Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.; Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.; Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.; Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.",Other_Vendor,Other_Product,0,,,,,,7.1,,,CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,A,H,L,N,U,H,H,H,8,30,https://access.redhat.com/errata/RHSA-2024:1919|https://access.redhat.com/errata/RHSA-2024:1919|https://access.redhat.com/errata/RHSA-2024:1920|https://access.redhat.com/errata/RHSA-2024:1920|https://access.redhat.com/errata/RHSA-2024:1921|https://access.redhat.com/errata/RHSA-2024:1921|https://access.redhat.com/errata/RHSA-2024:1922|https://access.redhat.com/errata/RHSA-2024:1922|https://access.redhat.com/errata/RHSA-2024:2571|https://access.redhat.com/errata/RHSA-2024:2571|https://access.redhat.com/errata/RHSA-2024:3270|https://access.redhat.com/errata/RHSA-2024:3270|https://access.redhat.com/security/cve/CVE-2023-3758|https://access.redhat.com/security/cve/CVE-2023-3758|https://bugzilla.redhat.com/show_bug.cgi?id=2223762|https://bugzilla.redhat.com/show_bug.cgi?id=2223762|https://github.com/SSSD/sssd/pull/7302|https://github.com/SSSD/sssd/pull/7302|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RV3HIZI3SURBUQKSOOL3XE64OOBQ2HTK/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XEP62IDS7A55D5UHM6GH7QZ7SQFOAPVF/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XMORAO2BDDA5YX4ZLMXDZ7SM6KU47SY5/|https://access.redhat.com/errata/RHSA-2024:1919|https://access.redhat.com/errata/RHSA-2024:1920|https://access.redhat.com/errata/RHSA-2024:1921|https://access.redhat.com/errata/RHSA-2024:1922|https://access.redhat.com/errata/RHSA-2024:2571|https://access.redhat.com/errata/RHSA-2024:3270|https://access.redhat.com/security/cve/CVE-2023-3758|https://bugzilla.redhat.com/show_bug.cgi?id=2223762|https://github.com/SSSD/sssd/pull/7302,|||||||||||||||||||||||||||||,0,0,/ 0,/ 0,"In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.; Use thread-safe capabilities such as the data access abstraction in Spring.; Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.
                  Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).; When using multithreading and operating on shared variables, only use thread-safe functions.; Use atomic operations on shared variables. Be wary of innocent-looking constructs such as ""x++"". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.; Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.; Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.; Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.; Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.",Race Condition,High,Race Condition,Privilege Escalation,
CVE-2022-49135,"In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix memory leak

[why]
Resource release is needed on the error handling path
to prevent memory leak.

[how]
Fix this by adding kfree on the error handling path.",,,0,0,0,0,,,,,,,CWE-401,Missing Release of Memory after Effective Lifetime,Variant,"Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.
                  For example, glibc in Linux provides protection against free of invalid pointers.
                  When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].
                  To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",Linux,Linux,5.15.34,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,6,8,https://git.kernel.org/stable/c/3ce1497add6d17b48cc9df65095bd20202d93994|https://git.kernel.org/stable/c/5d5c6dba2b43e28845d7d7ed32a36802329a5f52|https://git.kernel.org/stable/c/7e10369c72db7a0e2f77b2e306aadc07aef6b07a|https://git.kernel.org/stable/c/9d0bef3cc22cf250278ed45b829f062a00af9e27|https://git.kernel.org/stable/c/7e10369c72db7a0e2f77b2e306aadc07aef6b07a|https://git.kernel.org/stable/c/3ce1497add6d17b48cc9df65095bd20202d93994|https://git.kernel.org/stable/c/9d0bef3cc22cf250278ed45b829f062a00af9e27|https://git.kernel.org/stable/c/5d5c6dba2b43e28845d7d7ed32a36802329a5f52,|||||||,0,0,Linux/Linux 5.15.34,Linux/Linux 5.15.34,"Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.
                  For example, glibc in Linux provides protection against free of invalid pointers.
                  When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].
                  To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",Memory Leak,Medium,Memory Leak,Buffer Overflow,
CVE-2021-47585,"In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix memory leak in __add_inode_ref()

Line 1169 (#3) allocates a memory chunk for victim_name by kmalloc(),
but  when the function returns in line 1184 (#4) victim_name allocated
by line 1169 (#3) is not freed, which will lead to a memory leak.
There is a similar snippet of code in this function as allocating a memory
chunk for victim_name in line 1104 (#1) as well as releasing the memory
in line 1116 (#2).

We should kfree() victim_name when the return value of backref_in_log()
is less than zero and before the function returns in line 1184 (#4).

1057 static inline int __add_inode_ref(struct btrfs_trans_handle *trans,
1058 				  struct btrfs_root *root,
1059 				  struct btrfs_path *path,
1060 				  struct btrfs_root *log_root,
1061 				  struct btrfs_inode *dir,
1062 				  struct btrfs_inode *inode,
1063 				  u64 inode_objectid, u64 parent_objectid,
1064 				  u64 ref_index, char *name, int namelen,
1065 				  int *search_done)
1066 {

1104 	victim_name = kmalloc(victim_name_len, GFP_NOFS);
	// #1: kmalloc (victim_name-1)
1105 	if (!victim_name)
1106 		return -ENOMEM;

1112	ret = backref_in_log(log_root, &search_key,
1113			parent_objectid, victim_name,
1114			victim_name_len);
1115	if (ret < 0) {
1116		kfree(victim_name); // #2: kfree (victim_name-1)
1117		return ret;
1118	} else if (!ret) {

1169 	victim_name = kmalloc(victim_name_len, GFP_NOFS);
	// #3: kmalloc (victim_name-2)
1170 	if (!victim_name)
1171 		return -ENOMEM;

1180 	ret = backref_in_log(log_root, &search_key,
1181 			parent_objectid, victim_name,
1182 			victim_name_len);
1183 	if (ret < 0) {
1184 		return ret; // #4: missing kfree (victim_name-2)
1185 	} else if (!ret) {

1241 	return 0;
1242 }",,,0,0,0,0,,,,,,,CWE-401,Missing Release of Memory after Effective Lifetime,Variant,"Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.
                  For example, glibc in Linux provides protection against free of invalid pointers.
                  When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].
                  To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",Linux,Linux,5.15.11,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,7,9,https://git.kernel.org/stable/c/005d9292b5b2e71a009f911bd85d755009b37242|https://git.kernel.org/stable/c/005d9292b5b2e71a009f911bd85d755009b37242|https://git.kernel.org/stable/c/493ff661d434d6bdf02e3a21adae04d7a0b4265d|https://git.kernel.org/stable/c/493ff661d434d6bdf02e3a21adae04d7a0b4265d|https://git.kernel.org/stable/c/f35838a6930296fc1988764cfa54cb3f705c0665|https://git.kernel.org/stable/c/f35838a6930296fc1988764cfa54cb3f705c0665|https://git.kernel.org/stable/c/005d9292b5b2e71a009f911bd85d755009b37242|https://git.kernel.org/stable/c/493ff661d434d6bdf02e3a21adae04d7a0b4265d|https://git.kernel.org/stable/c/f35838a6930296fc1988764cfa54cb3f705c0665,||||||||,0,0,Linux/Linux 5.15.11,Linux/Linux 5.15.11,"Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.
                  For example, glibc in Linux provides protection against free of invalid pointers.
                  When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].
                  To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",Memory Leak,Medium,Memory Leak,Denial of Service (DoS),
CVE-2024-50190,"In the Linux kernel, the following vulnerability has been resolved:

ice: fix memleak in ice_init_tx_topology()

Fix leak of the FW blob (DDP pkg).

Make ice_cfg_tx_topo() const-correct, so ice_init_tx_topology() can avoid
copying whole FW blob. Copy just the topology section, and only when
needed. Reuse the buffer allocated for the read of the current topology.

This was found by kmemleak, with the following trace for each PF:
    [<ffffffff8761044d>] kmemdup_noprof+0x1d/0x50
    [<ffffffffc0a0a480>] ice_init_ddp_config+0x100/0x220 [ice]
    [<ffffffffc0a0da7f>] ice_init_dev+0x6f/0x200 [ice]
    [<ffffffffc0a0dc49>] ice_init+0x29/0x560 [ice]
    [<ffffffffc0a10c1d>] ice_probe+0x21d/0x310 [ice]

Constify ice_cfg_tx_topo() @buf parameter.
This cascades further down to few more functions.",,,0,0,0,0,,,,,,,CWE-401,Missing Release of Memory after Effective Lifetime,Variant,"Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.
                  For example, glibc in Linux provides protection against free of invalid pointers.
                  When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].
                  To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",Linux,Linux,6.11.4,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,7,4,https://git.kernel.org/stable/c/43544b4e30732c3d88f423252281915d5bc739b6|https://git.kernel.org/stable/c/c188afdc36113760873ec78cbc036f6b05f77621|https://git.kernel.org/stable/c/43544b4e30732c3d88f423252281915d5bc739b6|https://git.kernel.org/stable/c/c188afdc36113760873ec78cbc036f6b05f77621,|||,0,0,Linux/Linux 6.11.4,Linux/Linux 6.11.4,"Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.
                  For example, glibc in Linux provides protection against free of invalid pointers.
                  When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].
                  To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",Memory Leak,Medium,Memory Leak,Privilege Escalation,
CVE-2022-49855,"In the Linux kernel, the following vulnerability has been resolved:

net: wwan: iosm: fix memory leak in ipc_pcie_read_bios_cfg

ipc_pcie_read_bios_cfg() is using the acpi_evaluate_dsm() to
obtain the wwan power state configuration from BIOS but is
not freeing the acpi_object. The acpi_evaluate_dsm() returned
acpi_object to be freed.

Free the acpi_object after use.",,,0,0,0,0,,,,,,,CWE-401,Missing Release of Memory after Effective Lifetime,Variant,"Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.
                  For example, glibc in Linux provides protection against free of invalid pointers.
                  When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].
                  To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",linux,linux_kernel,*,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,8,12,https://git.kernel.org/stable/c/13b1ea861e8aeb701bcfbfe436b943efa2d44029|https://git.kernel.org/stable/c/7560ceef4d2832a67e8781d924e129c7f542376f|https://git.kernel.org/stable/c/d38a648d2d6cc7bee11c6f533ff9426a00c2a74c|https://git.kernel.org/stable/c/13b1ea861e8aeb701bcfbfe436b943efa2d44029|https://git.kernel.org/stable/c/7560ceef4d2832a67e8781d924e129c7f542376f|https://git.kernel.org/stable/c/d38a648d2d6cc7bee11c6f533ff9426a00c2a74c|https://git.kernel.org/stable/c/13b1ea861e8aeb701bcfbfe436b943efa2d44029|https://git.kernel.org/stable/c/7560ceef4d2832a67e8781d924e129c7f542376f|https://git.kernel.org/stable/c/d38a648d2d6cc7bee11c6f533ff9426a00c2a74c|https://git.kernel.org/stable/c/13b1ea861e8aeb701bcfbfe436b943efa2d44029|https://git.kernel.org/stable/c/7560ceef4d2832a67e8781d924e129c7f542376f|https://git.kernel.org/stable/c/d38a648d2d6cc7bee11c6f533ff9426a00c2a74c,|||||||||||,0,0,linux/linux_kernel *,linux/linux_kernel *,"Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.
                  For example, glibc in Linux provides protection against free of invalid pointers.
                  When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].
                  To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",Memory Leak,Medium,Memory Leak,Information Disclosure,
CVE-2024-41006,"In the Linux kernel, the following vulnerability has been resolved:

netrom: Fix a memory leak in nr_heartbeat_expiry()

syzbot reported a memory leak in nr_create() [0].

Commit 409db27e3a2e (""netrom: Fix use-after-free of a listening socket."")
added sock_hold() to the nr_heartbeat_expiry() function, where
a) a socket has a SOCK_DESTROY flag or
b) a listening socket has a SOCK_DEAD flag.

But in the case ""a,"" when the SOCK_DESTROY flag is set, the file descriptor
has already been closed and the nr_release() function has been called.
So it makes no sense to hold the reference count because no one will
call another nr_destroy_socket() and put it as in the case ""b.""

nr_connect
  nr_establish_data_link
    nr_start_heartbeat

nr_release
  switch (nr->state)
  case NR_STATE_3
    nr->state = NR_STATE_2
    sock_set_flag(sk, SOCK_DESTROY);

                        nr_rx_frame
                          nr_process_rx_frame
                            switch (nr->state)
                            case NR_STATE_2
                              nr_state2_machine()
                                nr_disconnect()
                                  nr_sk(sk)->state = NR_STATE_0
                                  sock_set_flag(sk, SOCK_DEAD)

                        nr_heartbeat_expiry
                          switch (nr->state)
                          case NR_STATE_0
                            if (sock_flag(sk, SOCK_DESTROY) ||
                               (sk->sk_state == TCP_LISTEN
                                 && sock_flag(sk, SOCK_DEAD)))
                               sock_hold()  // ( !!! )
                               nr_destroy_socket()

To fix the memory leak, let's call sock_hold() only for a listening socket.

Found by InfoTeCS on behalf of Linux Verification Center
(linuxtesting.org) with Syzkaller.

[0]: https://syzkaller.appspot.com/bug?extid=d327a1f3b12e1e206c16",,,0,0,0,0,,,,,,,CWE-401,Missing Release of Memory after Effective Lifetime,Variant,"Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.
                  For example, glibc in Linux provides protection against free of invalid pointers.
                  When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].
                  To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",Linux,Linux,e666990abb2e42dd4ba979b4706280a3664cfae7,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,19,24,https://git.kernel.org/stable/c/0b9130247f3b6a1122478471ff0e014ea96bb735|https://git.kernel.org/stable/c/0b9130247f3b6a1122478471ff0e014ea96bb735|https://git.kernel.org/stable/c/280cf1173726a7059b628c610c71050d5c0b6937|https://git.kernel.org/stable/c/280cf1173726a7059b628c610c71050d5c0b6937|https://git.kernel.org/stable/c/5391f9db2cab5ef1cb411be1ab7dbec728078fba|https://git.kernel.org/stable/c/5391f9db2cab5ef1cb411be1ab7dbec728078fba|https://git.kernel.org/stable/c/a02fd5d775cf9787ee7698c797e20f2fa13d2e2b|https://git.kernel.org/stable/c/a02fd5d775cf9787ee7698c797e20f2fa13d2e2b|https://git.kernel.org/stable/c/b6ebe4fed73eedeb73f4540f8edc4871945474c8|https://git.kernel.org/stable/c/b6ebe4fed73eedeb73f4540f8edc4871945474c8|https://git.kernel.org/stable/c/d377f5a28332954b19e373d36823e59830ab1712|https://git.kernel.org/stable/c/d377f5a28332954b19e373d36823e59830ab1712|https://git.kernel.org/stable/c/d616876256b38ecf9a1a1c7d674192c5346bc69c|https://git.kernel.org/stable/c/d616876256b38ecf9a1a1c7d674192c5346bc69c|https://git.kernel.org/stable/c/e07a9c2a850cdebf625e7a1b8171bd23a8554313|https://git.kernel.org/stable/c/e07a9c2a850cdebf625e7a1b8171bd23a8554313|https://git.kernel.org/stable/c/d616876256b38ecf9a1a1c7d674192c5346bc69c|https://git.kernel.org/stable/c/e07a9c2a850cdebf625e7a1b8171bd23a8554313|https://git.kernel.org/stable/c/5391f9db2cab5ef1cb411be1ab7dbec728078fba|https://git.kernel.org/stable/c/280cf1173726a7059b628c610c71050d5c0b6937|https://git.kernel.org/stable/c/a02fd5d775cf9787ee7698c797e20f2fa13d2e2b|https://git.kernel.org/stable/c/b6ebe4fed73eedeb73f4540f8edc4871945474c8|https://git.kernel.org/stable/c/d377f5a28332954b19e373d36823e59830ab1712|https://git.kernel.org/stable/c/0b9130247f3b6a1122478471ff0e014ea96bb735,|||||||||||||||||||||||,0,0,Linux/Linux e666990abb2e42dd4ba979b4706280a3664cfae7,Linux/Linux e666990abb2e42dd4ba979b4706280a3664cfae7,"Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone.
                  For example, glibc in Linux provides protection against free of invalid pointers.
                  When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391].
                  To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost.; Use an abstraction library to abstract away risky APIs. Not a complete solution.; The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code.",Memory Leak,Medium,Memory Leak,Remote Code Execution,
CVE-2024-8479,"The The Simple Spoiler plugin for WordPress is vulnerable to arbitrary shortcode execution in versions 1.2 to 1.3. This is due to the plugin adding the filter add_filter('comment_text', 'do_shortcode'); which will run all shortcodes in comments. This makes it possible for unauthenticated attackers to execute arbitrary shortcodes.",,,0,0,0,0,,,,,,,CWE-94,Improper Control of Generation of Code ('Code Injection'),Base,"Refactor your program so that you do not have to dynamically generate code.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Other_Vendor,Other_Product,*,,,,,,7.3,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L,N,L,N,N,U,L,L,L,2,6,https://plugins.trac.wordpress.org/browser/simple-spoiler/trunk/simple-spoiler.php#L108|https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&old=3151179%40simple-spoiler&new=3151179%40simple-spoiler&sfp_email=&sfph_mail=|https://www.wordfence.com/threat-intel/vulnerabilities/id/8ffc76d8-b841-4c26-bbc6-1f96664efe36?source=cve|https://www.wordfence.com/threat-intel/vulnerabilities/id/8ffc76d8-b841-4c26-bbc6-1f96664efe36?source=cve|https://plugins.trac.wordpress.org/browser/simple-spoiler/trunk/simple-spoiler.php#L108|https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&old=3151179%40simple-spoiler&new=3151179%40simple-spoiler&sfp_email=&sfph_mail=,|||||,0,0,webliberty/simple_spoiler *,webliberty/simple_spoiler *,"Refactor your program so that you do not have to dynamically generate code.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Code Injection,High,Code Injection,Denial of Service (DoS),
CVE-2024-45480,An improper control of generation of code ('Code Injection') vulnerability in the AprolCreateReport component of B&R APROL <4.4-00P5 may allow an unauthenticated network-based attacker to read files from the local system.,,,0,0,0,0,,,,,,,CWE-94,Improper Control of Generation of Code ('Code Injection'),Base,"Refactor your program so that you do not have to dynamically generate code.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Other_Vendor,Other_Product,R4.4,,,,,,0,,,,,,,,,,,,1,2,https://www.br-automation.com/fileadmin/SA24P015-77573c08.pdf|https://www.br-automation.com/fileadmin/SA24P015-77573c08.pdf,|,0,0,B&R Industrial Automation/B&R APROL R4.4,B&R Industrial Automation/B&R APROL R4.4,"Refactor your program so that you do not have to dynamically generate code.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Code Injection,,Code Injection,Privilege Escalation,
CVE-2022-25894,"All versions of the package com.bstek.uflo:uflo-core are vulnerable to Remote Code Execution (RCE) in the ExpressionContextImpl class via jexl.createExpression(expression).evaluate(context); functionality, due to improper user input validation.",,,0,0,0,0,,,,,,,CWE-94,Improper Control of Generation of Code ('Code Injection'),Base,"Refactor your program so that you do not have to dynamically generate code.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Other_Vendor,Other_Product,0,,,,,,9.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H/E:P,N,L,N,N,U,H,H,H,2,9,https://fmyyy1.github.io/2022/10/23/uflo2rce/|https://fmyyy1.github.io/2022/10/23/uflo2rce/|https://github.com/youseries/uflo/blob/b3e198bc6523e5a6ba69edd84ba10e05a3b78726/uflo-core/src/main/java/com/bstek/uflo/expr/impl/ExpressionContextImpl.java%23L126|https://github.com/youseries/uflo/blob/b3e198bc6523e5a6ba69edd84ba10e05a3b78726/uflo-core/src/main/java/com/bstek/uflo/expr/impl/ExpressionContextImpl.java%23L126|https://security.snyk.io/vuln/SNYK-JAVA-COMBSTEKUFLO-3091112|https://security.snyk.io/vuln/SNYK-JAVA-COMBSTEKUFLO-3091112|https://security.snyk.io/vuln/SNYK-JAVA-COMBSTEKUFLO-3091112|https://github.com/youseries/uflo/blob/b3e198bc6523e5a6ba69edd84ba10e05a3b78726/uflo-core/src/main/java/com/bstek/uflo/expr/impl/ExpressionContextImpl.java%23L126|https://fmyyy1.github.io/2022/10/23/uflo2rce/,||||||||,0,0,n/a/com.bstek.uflo:uflo-core 0,n/a/com.bstek.uflo:uflo-core 0,"Refactor your program so that you do not have to dynamically generate code.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Code Injection,Critical,Code Injection,Information Disclosure,
CVE-2023-20063,"A vulnerability in the inter-device communication mechanisms between devices that are running Cisco Firepower Threat Defense (FTD) Software and devices that are running Cisco Firepower Management (FMC) Software could allow an authenticated, local attacker to execute arbitrary commands with root permissions on the underlying operating system of an affected device.

This vulnerability is due to insufficient validation of user-supplied input. An attacker could exploit this vulnerability by accessing the expert mode of an affected device and submitting specific commands to a connected system. A successful exploit could allow the attacker to execute arbitrary code in the context of an FMC device if the attacker has administrative privileges on an associated FTD device. Alternatively, a successful exploit could allow the attacker to execute arbitrary code in the context of an FTD device if the attacker has administrative privileges on an associated FMC device.",,,0,0,0,0,,,,,,,CWE-94,Improper Control of Generation of Code ('Code Injection'),Base,"Refactor your program so that you do not have to dynamically generate code.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Cisco,Cisco Firepower Threat Defense Software,6.6.7,,,,,,8.2,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H,L,L,H,N,C,H,H,H,366,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ftd-fmc-code-inj-wSHrgz8L|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ftd-fmc-code-inj-wSHrgz8L|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ftd-fmc-code-inj-wSHrgz8L,||,0,0,Cisco/Cisco Firepower Threat Defense Software 6.6.7,Cisco/Cisco Firepower Threat Defense Software 6.6.7,"Refactor your program so that you do not have to dynamically generate code.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Code Injection,High,Code Injection,Remote Code Execution,
CVE-2021-22961,A code injection vulnerability exists within the firewall software of GlassWire v2.1.167 that could lead to arbitrary code execution from a file in the user path on first execution.,,,0,0,0,0,,,,,,,CWE-94,Improper Control of Generation of Code ('Code Injection'),Base,"Refactor your program so that you do not have to dynamically generate code.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Other_Vendor,Other_Product,2.1.167,,,,,,9.8,3.9,5.9,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,N,L,N,N,U,H,H,H,2,3,https://hackerone.com/reports/1193641|https://hackerone.com/reports/1193641|https://hackerone.com/reports/1193641,||,0,0,glasswire/glasswire 2.1.167,glasswire/glasswire 2.1.167,"Refactor your program so that you do not have to dynamically generate code.; Run your code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.
                  Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's ""-T"" switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Code Injection,Critical,Code Injection,Denial of Service (DoS),
CVE-2024-31984,"XWiki Platform is a generic wiki platform. Starting in version 7.2-rc-1 and prior to versions 4.10.20, 15.5.4, and 15.10-rc-1, by creating a document with a specially crafted title, it is possible to trigger remote code execution in the (Solr-based) search in XWiki. This allows any user who can edit the title of a space (all users by default) to execute any Groovy code in the XWiki installation which compromises the confidentiality, integrity and availability of the whole XWiki installation. This has been patched in XWiki 14.10.20, 15.5.4 and 15.10 RC1. As a workaround, manually apply the patch to the `Main.SolrSpaceFacet` page.",,,0,0,0,0,,,,,,,CWE-95,Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection'),Variant,"If possible, refactor your code so that it does not need to use eval() at all.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Other_Vendor,Other_Product,*,,,,,,10,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H,N,L,L,N,C,H,H,H,10,24,https://github.com/xwiki/xwiki-platform/commit/43c9d551e3c11e9d8f176b556dd33bbe31fc66e0|https://github.com/xwiki/xwiki-platform/commit/43c9d551e3c11e9d8f176b556dd33bbe31fc66e0|https://github.com/xwiki/xwiki-platform/commit/5ef9d294d37be92ee22b2549e38663b29dce8767|https://github.com/xwiki/xwiki-platform/commit/5ef9d294d37be92ee22b2549e38663b29dce8767|https://github.com/xwiki/xwiki-platform/commit/74e301c481e69eeea674dac7fed6af3614cf08c5|https://github.com/xwiki/xwiki-platform/commit/74e301c481e69eeea674dac7fed6af3614cf08c5|https://github.com/xwiki/xwiki-platform/commit/94fc12db87c2431eb1335ecb9c2954b1905bde62|https://github.com/xwiki/xwiki-platform/commit/94fc12db87c2431eb1335ecb9c2954b1905bde62|https://github.com/xwiki/xwiki-platform/commit/acba74c149a041345b24dcca52c586f872ba97fb|https://github.com/xwiki/xwiki-platform/commit/acba74c149a041345b24dcca52c586f872ba97fb|https://github.com/xwiki/xwiki-platform/commit/ef55105d6eeec5635fd693f0070c5aaaf3bdd940|https://github.com/xwiki/xwiki-platform/commit/ef55105d6eeec5635fd693f0070c5aaaf3bdd940|https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-xm4h-3jxr-m3c6|https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-xm4h-3jxr-m3c6|https://jira.xwiki.org/browse/XWIKI-21471|https://jira.xwiki.org/browse/XWIKI-21471|https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-xm4h-3jxr-m3c6|https://github.com/xwiki/xwiki-platform/commit/43c9d551e3c11e9d8f176b556dd33bbe31fc66e0|https://github.com/xwiki/xwiki-platform/commit/5ef9d294d37be92ee22b2549e38663b29dce8767|https://github.com/xwiki/xwiki-platform/commit/74e301c481e69eeea674dac7fed6af3614cf08c5|https://github.com/xwiki/xwiki-platform/commit/94fc12db87c2431eb1335ecb9c2954b1905bde62|https://github.com/xwiki/xwiki-platform/commit/acba74c149a041345b24dcca52c586f872ba97fb|https://github.com/xwiki/xwiki-platform/commit/ef55105d6eeec5635fd693f0070c5aaaf3bdd940|https://jira.xwiki.org/browse/XWIKI-21471,|||||||||||||||||||||||,0,0,xwiki/xwiki *,xwiki/xwiki *,"If possible, refactor your code so that it does not need to use eval() at all.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; For Python programs, it is frequently encouraged to use the ast.literal_eval() function instead of eval, since it is intentionally designed to avoid executing code. However, an adversary could still cause excessive memory or stack consumption via deeply nested structures [REF-1372], so the python documentation discourages use of ast.literal_eval() on untrusted data [REF-1373].",Injection,Critical,Injection,Privilege Escalation,
CVE-2025-3546,"A vulnerability was found in H3C Magic NX15, Magic NX30 Pro, Magic NX400, Magic R3010 and Magic BE18000 up to V100R014. It has been declared as critical. Affected by this vulnerability is the function FCGI_CheckStringIfContainsSemicolon of the file /api/wizard/getLanguage of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack can only be done within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",,,0,0,0,0,,,,,,,CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),Class,Programming languages and supporting technologies might be chosen which are not subject to these issues.; Utilize an appropriate mix of allowlist and denylist parsing to filter control-plane syntax from all input.,Other_Vendor,Other_Product,V100R014,,,,,,8,,,CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,A,L,L,N,U,H,H,H,10,12,https://gist.github.com/isstabber/154661f329e4ae6bfe15dcdc0b932ff3|https://vuldb.com/?ctiid.304585|https://vuldb.com/?id.304585|https://vuldb.com/?submit.524745|https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/|https://zhiliao.h3c.com/theme/details/229784|https://vuldb.com/?id.304585|https://vuldb.com/?ctiid.304585|https://vuldb.com/?submit.524745|https://gist.github.com/isstabber/154661f329e4ae6bfe15dcdc0b932ff3|https://zhiliao.h3c.com/theme/details/229784|https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/,|||||||||||,0,0,H3C/Magic R3010 V100R014,H3C/Magic R3010 V100R014,Programming languages and supporting technologies might be chosen which are not subject to these issues.; Utilize an appropriate mix of allowlist and denylist parsing to filter control-plane syntax from all input.,Injection,High,Injection,Information Disclosure,
CVE-2023-20260,"A vulnerability in the application CLI of Cisco Prime Infrastructure and Cisco Evolved Programmable Network Manager could allow an authenticated, local attacker to gain escalated privileges. This vulnerability is due to improper processing of command line arguments to application scripts. An attacker could exploit this vulnerability by issuing a command on the CLI with malicious options. A successful exploit could allow the attacker to gain the escalated privileges of the root user on the underlying operating system.",,,0,0,0,0,,,,,,,CWE-88,Improper Neutralization of Argument Delimiters in a Command ('Argument Injection'),Base,"Where possible, avoid building a single string that contains the command and its arguments.  Some languages or frameworks have functions that support specifying independent arguments, e.g. as an array, which is used to automatically perform the appropriate quoting or escaping while building the command.  For example, in PHP, escapeshellarg() can be used to escape a single argument to system(), or exec() can be called with an array of arguments.  In C, code can often be refactored from using system() - which accepts a single string - to using exec(), which requires separate function arguments for each parameter.; Understand all the potential areas where untrusted inputs can enter your product: parameters or arguments, cookies, anything read from the network, environment variables, request headers as well as content, URL components, e-mail, files, databases, and any external systems that provide data to the application. Perform input validation at well-defined interfaces.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.",Cisco,Cisco Prime Infrastructure,3.5.0 Update 01,,,,,,6,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N,L,L,H,N,U,H,H,N,476,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-pi-epnm-wkZJeyeq|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-pi-epnm-wkZJeyeq|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-pi-epnm-wkZJeyeq,||,0,0,Cisco/Cisco Prime Infrastructure 3.5.0 Update 01,Cisco/Cisco Prime Infrastructure 3.5.0 Update 01,"Where possible, avoid building a single string that contains the command and its arguments.  Some languages or frameworks have functions that support specifying independent arguments, e.g. as an array, which is used to automatically perform the appropriate quoting or escaping while building the command.  For example, in PHP, escapeshellarg() can be used to escape a single argument to system(), or exec() can be called with an array of arguments.  In C, code can often be refactored from using system() - which accepts a single string - to using exec(), which requires separate function arguments for each parameter.; Understand all the potential areas where untrusted inputs can enter your product: parameters or arguments, cookies, anything read from the network, environment variables, request headers as well as content, URL components, e-mail, files, databases, and any external systems that provide data to the application. Perform input validation at well-defined interfaces.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.
                  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.; When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.; When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.",Injection,Medium,Injection,Remote Code Execution,
CVE-2023-44373,"A vulnerability has been identified in RUGGEDCOM RM1224 LTE(4G) EU (6GK6108-4AM00-2BA2) (All versions < V8.0), RUGGEDCOM RM1224 LTE(4G) NAM (6GK6108-4AM00-2DA2) (All versions < V8.0), SCALANCE M804PB (6GK5804-0AP00-2AA2) (All versions < V8.0), SCALANCE M812-1 ADSL-Router (6GK5812-1AA00-2AA2) (All versions < V8.0), SCALANCE M812-1 ADSL-Router (6GK5812-1BA00-2AA2) (All versions < V8.0), SCALANCE M816-1 ADSL-Router (6GK5816-1AA00-2AA2) (All versions < V8.0), SCALANCE M816-1 ADSL-Router (6GK5816-1BA00-2AA2) (All versions < V8.0), SCALANCE M826-2 SHDSL-Router (6GK5826-2AB00-2AB2) (All versions < V8.0), SCALANCE M874-2 (6GK5874-2AA00-2AA2) (All versions < V8.0), SCALANCE M874-3 (6GK5874-3AA00-2AA2) (All versions < V8.0), SCALANCE M876-3 (6GK5876-3AA02-2BA2) (All versions < V8.0), SCALANCE M876-3 (ROK) (6GK5876-3AA02-2EA2) (All versions < V8.0), SCALANCE M876-4 (6GK5876-4AA10-2BA2) (All versions < V8.0), SCALANCE M876-4 (EU) (6GK5876-4AA00-2BA2) (All versions < V8.0), SCALANCE M876-4 (NAM) (6GK5876-4AA00-2DA2) (All versions < V8.0), SCALANCE MUM853-1 (EU) (6GK5853-2EA00-2DA1) (All versions < V8.0), SCALANCE MUM856-1 (EU) (6GK5856-2EA00-3DA1) (All versions < V8.0), SCALANCE MUM856-1 (RoW) (6GK5856-2EA00-3AA1) (All versions < V8.0), SCALANCE S615 EEC LAN-Router (6GK5615-0AA01-2AA2) (All versions < V8.0), SCALANCE S615 LAN-Router (6GK5615-0AA00-2AA2) (All versions < V8.0), SCALANCE WAB762-1 (6GK5762-1AJ00-6AA0) (All versions < V2.4.0), SCALANCE WAM763-1 (6GK5763-1AL00-7DA0) (All versions < V2.4.0), SCALANCE WAM763-1 (ME) (6GK5763-1AL00-7DC0) (All versions < V2.4.0), SCALANCE WAM763-1 (US) (6GK5763-1AL00-7DB0) (All versions < V2.4.0), SCALANCE WAM766-1 (EU) (6GK5766-1GE00-7DA0) (All versions < V2.4.0), SCALANCE WAM766-1 (ME) (6GK5766-1GE00-7DC0) (All versions < V2.4.0), SCALANCE WAM766-1 (US) (6GK5766-1GE00-7DB0) (All versions < V2.4.0), SCALANCE WAM766-1 EEC (EU) (6GK5766-1GE00-7TA0) (All versions < V2.4.0), SCALANCE WAM766-1 EEC (ME) (6GK5766-1GE00-7TC0) (All versions < V2.4.0), SCALANCE WAM766-1 EEC (US) (6GK5766-1GE00-7TB0) (All versions < V2.4.0), SCALANCE WUB762-1 (6GK5762-1AJ00-1AA0) (All versions < V2.4.0), SCALANCE WUB762-1 (6GK5762-1AJ00-2AA0) (All versions < V2.4.0), SCALANCE WUM763-1 (6GK5763-1AL00-3AA0) (All versions < V2.4.0), SCALANCE WUM763-1 (6GK5763-1AL00-3DA0) (All versions < V2.4.0), SCALANCE WUM763-1 (US) (6GK5763-1AL00-3AB0) (All versions < V2.4.0), SCALANCE WUM763-1 (US) (6GK5763-1AL00-3DB0) (All versions < V2.4.0), SCALANCE WUM766-1 (EU) (6GK5766-1GE00-3DA0) (All versions < V2.4.0), SCALANCE WUM766-1 (ME) (6GK5766-1GE00-3DC0) (All versions < V2.4.0), SCALANCE WUM766-1 (US) (6GK5766-1GE00-3DB0) (All versions < V2.4.0). Affected devices do not properly sanitize an input field.  This could allow an authenticated remote attacker with administrative privileges to inject code or spawn a system root shell. Follow-up of CVE-2022-36323.",,,0,0,0,0,,,,,,,CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),Class,Programming languages and supporting technologies might be chosen which are not subject to these issues.; Utilize an appropriate mix of allowlist and denylist parsing to filter control-plane syntax from all input.,Siemens,Other_Product,0,,,,,,9.1,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H/E:P/RL:O/RC:C,N,L,H,N,C,H,H,H,34,20,https://cert-portal.siemens.com/productcert/html/ssa-180704.html|https://cert-portal.siemens.com/productcert/html/ssa-180704.html|https://cert-portal.siemens.com/productcert/html/ssa-602936.html|https://cert-portal.siemens.com/productcert/html/ssa-602936.html|https://cert-portal.siemens.com/productcert/html/ssa-690517.html|https://cert-portal.siemens.com/productcert/html/ssa-690517.html|https://cert-portal.siemens.com/productcert/html/ssa-699386.html|https://cert-portal.siemens.com/productcert/html/ssa-699386.html|https://cert-portal.siemens.com/productcert/html/ssa-721642.html|https://cert-portal.siemens.com/productcert/pdf/ssa-180704.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-180704.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-699386.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-699386.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-699386.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-180704.pdf|https://cert-portal.siemens.com/productcert/html/ssa-699386.html|https://cert-portal.siemens.com/productcert/html/ssa-180704.html|https://cert-portal.siemens.com/productcert/html/ssa-602936.html|https://cert-portal.siemens.com/productcert/html/ssa-690517.html|https://cert-portal.siemens.com/productcert/html/ssa-721642.html,|||||||||||||||||||,0,0,Siemens/SCALANCE WAM763-1 (US) 0,Siemens/SCALANCE WAM763-1 (US) 0,Programming languages and supporting technologies might be chosen which are not subject to these issues.; Utilize an appropriate mix of allowlist and denylist parsing to filter control-plane syntax from all input.,Injection,Critical,Injection,Denial of Service (DoS),
CVE-2025-1582,A vulnerability was found in PHPGurukul Online Nurse Hiring System 1.0. It has been rated as critical. Affected by this issue is some unknown functionality of the file /admin/all-request.php. The manipulation of the argument viewid leads to sql injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used.,,,0,0,0,0,,,,,,,CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),Class,Programming languages and supporting technologies might be chosen which are not subject to these issues.; Utilize an appropriate mix of allowlist and denylist parsing to filter control-plane syntax from all input.,Other_Vendor,Other_Product,1,,,,,,6.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L,N,L,L,N,U,L,L,L,4,10,https://github.com/wqywfvc/CVE/issues/11|https://phpgurukul.com/|https://vuldb.com/?ctiid.296558|https://vuldb.com/?id.296558|https://vuldb.com/?submit.504451|https://vuldb.com/?id.296558|https://vuldb.com/?ctiid.296558|https://vuldb.com/?submit.504451|https://github.com/wqywfvc/CVE/issues/11|https://phpgurukul.com/,|||||||||,0,0,PHPGurukul/Online Nurse Hiring System 1.0,PHPGurukul/Online Nurse Hiring System 1.0,Programming languages and supporting technologies might be chosen which are not subject to these issues.; Utilize an appropriate mix of allowlist and denylist parsing to filter control-plane syntax from all input.,Injection,Medium,Injection,Privilege Escalation,
CVE-2021-22968,"A bypass of adding remote files in Concrete CMS (previously concrete5) File Manager leads to remote code execution in Concrete CMS (concrete5) versions 8.5.6 and below.The external file upload feature stages files in the public directory even if they have disallowed file extensions. They are stored in a directory with a random name, but it's possible to stall the uploads and brute force the directory name. You have to be an admin with the ability to upload files, but this bug gives you the ability to upload restricted file types and execute them depending on server configuration.To fix this, a check for allowed file extensions was added before downloading files to a tmp directory.Concrete CMS Security Team gave this a CVSS v3.1 score of 5.4 AV:N/AC:H/PR:H/UI:R/S:C/C:N/I:H/A:NThis fix is also in Concrete version 9.0.0",,,0,0,0,0,,,,,,,CWE-434,Unrestricted Upload of File with Dangerous Type,Base,"Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.; Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.; Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423]; When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.; Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Other_Vendor,Other_Product,*,,,,,,7.2,1.2,5.9,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,N,L,H,N,U,H,H,H,6,6,https://documentation.concretecms.org/developers/introduction/version-history/857-release-notes|https://documentation.concretecms.org/developers/introduction/version-history/857-release-notes|https://hackerone.com/reports/1350444|https://hackerone.com/reports/1350444|https://documentation.concretecms.org/developers/introduction/version-history/857-release-notes|https://hackerone.com/reports/1350444,|||||,0,0,concretecms/concrete_cms *,concretecms/concrete_cms *,"Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.; Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.; Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423]; When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.; Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Unrestricted File Upload,High,Unrestricted File Upload,Information Disclosure,
CVE-2022-40431,"The d8s-pdfs for python, as distributed on PyPI, included a potential code-execution backdoor inserted by a third party. The backdoor is the democritus-networking package. The affected version is 0.1.0.",,,0,0,0,0,,,,,,,CWE-434,Unrestricted Upload of File with Dangerous Type,Base,"Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.; Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.; Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423]; When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.; Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Other_Vendor,Other_Product,,,,,,,9.8,3.9,5.9,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,N,L,N,N,U,H,H,H,2,6,https://github.com/democritus-project/d8s-pdfs/issues/5|https://github.com/democritus-project/d8s-pdfs/issues/5|https://pypi.org/project/democritus-networking/|https://pypi.org/project/democritus-networking/|https://pypi.org/project/democritus-networking/|https://github.com/democritus-project/d8s-pdfs/issues/5,|||||,0,0,n/a/n/a n/a,n/a/n/a n/a,"Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.; Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.; Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423]; When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.; Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Unrestricted File Upload,Critical,Unrestricted File Upload,Remote Code Execution,
CVE-2024-10413,"A vulnerability, which was classified as critical, has been found in SourceCodester Online Hotel Reservation System 1.0. Affected by this issue is the function upload of the file /guest/update.php. The manipulation of the argument image leads to unrestricted upload. The attack may be launched remotely. The exploit has been disclosed to the public and may be used.",,,0,0,0,0,,,,,,,CWE-434,Unrestricted Upload of File with Dangerous Type,Base,"Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.; Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.; Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423]; When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.; Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Other_Vendor,Other_Product,1,,,,,,6.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L,N,L,L,N,U,L,L,L,2,10,https://vuldb.com/?id.281954|https://vuldb.com/?ctiid.281954|https://vuldb.com/?submit.431595|https://github.com/K1nako0/tmp_vuln11/blob/main/README.md|https://www.sourcecodester.com/|https://vuldb.com/?id.281954|https://vuldb.com/?ctiid.281954|https://vuldb.com/?submit.431595|https://github.com/K1nako0/tmp_vuln11/blob/main/README.md|https://www.sourcecodester.com/,|||||||||,0,0,janobe/online_hotel_reservation_system 1.0,janobe/online_hotel_reservation_system 1.0,"Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.; Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.; Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423]; When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.; Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Unrestricted File Upload,Medium,Unrestricted File Upload,Denial of Service (DoS),
CVE-2021-29641,"Directus 8 before 8.8.2 allows remote authenticated users to execute arbitrary code because file-upload permissions include the ability to upload a .php file to the main upload directory and/or upload a .php file and a .htaccess file to a subdirectory. Exploitation succeeds only for certain installations with the Apache HTTP Server and the local-storage driver (e.g., when the product was obtained from hub.docker.com).",,,0,0,0,0,,,,,,,CWE-434,Unrestricted Upload of File with Dangerous Type,Base,"Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.; Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.; Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423]; When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.; Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Other_Vendor,Other_Product,*,,,,,,8.8,2.8,5.9,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,N,L,L,N,U,H,H,H,2,15,http://packetstormsecurity.com/files/162118/Monospace-Directus-Headless-CMS-File-Upload-Rule-Bypass.html|http://packetstormsecurity.com/files/162118/Monospace-Directus-Headless-CMS-File-Upload-Rule-Bypass.html|http://seclists.org/fulldisclosure/2021/Apr/14|http://seclists.org/fulldisclosure/2021/Apr/14|https://hub.docker.com/layers/directus/directus/v8.8.2-apache/images/sha256-d9898b6442b0150c3c377b50e706757f35d2d563bd82ddaf97f3ae4ba450a6e6?context=explore|https://hub.docker.com/layers/directus/directus/v8.8.2-apache/images/sha256-d9898b6442b0150c3c377b50e706757f35d2d563bd82ddaf97f3ae4ba450a6e6?context=explore|https://sec-consult.com/de/vulnerability-lab/advisory/arbitrary-file-upload-and-bypassing-htaccess-rules-in-monospace-directus-headless-cms/|https://sec-consult.com/de/vulnerability-lab/advisory/arbitrary-file-upload-and-bypassing-htaccess-rules-in-monospace-directus-headless-cms/|https://sec-consult.com/vulnerability-lab/advisory/arbitrary-file-upload-and-bypassing-htaccess-rules-in-monospace-directus-headless-cms/|https://sec-consult.com/vulnerability-lab/advisory/arbitrary-file-upload-and-bypassing-htaccess-rules-in-monospace-directus-headless-cms/|https://hub.docker.com/layers/directus/directus/v8.8.2-apache/images/sha256-d9898b6442b0150c3c377b50e706757f35d2d563bd82ddaf97f3ae4ba450a6e6?context=explore|http://seclists.org/fulldisclosure/2021/Apr/14|https://sec-consult.com/de/vulnerability-lab/advisory/arbitrary-file-upload-and-bypassing-htaccess-rules-in-monospace-directus-headless-cms/|https://sec-consult.com/vulnerability-lab/advisory/arbitrary-file-upload-and-bypassing-htaccess-rules-in-monospace-directus-headless-cms/|http://packetstormsecurity.com/files/162118/Monospace-Directus-Headless-CMS-File-Upload-Rule-Bypass.html,||||||||||||||,0,0,rangerstudio/directus *,rangerstudio/directus *,"Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.; Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.; Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423]; When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.; Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Unrestricted File Upload,High,Unrestricted File Upload,Privilege Escalation,
CVE-2024-11390,"Unrestricted upload of a file with dangerous type in Kibana can lead to arbitrary JavaScript execution in a victim’s browser (XSS) via crafted HTML and JavaScript files.

The attacker must have access to the Synthetics app AND/OR have access to write to the synthetics indices.",,,0,0,0,0,,,,,,,CWE-434,Unrestricted Upload of File with Dangerous Type,Base,"Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.; Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.; Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423]; When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.; Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Other_Vendor,Other_Product,7.17.6,,,,,,5.4,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N,N,L,L,R,C,L,L,N,2,4,https://discuss.elastic.co/t/kibana-7-17-24-and-8-12-0-security-update-esa-2024-20/377712|https://discuss.elastic.co/t/kibana-7-17-24-and-8-12-0-security-update-esa-2024-20/377712|https://discuss.elastic.co/t/kibana-7-17-24-and-8-12-0-security-update-esa-2024-20/377712|https://discuss.elastic.co/t/kibana-7-17-24-and-8-12-0-security-update-esa-2024-20/377712,|||,0,0,Elastic/Kibana 7.17.6,Elastic/Kibana 7.17.6,"Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.; Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions.; Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types.; Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that ""filename.php.gif"" is fed to the PHP interpreter.[REF-422] [REF-423]; When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field.; Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution.; Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.; Run the code in a ""jail"" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.
                  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.
                  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.
                  Be careful to avoid CWE-243 and other weaknesses related to jails.",Unrestricted File Upload,Medium,Unrestricted File Upload,Information Disclosure,
CVE-2023-20900,A malicious actor that has been granted  Guest Operation Privileges https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-security/GUID-6A952214-0E5E-4CCF-9D2A-90948FF643EC.html  in a target virtual machine may be able to elevate their privileges if that target virtual machine has been assigned a more privileged  Guest Alias https://vdc-download.vmware.com/vmwb-repository/dcr-public/d1902b0e-d479-46bf-8ac9-cee0e31e8ec0/07ce8dbd-db48-4261-9b8f-c6d3ad8ba472/vim.vm.guest.AliasManager.html .,,,0,0,0,0,,,,,,,CWE-294,Authentication Bypass by Capture-replay,Base,"Utilize some sequence or time stamping functionality along with a checksum which takes this into account in order to ensure that messages can be parsed only once.; Since any attacker who can listen to traffic can see sequence numbers, it is necessary to sign messages with some kind of cryptography to ensure that sequence numbers are not simply doctored along with content.",Other_Vendor,Other_Product,11.x.x,,,,,,7.1,,,CVSS:3.1/AV:A/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,A,H,L,N,U,H,H,H,13,27,http://www.openwall.com/lists/oss-security/2023/08/31/1|http://www.openwall.com/lists/oss-security/2023/08/31/1|http://www.openwall.com/lists/oss-security/2023/10/27/1|http://www.openwall.com/lists/oss-security/2023/10/27/1|https://lists.debian.org/debian-lts-announce/2023/10/msg00000.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00000.html|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NVKQ6Y2JFJRWPFOZUOTFO3H27BK5GGOG/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NVKQ6Y2JFJRWPFOZUOTFO3H27BK5GGOG/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TJNJMD67QIT6LXLKWSHFM47DCLRSMT6W/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TJNJMD67QIT6LXLKWSHFM47DCLRSMT6W/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZJM6HDRQYS74JA7YNKQBFH2XSZ52HEWH/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZJM6HDRQYS74JA7YNKQBFH2XSZ52HEWH/|https://security.netapp.com/advisory/ntap-20231013-0002/|https://security.netapp.com/advisory/ntap-20231013-0002/|https://www.debian.org/security/2023/dsa-5493|https://www.debian.org/security/2023/dsa-5493|https://www.vmware.com/security/advisories/VMSA-2023-0019.html|https://www.vmware.com/security/advisories/VMSA-2023-0019.html|https://www.vmware.com/security/advisories/VMSA-2023-0019.html|http://www.openwall.com/lists/oss-security/2023/08/31/1|https://www.debian.org/security/2023/dsa-5493|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZJM6HDRQYS74JA7YNKQBFH2XSZ52HEWH/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NVKQ6Y2JFJRWPFOZUOTFO3H27BK5GGOG/|https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TJNJMD67QIT6LXLKWSHFM47DCLRSMT6W/|https://lists.debian.org/debian-lts-announce/2023/10/msg00000.html|https://security.netapp.com/advisory/ntap-20231013-0002/|http://www.openwall.com/lists/oss-security/2023/10/27/1,||||||||||||||||||||||||||,0,0,n/a/VMware Tools 11.x.x,n/a/VMware Tools 11.x.x,"Utilize some sequence or time stamping functionality along with a checksum which takes this into account in order to ensure that messages can be parsed only once.; Since any attacker who can listen to traffic can see sequence numbers, it is necessary to sign messages with some kind of cryptography to ensure that sequence numbers are not simply doctored along with content.",Security Bypass,High,Security Bypass,Remote Code Execution,
CVE-2023-20046,"A vulnerability in the key-based SSH authentication feature of Cisco StarOS Software could allow an authenticated, remote attacker to elevate privileges on an affected device.
 This vulnerability is due to insufficient validation of user-supplied credentials. An attacker could exploit this vulnerability by sending a valid low-privileged SSH key to an affected device from a host that has an IP address that is configured as the source for a high-privileged user account. A successful exploit could allow the attacker to log in to the affected device through SSH as a high-privileged user.
   There are workarounds that address this vulnerability.",,,0,0,0,0,,,,,,,CWE-289,Authentication Bypass by Alternate Name,Base,"Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.",Cisco,Cisco ASR 5000 Series Software,21.23.0,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,N,L,L,N,U,H,H,H,810,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-staros-ssh-privesc-BmWeJC3h|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-staros-ssh-privesc-BmWeJC3h|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-staros-ssh-privesc-BmWeJC3h,||,0,0,Cisco/Cisco ASR 5000 Series Software 21.23.0,Cisco/Cisco ASR 5000 Series Software 21.23.0,"Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.",Security Bypass,High,Security Bypass,Denial of Service (DoS),
CVE-2022-25159,"Authentication Bypass by Capture-replay vulnerability in Mitsubishi Electric MELSEC iQ-F series FX5U(C) CPU all versions, Mitsubishi Electric MELSEC iQ-F series FX5UJ CPU all versions, Mitsubishi Electric MELSEC iQ-R series R00/01/02CPU all versions, Mitsubishi Electric MELSEC iQ-R series R04/08/16/32/120(EN)CPU all versions, Mitsubishi Electric MELSEC iQ-R series R08/16/32/120SFCPU all versions, Mitsubishi Electric MELSEC iQ-R series R08/16/32/120PCPU all versions, Mitsubishi Electric MELSEC iQ-R series R08/16/32/120PSFCPU all versions, Mitsubishi Electric MELSEC iQ-R series R16/32/64MTCPU all versions, Mitsubishi Electric MELSEC iQ-R series RJ71C24(-R2/R4) all versions, Mitsubishi Electric MELSEC iQ-R series RJ71EN71 all versions, Mitsubishi Electric MELSEC iQ-R series RJ72GF15-T2 all versions, Mitsubishi Electric MELSEC Q series Q03/04/06/13/26UDVCPU all versions, Mitsubishi Electric MELSEC Q series Q04/06/13/26UDPVCPU all versions, Mitsubishi Electric MELSEC Q series QJ71C24N(-R2/R4) all versions and Mitsubishi Electric MELSEC Q series QJ71E71-100 all versions allows a remote unauthenticated attacker to login to the product by replay attack.",,,0,0,0,0,,,,,,,CWE-294,Authentication Bypass by Capture-replay,Base,"Utilize some sequence or time stamping functionality along with a checksum which takes this into account in order to ensure that messages can be parsed only once.; Since any attacker who can listen to traffic can see sequence numbers, it is necessary to sign messages with some kind of cryptography to ensure that sequence numbers are not simply doctored along with content.",Other_Vendor,Other_Product,Mitsubishi Electric MELSEC iQ-R series RJ72GF15-T2 all versions,,,,,,8.1,2.2,5.9,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H,N,H,N,N,U,H,H,H,15,9,https://jvn.jp/vu/JVNVU96577897/index.html|https://jvn.jp/vu/JVNVU96577897/index.html|https://www.cisa.gov/uscert/ics/advisories/icsa-22-090-04|https://www.cisa.gov/uscert/ics/advisories/icsa-22-090-04|https://www.mitsubishielectric.com/en/psirt/vulnerability/pdf/2021-031_en.pdf|https://www.mitsubishielectric.com/en/psirt/vulnerability/pdf/2021-031_en.pdf|https://www.mitsubishielectric.com/en/psirt/vulnerability/pdf/2021-031_en.pdf|https://jvn.jp/vu/JVNVU96577897/index.html|https://www.cisa.gov/uscert/ics/advisories/icsa-22-090-04,||||||||,0,0,n/a/Mitsubishi Electric MELSEC iQ-F series FX5U(C) CPU; Mitsubishi Electric MELSEC iQ-F series FX5UJ CPU; Mitsubishi Electric MELSEC iQ-R series R00/01/02CPU; Mitsubishi Electric MELSEC iQ-R series R04/08/16/32/120(EN)CPU; Mitsubishi Electric MELSEC iQ-R series R08/16/32/120SFCPU; Mitsubishi Electric MELSEC iQ-R series R08/16/32/120PCPU; Mitsubishi Electric MELSEC iQ-R series R08/16/32/120PSFCPU; Mitsubishi Electric MELSEC iQ-R series R16/32/64MTCPU; Mitsubishi Electric MELSEC iQ-R series RJ71C24(-R2/R4); Mitsubishi Electric MELSEC iQ-R series RJ71EN71; Mitsubishi Electric MELSEC iQ-R series RJ72GF15-T2; Mitsubishi Electric MELSEC Q series Q03/04/06/13/26UDVCPU; Mitsubishi Electric MELSEC Q series Q04/06/13/26UDPVCPU; Mitsubishi Electric MELSEC Q series QJ71C24N(-R2/R4); Mitsubishi Electric MELSEC Q series QJ71E71-100 Mitsubishi Electric MELSEC iQ-R series RJ72GF15-T2 all versions,n/a/Mitsubishi Electric MELSEC iQ-F series FX5U(C) CPU; Mitsubishi Electric MELSEC iQ-F series FX5UJ CPU; Mitsubishi Electric MELSEC iQ-R series R00/01/02CPU; Mitsubishi Electric MELSEC iQ-R series R04/08/16/32/120(EN)CPU; Mitsubishi Electric MELSEC iQ-R series R08/16/32/120SFCPU; Mitsubishi Electric MELSEC iQ-R series R08/16/32/120PCPU; Mitsubishi Electric MELSEC iQ-R series R08/16/32/120PSFCPU; Mitsubishi Electric MELSEC iQ-R series R16/32/64MTCPU; Mitsubishi Electric MELSEC iQ-R series RJ71C24(-R2/R4); Mitsubishi Electric MELSEC iQ-R series RJ71EN71; Mitsubishi Electric MELSEC iQ-R series RJ72GF15-T2; Mitsubishi Electric MELSEC Q series Q03/04/06/13/26UDVCPU; Mitsubishi Electric MELSEC Q series Q04/06/13/26UDPVCPU; Mitsubishi Electric MELSEC Q series QJ71C24N(-R2/R4); Mitsubishi Electric MELSEC Q series QJ71E71-100 Mitsubishi Electric MELSEC iQ-R series RJ72GF15-T2 all versions,"Utilize some sequence or time stamping functionality along with a checksum which takes this into account in order to ensure that messages can be parsed only once.; Since any attacker who can listen to traffic can see sequence numbers, it is necessary to sign messages with some kind of cryptography to ensure that sequence numbers are not simply doctored along with content.",Security Bypass,High,Security Bypass,Privilege Escalation,
CVE-2023-20256,"Multiple vulnerabilities in the per-user-override feature of Cisco Adaptive Security Appliance (ASA) Software and Cisco Firepower Threat Defense (FTD) Software could allow an unauthenticated, remote attacker to bypass a configured access control list (ACL) and allow traffic that should be denied to flow through an affected device. These vulnerabilities are due to a logic error that could occur when the affected software constructs and applies per-user-override rules. An attacker could exploit these vulnerabilities by connecting to a network through an affected device that has a vulnerable configuration. A successful exploit could allow the attacker to bypass the interface ACL and access resources that would should be protected.",,,0,0,0,0,,,,,,,CWE-290,Authentication Bypass by Spoofing,Base,,Cisco,Cisco Adaptive Security Appliance (ASA) Software,9.18.2.7,,,,,,5,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:L/A:N,N,L,L,N,C,N,L,N,304,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-ac-acl-bypass-bwd7q6Gb|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-ac-acl-bypass-bwd7q6Gb|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-ac-acl-bypass-bwd7q6Gb,||,0,0,Cisco/Cisco Adaptive Security Appliance (ASA) Software 9.18.2.7,Cisco/Cisco Adaptive Security Appliance (ASA) Software 9.18.2.7,,Security Bypass,Medium,Security Bypass,Information Disclosure,
CVE-2023-20269,"A vulnerability in the remote access VPN feature of Cisco Adaptive Security Appliance (ASA) Software and Cisco Firepower Threat Defense (FTD) Software could allow an unauthenticated, remote attacker to conduct a brute force attack in an attempt to identify valid username and password combinations or an authenticated, remote attacker to establish a clientless SSL VPN session with an unauthorized user.
 This vulnerability is due to improper separation of authentication, authorization, and accounting (AAA) between the remote access VPN feature and the HTTPS management and site-to-site VPN features. An attacker could exploit this vulnerability by specifying a default connection profile/tunnel group while conducting a brute force attack or while establishing a clientless SSL VPN session using valid credentials. A successful exploit could allow the attacker to achieve one or both of the following:
  Identify valid credentials that could then be used to establish an unauthorized remote access VPN session. Establish a clientless SSL VPN session (only when running Cisco ASA Software Release 9.16 or earlier).  Notes:
  Establishing a client-based remote access VPN tunnel is not possible as these default connection profiles/tunnel groups do not and cannot have an IP address pool configured. This vulnerability does not allow an attacker to bypass authentication. To successfully establish a remote access VPN session, valid credentials are required, including a valid second factor if multi-factor authentication (MFA) is configured.  Cisco will release software updates that address this vulnerability. There are workarounds that address this vulnerability.",,,0,0,0,0,,,,,,,CWE-288,Authentication Bypass Using an Alternate Path or Channel,Base,"Funnel all access through a single choke point to simplify how users can access a resource. For every access, perform a check to determine if the user has permissions to access the resource.",Cisco,Cisco Firepower Threat Defense Software,6.2.3.11,,,,,,5,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:L/A:N,N,L,L,N,C,N,L,N,984,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-ravpn-auth-8LyfCkeC|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-ravpn-auth-8LyfCkeC|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-ravpn-auth-8LyfCkeC,||,0,0,Cisco/Cisco Firepower Threat Defense Software 6.2.3.11,Cisco/Cisco Firepower Threat Defense Software 6.2.3.11,"Funnel all access through a single choke point to simplify how users can access a resource. For every access, perform a check to determine if the user has permissions to access the resource.",Security Bypass,Medium,Security Bypass,Remote Code Execution,
CVE-2021-26857,,,,0,0,0,0,,,,,,,CWE-502,Deserialization of Untrusted Data,Base,"If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.; When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.; Explicitly define a final object() to prevent deserialization.; Make fields transient to protect them from deserialization.
                  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.; Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.; Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed.",Microsoft,Other_Product,15.00.0,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H/E:F/RL:O/RC:C,L,L,N,R,U,H,H,H,30,3,https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-26857|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-26857|https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2021-26857,||,0,0,Microsoft/Microsoft Exchange Server 2013 Service Pack 1 15.00.0,Microsoft/Microsoft Exchange Server 2013 Service Pack 1 15.00.0,"If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.; When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.; Explicitly define a final object() to prevent deserialization.; Make fields transient to protect them from deserialization.
                  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.; Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.; Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed.",Deserialization of Untrusted Data,High,Deserialization of Untrusted Data,Denial of Service (DoS),
CVE-2023-30899,"A vulnerability has been identified in Siveillance Video 2020 R2 (All versions < V20.2 HotfixRev14), Siveillance Video 2020 R3 (All versions < V20.3 HotfixRev12), Siveillance Video 2021 R1 (All versions < V21.1 HotfixRev12), Siveillance Video 2021 R2 (All versions < V21.2 HotfixRev8), Siveillance Video 2022 R1 (All versions < V22.1 HotfixRev7), Siveillance Video 2022 R2 (All versions < V22.2 HotfixRev5), Siveillance Video 2022 R3 (All versions < V22.3 HotfixRev2), Siveillance Video 2023 R1 (All versions < V23.1 HotfixRev1). The Management Server component of affected applications deserializes data without sufficient validations. This could allow an authenticated remote attacker to execute code on the affected system.",,,0,0,0,0,,,,,,,CWE-502,Deserialization of Untrusted Data,Base,"If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.; When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.; Explicitly define a final object() to prevent deserialization.; Make fields transient to protect them from deserialization.
                  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.; Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.; Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed.",siemens,Other_Product,2020,,,,,,9.9,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H/E:P/RL:O/RC:C,N,L,L,N,C,H,H,H,12,3,https://cert-portal.siemens.com/productcert/pdf/ssa-789345.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-789345.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-789345.pdf,||,0,0,siemens/siveillance_video 2020,siemens/siveillance_video 2020,"If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.; When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.; Explicitly define a final object() to prevent deserialization.; Make fields transient to protect them from deserialization.
                  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.; Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.; Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed.",Deserialization of Untrusted Data,Critical,Deserialization of Untrusted Data,Privilege Escalation,
CVE-2021-21956,A php unserialize vulnerability exists in the Ai-Bolit functionality of CloudLinux Inc Imunify360 5.10.2. A specially-crafted malformed file can lead to potential arbitrary command execution. An attacker can provide a malicious file to trigger this vulnerability.,,,0,0,0,0,,,,,,,CWE-502,Deserialization of Untrusted Data,Base,"If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.; When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.; Explicitly define a final object() to prevent deserialization.; Make fields transient to protect them from deserialization.
                  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.; Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.; Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed.",Other_Vendor,Other_Product,5.9,,,,,,8.2,,,CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:N,N,H,L,N,C,H,H,N,5,3,https://talosintelligence.com/vulnerability_reports/TALOS-2021-1383|https://talosintelligence.com/vulnerability_reports/TALOS-2021-1383|https://talosintelligence.com/vulnerability_reports/TALOS-2021-1383,||,0,0,CloudLinux Inc/Imunify360 5.9,CloudLinux Inc/Imunify360 5.9,"If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.; When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.; Explicitly define a final object() to prevent deserialization.; Make fields transient to protect them from deserialization.
                  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.; Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.; Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed.",Deserialization of Untrusted Data,High,Deserialization of Untrusted Data,Information Disclosure,
CVE-2024-22369,"Deserialization of Untrusted Data vulnerability in Apache Camel SQL ComponentThis issue affects Apache Camel: from 3.0.0 before 3.21.4, from 3.22.0 before 3.22.1, from 4.0.0 before 4.0.4, from 4.1.0 before 4.4.0.

Users are recommended to upgrade to version 4.4.0, which fixes the issue. If users are on the 4.0.x LTS releases stream, then they are suggested to upgrade to 4.0.4. If users are on 3.x, they are suggested to move to 3.21.4 or 3.22.1

",,,0,0,0,0,,,,,,,CWE-502,Deserialization of Untrusted Data,Base,"If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.; When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.; Explicitly define a final object() to prevent deserialization.; Make fields transient to protect them from deserialization.
                  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.; Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.; Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed.",Apache Software Foundation,Other_Product,4.0.0,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,L,L,N,R,U,H,H,H,6,3,https://lists.apache.org/thread/3dko781dy2gy5l3fs48p56fgp429yb0f|https://lists.apache.org/thread/3dko781dy2gy5l3fs48p56fgp429yb0f|https://lists.apache.org/thread/3dko781dy2gy5l3fs48p56fgp429yb0f,||,0,0,Apache Software Foundation/Apache Camel 4.0.0,Apache Software Foundation/Apache Camel 4.0.0,"If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.; When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.; Explicitly define a final object() to prevent deserialization.; Make fields transient to protect them from deserialization.
                  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.; Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.; Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed.",Deserialization of Untrusted Data,High,Deserialization of Untrusted Data,Remote Code Execution,
CVE-2023-21710,,,,0,0,0,0,,,,,,,CWE-502,Deserialization of Untrusted Data,Base,"If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.; When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.; Explicitly define a final object() to prevent deserialization.; Make fields transient to protect them from deserialization.
                  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.; Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.; Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed.",Microsoft,Other_Product,15.02.0,,,,,,7.2,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,N,L,H,N,U,H,H,H,5,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-21710|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-21710|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-21710,||,0,0,Microsoft/Microsoft Exchange Server 2019 Cumulative Update 11 15.02.0,Microsoft/Microsoft Exchange Server 2019 Cumulative Update 11 15.02.0,"If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.; When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe.; Explicitly define a final object() to prevent deserialization.; Make fields transient to protect them from deserialization.
                  An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly.; Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note: new gadgets are constantly being discovered, so this alone is not a sufficient mitigation.; Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed.",Deserialization of Untrusted Data,High,Deserialization of Untrusted Data,Denial of Service (DoS),
CVE-2022-22212,An Allocation of Resources Without Limits or Throttling vulnerability in the Packet Forwarding Engine (PFE) of Juniper Networks Junos OS Evolved allows unauthenticated network based attacker to cause a Denial of Service (DoS). On all Junos Evolved platforms hostbound protocols will be impacted by a high rate of specific hostbound traffic from ports on a PFE. Continued receipt of this amount of traffic will create a sustained Denial of Service (DoS) condition. This issue affects Juniper Networks Junos OS Evolved: 21.2 versions prior to 21.2R3-EVO; 21.3 versions prior to 21.3R2-EVO. This issue does not affect Juniper Networks Junos OS Evolved versions prior to 21.2R1.,,,0,0,0,0,,,,,,,CWE-770,Allocation of Resources Without Limits or Throttling,Base,"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.; Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.; Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.
                  Ensure that all failures in resource allocation place the system into a safe posture.; Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.
                  When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.
                  Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).",juniper,Other_Product,21.2,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,5,3,https://kb.juniper.net/JSA69716|https://kb.juniper.net/JSA69716|https://kb.juniper.net/JSA69716,||,0,0,juniper/junos_os_evolved 21.2,juniper/junos_os_evolved 21.2,"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.; Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.; Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.
                  Ensure that all failures in resource allocation place the system into a safe posture.; Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.
                  When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.
                  Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).",Resource Allocation,High,Resource Allocation,Privilege Escalation,
CVE-2022-41725,"A denial of service is possible from excessive resource consumption in net/http and mime/multipart. Multipart form parsing with mime/multipart.Reader.ReadForm can consume largely unlimited amounts of memory and disk files. This also affects form parsing in the net/http package with the Request methods FormFile, FormValue, ParseMultipartForm, and PostFormValue. ReadForm takes a maxMemory parameter, and is documented as storing ""up to maxMemory bytes +10MB (reserved for non-file parts) in memory"". File parts which cannot be stored in memory are stored on disk in temporary files. The unconfigurable 10MB reserved for non-file parts is excessively large and can potentially open a denial of service vector on its own. However, ReadForm did not properly account for all memory consumed by a parsed form, such as map entry overhead, part names, and MIME headers, permitting a maliciously crafted form to consume well over 10MB. In addition, ReadForm contained no limit on the number of disk files created, permitting a relatively small request body to create a large number of disk temporary files. With fix, ReadForm now properly accounts for various forms of memory overhead, and should now stay within its documented limit of 10MB + maxMemory bytes of memory consumption. Users should still be aware that this limit is high and may still be hazardous. In addition, ReadForm now creates at most one on-disk temporary file, combining multiple form parts into a single temporary file. The mime/multipart.File interface type's documentation states, ""If stored on disk, the File's underlying concrete type will be an *os.File."". This is no longer the case when a form contains more than one file part, due to this coalescing of parts into a single file. The previous behavior of using distinct files for each form part may be reenabled with the environment variable GODEBUG=multipartfiles=distinct. Users should be aware that multipart.ReadForm and the http.Request methods that call it do not limit the amount of disk consumed by temporary files. Callers can limit the size of form data with http.MaxBytesReader.",,,0,0,0,0,,,,,,,CWE-770,Allocation of Resources Without Limits or Throttling,Base,"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.; Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.; Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.
                  Ensure that all failures in resource allocation place the system into a safe posture.; Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.
                  When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.
                  Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).",Other_Vendor,Other_Product,0,,,,,,7.5,3.9,3.6,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,4,15,https://go.dev/cl/468124|https://go.dev/cl/468124|https://go.dev/issue/58006|https://go.dev/issue/58006|https://groups.google.com/g/golang-announce/c/V0aBFqaFs_E|https://groups.google.com/g/golang-announce/c/V0aBFqaFs_E|https://pkg.go.dev/vuln/GO-2023-1569|https://pkg.go.dev/vuln/GO-2023-1569|https://security.gentoo.org/glsa/202311-09|https://security.gentoo.org/glsa/202311-09|https://go.dev/issue/58006|https://go.dev/cl/468124|https://groups.google.com/g/golang-announce/c/V0aBFqaFs_E|https://pkg.go.dev/vuln/GO-2023-1569|https://security.gentoo.org/glsa/202311-09,||||||||||||||,0,0,Go standard library/mime/multipart 0,Go standard library/mime/multipart 0,"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.; Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.; Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.
                  Ensure that all failures in resource allocation place the system into a safe posture.; Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.
                  When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.
                  Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).",Resource Allocation,High,Resource Allocation,Information Disclosure,
CVE-2021-3669,A flaw was found in the Linux kernel. Measuring usage of the shared memory does not scale with large shared memory segment counts which could lead to resource exhaustion and DoS.,,,0,0,0,0,,,,,,,CWE-770,Allocation of Resources Without Limits or Throttling,Base,"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.; Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.; Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.
                  Ensure that all failures in resource allocation place the system into a safe posture.; Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.
                  When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.
                  Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).",redhat,Other_Product,8.6,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,44,12,https://access.redhat.com/security/cve/CVE-2021-3669|https://access.redhat.com/security/cve/CVE-2021-3669|https://bugzilla.redhat.com/show_bug.cgi?id=1980619|https://bugzilla.redhat.com/show_bug.cgi?id=1980619|https://bugzilla.redhat.com/show_bug.cgi?id=1986473|https://bugzilla.redhat.com/show_bug.cgi?id=1986473|https://security-tracker.debian.org/tracker/CVE-2021-3669|https://security-tracker.debian.org/tracker/CVE-2021-3669|https://bugzilla.redhat.com/show_bug.cgi?id=1986473|https://bugzilla.redhat.com/show_bug.cgi?id=1980619|https://access.redhat.com/security/cve/CVE-2021-3669|https://security-tracker.debian.org/tracker/CVE-2021-3669,|||||||||||,0,0,redhat/enterprise_linux_server_aus 8.6,redhat/enterprise_linux_server_aus 8.6,"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.; Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.; Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.
                  Ensure that all failures in resource allocation place the system into a safe posture.; Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.
                  When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.
                  Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).",Resource Allocation,Medium,Resource Allocation,Remote Code Execution,
CVE-2023-20033,"A vulnerability in Cisco IOS XE Software for Cisco Catalyst 3650 and Catalyst 3850 Series Switches could allow an unauthenticated, remote attacker to cause an affected device to reload unexpectedly, resulting in a denial of service (DoS) condition.
 This vulnerability is due to improper resource management when processing traffic that is received on the management interface. An attacker could exploit this vulnerability by sending a high rate of traffic to the management interface. A successful exploit could allow the attacker to cause the device to reload, resulting in a DoS condition.",,,0,0,0,0,,,,,,,CWE-770,Allocation of Resources Without Limits or Throttling,Base,"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.; Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.; Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.
                  Ensure that all failures in resource allocation place the system into a safe posture.; Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.
                  When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.
                  Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).",Cisco,Cisco IOS XE Software,16.12.3,,,,,,8.6,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H,N,L,N,N,C,N,N,H,58,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-cat3k-dos-ZZA4Gb3r|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-cat3k-dos-ZZA4Gb3r|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-cat3k-dos-ZZA4Gb3r,||,0,0,Cisco/Cisco IOS XE Software 16.12.3,Cisco/Cisco IOS XE Software 16.12.3,"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.; Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.; Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.
                  Ensure that all failures in resource allocation place the system into a safe posture.; Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.
                  When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.
                  Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).",Resource Allocation,High,Resource Allocation,Denial of Service (DoS),
CVE-2021-44502,"An issue was discovered in FIS GT.M through V7.0-000 (related to the YottaDB code base). Using crafted input, an attacker can control the size of a memset that occurs in calls to util_format in sr_unix/util_output.c.",,,0,0,0,0,,,,,,,CWE-770,Allocation of Resources Without Limits or Throttling,Base,"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.; Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.; Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.
                  Ensure that all failures in resource allocation place the system into a safe posture.; Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.
                  When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.
                  Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).",Other_Vendor,Other_Product,*,,,,,,7.5,3.9,3.6,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,2,9,http://tinco.pair.com/bhaskar/gtm/doc/articles/GTM_V7.0-002_Release_Notes.html|http://tinco.pair.com/bhaskar/gtm/doc/articles/GTM_V7.0-002_Release_Notes.html|https://gitlab.com/YottaDB/DB/YDB/-/issues/828|https://gitlab.com/YottaDB/DB/YDB/-/issues/828|https://sourceforge.net/projects/fis-gtm/files/|https://sourceforge.net/projects/fis-gtm/files/|https://sourceforge.net/projects/fis-gtm/files/|https://gitlab.com/YottaDB/DB/YDB/-/issues/828|http://tinco.pair.com/bhaskar/gtm/doc/articles/GTM_V7.0-002_Release_Notes.html,||||||||,0,0,fisglobal/gt.m *,fisglobal/gt.m *,"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.; Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.; Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.; Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.; For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.; Mitigation of resource exhaustion attacks requires that the target system either:
                     
                        recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays
                        uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.
                     
                  The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.
                  The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.; Ensure that protocols have specific limits of scale placed on them.; If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.
                  Ensure that all failures in resource allocation place the system into a safe posture.; Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.
                  When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.
                  Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).",Resource Allocation,High,Resource Allocation,Privilege Escalation,
CVE-2023-35342,,,,0,0,0,0,,,,,,,CWE-59,Improper Link Resolution Before File Access ('Link Following'),Base,"Follow the principle of least privilege when assigning access rights to entities in a software system.
                  Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.",Microsoft,Windows Server 2022,10.0.20348.0,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,L,L,L,N,U,H,H,H,32,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-35342|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-35342|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-35342,||,0,0,Microsoft/Windows Server 2022 10.0.20348.0,Microsoft/Windows Server 2022 10.0.20348.0,"Follow the principle of least privilege when assigning access rights to entities in a software system.
                  Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.",Link Following,High,Link Following,Information Disclosure,
CVE-2024-26216,,,,0,0,0,0,,,,,,,CWE-59,Improper Link Resolution Before File Access ('Link Following'),Base,"Follow the principle of least privilege when assigning access rights to entities in a software system.
                  Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.",Microsoft,Windows Server 2008 R2 Service Pack 1,6.1.7601.0,,,,,,7.3,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,L,L,L,R,U,H,H,H,23,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-26216|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-26216|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-26216,||,0,0,Microsoft/Windows Server 2008 R2 Service Pack 1 6.1.7601.0,Microsoft/Windows Server 2008 R2 Service Pack 1 6.1.7601.0,"Follow the principle of least privilege when assigning access rights to entities in a software system.
                  Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.",Link Following,High,Link Following,Remote Code Execution,
CVE-2023-20008,"A vulnerability in the CLI of Cisco TelePresence CE and RoomOS Software could allow an authenticated, local attacker to overwrite arbitrary files on the local system of an affected device.
 This vulnerability is due to improper access controls on files that are in the local file system. An attacker could exploit this vulnerability by placing a symbolic link in a specific location on the local file system of an affected device. A successful exploit could allow the attacker to overwrite arbitrary files on the affected device.",,,0,0,0,0,,,,,,,CWE-59,Improper Link Resolution Before File Access ('Link Following'),Base,"Follow the principle of least privilege when assigning access rights to entities in a software system.
                  Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.",cisco,Other_Product,9.12.4,,,,,,4.4,,,CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:N,L,L,H,N,U,N,H,N,111,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-roomos-dkjGFgRK|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-roomos-dkjGFgRK|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-roomos-dkjGFgRK,||,0,0,cisco/telepresence_collaboration_endpoint 9.12.4,cisco/telepresence_collaboration_endpoint 9.12.4,"Follow the principle of least privilege when assigning access rights to entities in a software system.
                  Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.",Link Following,Medium,Link Following,Denial of Service (DoS),
CVE-2023-29351,,,,0,0,0,0,,,,,,,CWE-59,Improper Link Resolution Before File Access ('Link Following'),Base,"Follow the principle of least privilege when assigning access rights to entities in a software system.
                  Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.",Microsoft,Windows Server 2016 (Server Core installation),10.0.14393.0,,,,,,8.1,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H/E:U/RL:O/RC:C,N,L,L,N,U,N,H,H,36,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-29351|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-29351|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-29351,||,0,0,Microsoft/Windows Server 2016 (Server Core installation) 10.0.14393.0,Microsoft/Windows Server 2016 (Server Core installation) 10.0.14393.0,"Follow the principle of least privilege when assigning access rights to entities in a software system.
                  Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.",Link Following,High,Link Following,Privilege Escalation,
CVE-2024-5742,"A vulnerability was found in GNU Nano that allows a possible privilege escalation through an insecure temporary file. If Nano is killed while editing, a file it saves to an emergency file with the permissions of the running user provides a window of opportunity for attackers to escalate privileges through a malicious symlink.",,,0,0,0,0,,,,,,,CWE-59,Improper Link Resolution Before File Access ('Link Following'),Base,"Follow the principle of least privilege when assigning access rights to entities in a software system.
                  Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.",Red Hat,Other_Product,0:5.6.1-6.el9,,,,,,6.7,,,CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H,L,H,L,R,U,H,H,H,7,11,https://access.redhat.com/errata/RHSA-2024:6986|https://access.redhat.com/errata/RHSA-2024:9430|https://access.redhat.com/security/cve/CVE-2024-5742|https://access.redhat.com/security/cve/CVE-2024-5742|https://bugzilla.redhat.com/show_bug.cgi?id=2278574|https://bugzilla.redhat.com/show_bug.cgi?id=2278574|https://lists.debian.org/debian-lts-announce/2024/06/msg00006.html|https://access.redhat.com/errata/RHSA-2024:6986|https://access.redhat.com/errata/RHSA-2024:9430|https://access.redhat.com/security/cve/CVE-2024-5742|https://bugzilla.redhat.com/show_bug.cgi?id=2278574,||||||||||,0,0,Red Hat/Red Hat Enterprise Linux 9 0:5.6.1-6.el9,Red Hat/Red Hat Enterprise Linux 9 0:5.6.1-6.el9,"Follow the principle of least privilege when assigning access rights to entities in a software system.
                  Denying access to a file can prevent an attacker from replacing that file with a link to a sensitive file. Ensure good compartmentalization in the system to provide protected areas that can be trusted.",Link Following,Medium,Link Following,Information Disclosure,
CVE-2022-28390,ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel through 5.17.1 has a double free.,,,0,0,0,0,,,,,,,CWE-415,Double Free,Variant,"Choose a language that provides automatic memory management.; Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.; Use a static analysis tool to find double free instances.",netapp,Other_Product,h500s,,,,,,7.8,1.8,5.9,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,16,24,https://github.com/torvalds/linux/commit/c70222752228a62135cee3409dccefd494a24646|https://github.com/torvalds/linux/commit/c70222752228a62135cee3409dccefd494a24646|https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html|https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6IHHC455LMSJNG4CSZ5CEAHYWY2DE5YW/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6IHHC455LMSJNG4CSZ5CEAHYWY2DE5YW/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LAWC35TO642FOP3UCA3C6IF7NAUFOVZ6/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LAWC35TO642FOP3UCA3C6IF7NAUFOVZ6/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XFMPUI3WI4U2F7ONHRW36WDY4ZE7LGGT/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XFMPUI3WI4U2F7ONHRW36WDY4ZE7LGGT/|https://security.netapp.com/advisory/ntap-20220513-0001/|https://security.netapp.com/advisory/ntap-20220513-0001/|https://www.debian.org/security/2022/dsa-5127|https://www.debian.org/security/2022/dsa-5127|https://www.debian.org/security/2022/dsa-5173|https://www.debian.org/security/2022/dsa-5173|https://github.com/torvalds/linux/commit/c70222752228a62135cee3409dccefd494a24646|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LAWC35TO642FOP3UCA3C6IF7NAUFOVZ6/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/XFMPUI3WI4U2F7ONHRW36WDY4ZE7LGGT/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/6IHHC455LMSJNG4CSZ5CEAHYWY2DE5YW/|https://www.debian.org/security/2022/dsa-5127|https://security.netapp.com/advisory/ntap-20220513-0001/|https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html|https://www.debian.org/security/2022/dsa-5173,|||||||||||||||||||||||,0,0,netapp/hci_baseboard_management_controller h500s,netapp/hci_baseboard_management_controller h500s,"Choose a language that provides automatic memory management.; Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.; Use a static analysis tool to find double free instances.",Double Free,High,Double Free,Remote Code Execution,
CVE-2023-21629,Memory Corruption in Modem due to double free while parsing the PKCS15 sim files.,,,0,0,0,0,,,,,,,CWE-415,Double Free,Variant,"Choose a language that provides automatic memory management.; Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.; Use a static analysis tool to find double free instances.","Qualcomm, Inc.",Snapdragon,QCA6574AU,,,,,,6.8,,,CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,P,L,N,N,U,H,H,H,212,3,https://www.qualcomm.com/company/product-security/bulletins/july-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/july-2023-bulletin|https://www.qualcomm.com/company/product-security/bulletins/july-2023-bulletin,||,0,0,"Qualcomm, Inc./Snapdragon QCA6574AU","Qualcomm, Inc./Snapdragon QCA6574AU","Choose a language that provides automatic memory management.; Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.; Use a static analysis tool to find double free instances.",Double Free,Medium,Double Free,Denial of Service (DoS),
CVE-2024-21461,Memory corruption while performing finish HMAC operation when context is freed by keymaster.,,,0,0,0,0,,,,,,,CWE-415,Double Free,Variant,"Choose a language that provides automatic memory management.; Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.; Use a static analysis tool to find double free instances.","Qualcomm, Inc.",Snapdragon,Snapdragon 778G 5G Mobile Platform,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,L,L,N,N,U,H,H,H,308,3,https://docs.qualcomm.com/product/publicresources/securitybulletin/july-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/july-2024-bulletin.html|https://docs.qualcomm.com/product/publicresources/securitybulletin/july-2024-bulletin.html,||,0,0,"Qualcomm, Inc./Snapdragon Snapdragon 778G 5G Mobile Platform","Qualcomm, Inc./Snapdragon Snapdragon 778G 5G Mobile Platform","Choose a language that provides automatic memory management.; Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.; Use a static analysis tool to find double free instances.",Double Free,High,Double Free,Privilege Escalation,
CVE-2022-49203,"In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix double free during GPU reset on DC streams

[Why]
The issue only occurs during the GPU reset code path.

We first backup the current state prior to commiting 0 streams
internally from DM to DC. This state backup contains valid link
encoder assignments.

DC will clear the link encoder assignments as part of current state
(but not the backup, since it was a copied before the commit) and
free the extra stream reference it held.

DC requires that the link encoder assignments remain cleared/invalid
prior to commiting. Since the backup still has valid assignments we
call the interface post reset to clear them. This routine also
releases the extra reference that the link encoder interface held -
resulting in a double free (and eventually a NULL pointer dereference).

[How]
We'll have to do a full DC commit anyway after GPU reset because
the stream count previously went to 0.

We don't need to retain the assignment that we had backed up, so
just copy off of the now clean current state assignment after the
reset has occcurred with the new link_enc_cfg_copy() interface.",,,0,0,0,0,,,,,,,CWE-415,Double Free,Variant,"Choose a language that provides automatic memory management.; Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.; Use a static analysis tool to find double free instances.",Linux,Linux,5.18,,,,,,5.5,1.8,3.6,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,L,L,L,N,U,N,N,H,6,4,https://git.kernel.org/stable/c/32685b32d825ca08c5dec826477332df886c4743|https://git.kernel.org/stable/c/bbfcdd6289ba6f00f0cd7d496946dce9f6c600ac|https://git.kernel.org/stable/c/bbfcdd6289ba6f00f0cd7d496946dce9f6c600ac|https://git.kernel.org/stable/c/32685b32d825ca08c5dec826477332df886c4743,|||,0,0,Linux/Linux 5.18,Linux/Linux 5.18,"Choose a language that provides automatic memory management.; Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.; Use a static analysis tool to find double free instances.",Double Free,Medium,Double Free,Information Disclosure,
CVE-2024-27433,"In the Linux kernel, the following vulnerability has been resolved:

clk: mediatek: mt7622-apmixedsys: Fix an error handling path in clk_mt8135_apmixed_probe()

'clk_data' is allocated with mtk_devm_alloc_clk_data(). So calling
mtk_free_clk_data() explicitly in the remove function would lead to a
double-free.

Remove the redundant call.",,,0,0,0,0,,,,,,,CWE-415,Double Free,Variant,"Choose a language that provides automatic memory management.; Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.; Use a static analysis tool to find double free instances.",Linux,Linux,6.4,,,,,,7.8,1.8,5.9,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,8,12,https://git.kernel.org/stable/c/a32e88f2b20259f5fe4f8eed598bbc85dc4879ed|https://git.kernel.org/stable/c/a32e88f2b20259f5fe4f8eed598bbc85dc4879ed|https://git.kernel.org/stable/c/de3340533bd68a7b3d6be1841b8eb3fa6c762fe6|https://git.kernel.org/stable/c/de3340533bd68a7b3d6be1841b8eb3fa6c762fe6|https://git.kernel.org/stable/c/f3633fed984f1db106ff737a0bb52fadb2d89ac7|https://git.kernel.org/stable/c/f3633fed984f1db106ff737a0bb52fadb2d89ac7|https://git.kernel.org/stable/c/fa761ce7a1d15cca1a306b3635f81a22b15fee5b|https://git.kernel.org/stable/c/fa761ce7a1d15cca1a306b3635f81a22b15fee5b|https://git.kernel.org/stable/c/de3340533bd68a7b3d6be1841b8eb3fa6c762fe6|https://git.kernel.org/stable/c/f3633fed984f1db106ff737a0bb52fadb2d89ac7|https://git.kernel.org/stable/c/fa761ce7a1d15cca1a306b3635f81a22b15fee5b|https://git.kernel.org/stable/c/a32e88f2b20259f5fe4f8eed598bbc85dc4879ed,|||||||||||,0,0,Linux/Linux 6.4,Linux/Linux 6.4,"Choose a language that provides automatic memory management.; Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.; Use a static analysis tool to find double free instances.",Double Free,High,Double Free,Remote Code Execution,
CVE-2022-45859,"An insufficiently protected credentials vulnerability [CWE-522] in FortiNAC-F 7.2.0, FortiNAC 9.4.1 and below, 9.2.6 and below, 9.1.8 and below, 8.8.0 all versions, 8.7.0 all versions may allow a local attacker with system access to retrieve users' passwords.",,,0,0,0,0,,,,,,,CWE-522,Insufficiently Protected Credentials,Class,"Use an appropriate security mechanism to protect the credentials.; Make appropriate use of cryptography to protect the credentials.; Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.).",Fortinet,Other_Product,9.1.0,,,,,,3.9,,,CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N/E:F/RL:X/RC:R,L,H,H,N,U,H,N,N,7,3,https://fortiguard.com/psirt/FG-IR-22-456|https://fortiguard.com/psirt/FG-IR-22-456|https://fortiguard.com/psirt/FG-IR-22-456,||,0,0,Fortinet/FortiNAC 9.1.0,Fortinet/FortiNAC 9.1.0,"Use an appropriate security mechanism to protect the credentials.; Make appropriate use of cryptography to protect the credentials.; Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.).",Weak Credentials,Low,Weak Credentials,Denial of Service (DoS),
CVE-2023-0457,"Plaintext Storage of a Password vulnerability in Mitsubishi Electric Corporation MELSEC iQ-F Series, MELSEC iQ-R Series, MELSEC-Q Series and MELSEC-L Series allows a remote unauthenticated attacker to disclose plaintext credentials stored in project files and login into FTP server or Web server.",,,0,0,0,0,,,,,,,CWE-522,Insufficiently Protected Credentials,Class,"Use an appropriate security mechanism to protect the credentials.; Make appropriate use of cryptography to protect the credentials.; Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.).",Mitsubishi Electric Corporation,Other_Product,all versions,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,N,L,N,N,U,H,N,N,222,9,https://jvn.jp/vu/JVNVU93891523/index.html|https://jvn.jp/vu/JVNVU93891523/index.html|https://www.cisa.gov/news-events/ics-advisories/icsa-23-061-01|https://www.cisa.gov/news-events/ics-advisories/icsa-23-061-01|https://www.mitsubishielectric.com/en/psirt/vulnerability/pdf/2022-023_en.pdf|https://www.mitsubishielectric.com/en/psirt/vulnerability/pdf/2022-023_en.pdf|https://www.mitsubishielectric.com/en/psirt/vulnerability/pdf/2022-023_en.pdf|https://jvn.jp/vu/JVNVU93891523/index.html|https://www.cisa.gov/news-events/ics-advisories/icsa-23-061-01,||||||||,0,0,Mitsubishi Electric Corporation/MELSEC-Q Series Q10UDEHCPU all versions,Mitsubishi Electric Corporation/MELSEC-Q Series Q10UDEHCPU all versions,"Use an appropriate security mechanism to protect the credentials.; Make appropriate use of cryptography to protect the credentials.; Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.).",Weak Credentials,High,Weak Credentials,Privilege Escalation,
CVE-2024-39290,Insufficiently protected credentials issue exists in AIPHONE IX SYSTEM and IXG SYSTEM. A network-adjacent unauthenticated attacker may obtain sensitive information such as a username and its password in the address book.,,,0,0,0,0,,,,,,,CWE-522,Insufficiently Protected Credentials,Class,"Use an appropriate security mechanism to protect the credentials.; Make appropriate use of cryptography to protect the credentials.; Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.).",Other_Vendor,Other_Product,firmware Ver.3.00 and earlier,,,,,,6.5,,,CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,A,L,N,N,U,H,N,N,54,10,https://jvn.jp/en/jp/JVN41397971/|https://www.aiphone.net/important/20241016_1/|https://www.aiphone.net/important/20241016_2/|https://www.aiphone.net/support/software-documents/ix/|https://www.aiphone.net/support/software-documents/ixg/|https://www.aiphone.net/important/20241016_1/|https://www.aiphone.net/important/20241016_2/|https://www.aiphone.net/support/software-documents/ix/|https://www.aiphone.net/support/software-documents/ixg/|https://jvn.jp/en/jp/JVN41397971/,|||||||||,0,0,"AIPHONE CO., LTD./IXG-DM7-HIDA firmware Ver.3.00 and earlier","AIPHONE CO., LTD./IXG-DM7-HIDA firmware Ver.3.00 and earlier","Use an appropriate security mechanism to protect the credentials.; Make appropriate use of cryptography to protect the credentials.; Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.).",Weak Credentials,Medium,Weak Credentials,Information Disclosure,
CVE-2023-20046,"A vulnerability in the key-based SSH authentication feature of Cisco StarOS Software could allow an authenticated, remote attacker to elevate privileges on an affected device.
 This vulnerability is due to insufficient validation of user-supplied credentials. An attacker could exploit this vulnerability by sending a valid low-privileged SSH key to an affected device from a host that has an IP address that is configured as the source for a high-privileged user account. A successful exploit could allow the attacker to log in to the affected device through SSH as a high-privileged user.
   There are workarounds that address this vulnerability.",,,0,0,0,0,,,,,,,CWE-522,Insufficiently Protected Credentials,Class,"Use an appropriate security mechanism to protect the credentials.; Make appropriate use of cryptography to protect the credentials.; Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.).",Cisco,Cisco ASR 5000 Series Software,21.21.KS2,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,N,L,L,N,U,H,H,H,810,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-staros-ssh-privesc-BmWeJC3h|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-staros-ssh-privesc-BmWeJC3h|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-staros-ssh-privesc-BmWeJC3h,||,0,0,Cisco/Cisco ASR 5000 Series Software 21.21.KS2,Cisco/Cisco ASR 5000 Series Software 21.21.KS2,"Use an appropriate security mechanism to protect the credentials.; Make appropriate use of cryptography to protect the credentials.; Use industry standards to protect the credentials (e.g. LDAP, keystore, etc.).",Weak Credentials,High,Weak Credentials,Remote Code Execution,
CVE-2023-0564,"Weak Password Requirements in GitHub repository froxlor/froxlor prior to 2.0.10.

",,,0,0,0,0,,,,,,,CWE-521,Weak Password Requirements,Base,"A product's design should require adherance to an appropriate password policy. Specific password requirements depend strongly on contextual factors, but it is recommended to contain the following attributes:
                 
                   Enforcement of a minimum and maximum length
                   Restrictions against password reuse
                   Restrictions against using common passwords
                   Restrictions against using contextual string in the password (e.g., user id, app name)
                 
                 Depending on the threat model, the password policy may include several additional attributes.
                 
                   Complex passwords requiring mixed character sets (alpha, numeric, special, mixed case)
                     
                       Increasing the range of characters makes the password harder to crack and may be appropriate for systems relying on single factor authentication.
                       Unfortunately, a complex password may be difficult to memorize, encouraging a user to select a short password or to incorrectly manage the password (write it down).
                       Another disadvantage of this approach is that it often does not result in a significant increases in overal password complexity due to people's predictable usage of various symbols.
                     
                   
                   Large Minimum Length (encouraging passphrases instead of passwords)
                     
                       Increasing the number of characters makes the password harder to crack and may be appropriate for systems relying on single factor authentication.
                       A disadvantage of this approach is that selecting a good passphrase is not easy and poor passwords can still be generated. Some prompting may be needed to encourage long un-predictable passwords.
                     
                   
                   Randomly Chosen Secrets
                     
                       Generating a password for the user can help make sure that length and complexity requirements are met, and can result in secure passwords being used.
                       A disadvantage of this approach is that the resulting password or passpharse may be too difficult to memorize, encouraging them to be written down.
                     
                   
                   Password Expiration
                     
                       Requiring a periodic password change can reduce the time window that an adversary has to crack a password, while also limiting the damage caused by password exposures at other locations.
					   Password expiration may be a good mitigating technique when long complex passwords are not desired.
                     
                   
                 
                 See NIST 800-63B [REF-1053] for further information on password requirements.; Consider a second
                 authentication factor beyond the password, which prevents the
                 password from being a single point of failure. See CWE-308 for
                 further information.; Consider implementing a password complexity meter to inform users when a chosen password meets the required attributes.",Other_Vendor,Other_Product,*,,,,,,5.4,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N,N,L,L,N,U,L,L,N,2,6,https://github.com/froxlor/froxlor/commit/2a84e9c1207fd3d792b7fb198fd0c66fe1a66a7a|https://github.com/froxlor/froxlor/commit/2a84e9c1207fd3d792b7fb198fd0c66fe1a66a7a|https://huntr.dev/bounties/a4f86d6f-0d5d-428d-a4b3-551b20a21ce6|https://huntr.dev/bounties/a4f86d6f-0d5d-428d-a4b3-551b20a21ce6|https://huntr.dev/bounties/a4f86d6f-0d5d-428d-a4b3-551b20a21ce6|https://github.com/froxlor/froxlor/commit/2a84e9c1207fd3d792b7fb198fd0c66fe1a66a7a,|||||,0,0,froxlor/froxlor *,froxlor/froxlor *,"A product's design should require adherance to an appropriate password policy. Specific password requirements depend strongly on contextual factors, but it is recommended to contain the following attributes:
                 
                   Enforcement of a minimum and maximum length
                   Restrictions against password reuse
                   Restrictions against using common passwords
                   Restrictions against using contextual string in the password (e.g., user id, app name)
                 
                 Depending on the threat model, the password policy may include several additional attributes.
                 
                   Complex passwords requiring mixed character sets (alpha, numeric, special, mixed case)
                     
                       Increasing the range of characters makes the password harder to crack and may be appropriate for systems relying on single factor authentication.
                       Unfortunately, a complex password may be difficult to memorize, encouraging a user to select a short password or to incorrectly manage the password (write it down).
                       Another disadvantage of this approach is that it often does not result in a significant increases in overal password complexity due to people's predictable usage of various symbols.
                     
                   
                   Large Minimum Length (encouraging passphrases instead of passwords)
                     
                       Increasing the number of characters makes the password harder to crack and may be appropriate for systems relying on single factor authentication.
                       A disadvantage of this approach is that selecting a good passphrase is not easy and poor passwords can still be generated. Some prompting may be needed to encourage long un-predictable passwords.
                     
                   
                   Randomly Chosen Secrets
                     
                       Generating a password for the user can help make sure that length and complexity requirements are met, and can result in secure passwords being used.
                       A disadvantage of this approach is that the resulting password or passpharse may be too difficult to memorize, encouraging them to be written down.
                     
                   
                   Password Expiration
                     
                       Requiring a periodic password change can reduce the time window that an adversary has to crack a password, while also limiting the damage caused by password exposures at other locations.
					   Password expiration may be a good mitigating technique when long complex passwords are not desired.
                     
                   
                 
                 See NIST 800-63B [REF-1053] for further information on password requirements.; Consider a second
                 authentication factor beyond the password, which prevents the
                 password from being a single point of failure. See CWE-308 for
                 further information.; Consider implementing a password complexity meter to inform users when a chosen password meets the required attributes.",Weak Credentials,Medium,Weak Credentials,Denial of Service (DoS),
CVE-2024-28010,"Use of Hard-coded Password in NEC Corporation Aterm WG1800HP4, WG1200HS3, WG1900HP2, WG1200HP3, WG1800HP3, WG1200HS2, WG1900HP, WG1200HP2, W1200EX(-MS), WG1200HS, WG1200HP, WF300HP2, W300P, WF800HP, WR8165N, WG2200HP, WF1200HP2, WG1800HP2, WF1200HP, WG600HP, WG300HP, WF300HP, WG1800HP, WG1400HP, WR8175N, WR9300N, WR8750N, WR8160N, WR9500N, WR8600N, WR8370N, WR8170N, WR8700N, WR8300N, WR8150N, WR4100N, WR4500N, WR8100N, WR8500N, CR2500P, WR8400N, WR8200N, WR1200H, WR7870S, WR6670S, WR7850S, WR6650S, WR6600H, WR7800H, WM3400RN, WM3450RN, WM3500R, WM3600R, WM3800R, WR8166N, MR01LN MR02LN, WG1810HP(JE) and WG1810HP(MF) all versions allows a attacker to execute an arbitrary OS command via the internet.",,,0,0,0,0,,,,,,,CWE-259,Use of Hard-coded Password,Variant,"For outbound authentication: store passwords outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible.; For inbound authentication: Rather than hard-code a default username and password for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password.; Perform access control checks and limit which entities can access the feature that requires the hard-coded password. For example, a feature might only be enabled through the system console instead of through a network connection.; For inbound authentication: apply strong one-way hashes to your passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When receiving an incoming password during authentication, take the hash of the password and compare it to the hash that you have saved.
                  Use randomly assigned salts for each separate hash that you generate. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.; For front-end to back-end connections: Three solutions are possible, although none are complete.
                  
                     The first suggestion involves the use of generated passwords which are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.
                     Next, the passwords used should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.
                     Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay style attacks.",Other_Vendor,Other_Product,all versions,,,,,,9.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,N,L,N,N,U,H,H,H,59,3,https://https://jpn.nec.com/security-info/secinfo/nv24-001_en.html|https://jpn.nec.com/security-info/secinfo/nv24-001_en.html|https://jpn.nec.com/security-info/secinfo/nv24-001_en.html,||,0,0,NEC Corporation/WG1200HP3 all versions,NEC Corporation/WG1200HP3 all versions,"For outbound authentication: store passwords outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible.; For inbound authentication: Rather than hard-code a default username and password for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password.; Perform access control checks and limit which entities can access the feature that requires the hard-coded password. For example, a feature might only be enabled through the system console instead of through a network connection.; For inbound authentication: apply strong one-way hashes to your passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When receiving an incoming password during authentication, take the hash of the password and compare it to the hash that you have saved.
                  Use randomly assigned salts for each separate hash that you generate. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.; For front-end to back-end connections: Three solutions are possible, although none are complete.
                  
                     The first suggestion involves the use of generated passwords which are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.
                     Next, the passwords used should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.
                     Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay style attacks.",Hardcoded Credentials,Critical,Hardcoded Credentials,Privilege Escalation,
CVE-2024-21990,"ONTAP Select Deploy administration utility versions 9.12.1.x, 
9.13.1.x and 9.14.1.x contain hard-coded credentials that could allow an
 attacker to view Deploy configuration information and modify the 
account credentials.




",,,0,0,0,0,,,,,,,CWE-798,Use of Hard-coded Credentials,Base,"For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7].
                  In Windows environments, the Encrypted File System (EFS) may provide some protection.; For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password or key.; If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.; For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash.
                  Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.; For front-end to back-end connections: Three solutions are possible, although none are complete.
                     
                        The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.
                        Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.
                        Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.",netapp,Other_Product,*,,,,,,5.4,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N,N,L,L,N,U,L,L,N,4,3,https://security.netapp.com/advisory/ntap-20240411-0002/|https://security.netapp.com/advisory/ntap-20240411-0002/|https://security.netapp.com/advisory/ntap-20240411-0002/,||,0,0,netapp/ontap_select_deploy_administration_utility *,netapp/ontap_select_deploy_administration_utility *,"For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7].
                  In Windows environments, the Encrypted File System (EFS) may provide some protection.; For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password or key.; If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.; For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash.
                  Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.; For front-end to back-end connections: Three solutions are possible, although none are complete.
                     
                        The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.
                        Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.
                        Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.",Hardcoded Credentials,Medium,Hardcoded Credentials,Information Disclosure,
CVE-2022-37710,Patterson Dental Eaglesoft 21 has AES-256 encryption but there are two ways to obtain a keyfile: (1) keybackup.data > License > Encryption Key or (2) Eaglesoft.Server.Configuration.data > DbEncryptKeyPrimary > Encryption Key. Applicable files are encrypted with keys and salt that are hardcoded into a DLL or EXE file.,,,0,0,0,0,,,,,,,CWE-798,Use of Hard-coded Credentials,Base,"For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7].
                  In Windows environments, the Encrypted File System (EFS) may provide some protection.; For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password or key.; If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.; For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash.
                  Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.; For front-end to back-end connections: Three solutions are possible, although none are complete.
                     
                        The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.
                        Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.
                        Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.",Other_Vendor,Other_Product,,,,,,,7.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,L,L,L,N,U,H,H,H,2,5,https://justinshafer.blogspot.com/2022/08/eaglesofts-automatic-aes-256-encryption.html|https://justinshafer.blogspot.com/2022/08/eaglesofts-automatic-aes-256-encryption.html|https://justinshafer.blogspot.com/2022/08/eaglesofts-automatic-aes-256-encryption.html|https://justinshafer.blogspot.com/2022/08/eaglesofts-automatic-aes-256-encryption.html|https://justinshafer.blogspot.com/2022/08/eaglesofts-automatic-aes-256-encryption.html,||||,0,0,n/a/n/a n/a,n/a/n/a n/a,"For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7].
                  In Windows environments, the Encrypted File System (EFS) may provide some protection.; For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password or key.; If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.; For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash.
                  Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.; For front-end to back-end connections: Three solutions are possible, although none are complete.
                     
                        The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.
                        Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.
                        Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.",Hardcoded Credentials,High,Hardcoded Credentials,Remote Code Execution,
CVE-2023-41137,Symmetric encryption used to protect messages between the AppsAnywhere server and client can be broken by reverse engineering the client and used to impersonate the AppsAnywhere server.,,,0,0,0,0,,,,,,,CWE-798,Use of Hard-coded Credentials,Base,"For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7].
                  In Windows environments, the Encrypted File System (EFS) may provide some protection.; For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password or key.; If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.; For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash.
                  Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.; For front-end to back-end connections: Three solutions are possible, although none are complete.
                     
                        The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.
                        Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.
                        Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.",Other_Vendor,Other_Product,1.6.1,,,,,,8,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H,N,L,L,R,U,H,H,H,30,3,https://docs.appsanywhere.com/appsanywhere/3.1/2023-11-security-advisory|https://docs.appsanywhere.com/appsanywhere/3.1/2023-11-security-advisory|https://docs.appsanywhere.com/appsanywhere/3.1/2023-11-security-advisory,||,0,0,AppsAnywhere/AppsAnywhere Client 1.6.1,AppsAnywhere/AppsAnywhere Client 1.6.1,"For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7].
                  In Windows environments, the Encrypted File System (EFS) may provide some protection.; For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password or key.; If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.; For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash.
                  Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.; For front-end to back-end connections: Three solutions are possible, although none are complete.
                     
                        The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.
                        Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.
                        Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.",Hardcoded Credentials,High,Hardcoded Credentials,Denial of Service (DoS),
CVE-2024-26196,,,,0,0,0,0,,,,,,,CWE-259,Use of Hard-coded Password,Variant,"For outbound authentication: store passwords outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible.; For inbound authentication: Rather than hard-code a default username and password for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password.; Perform access control checks and limit which entities can access the feature that requires the hard-coded password. For example, a feature might only be enabled through the system console instead of through a network connection.; For inbound authentication: apply strong one-way hashes to your passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When receiving an incoming password during authentication, take the hash of the password and compare it to the hash that you have saved.
                  Use randomly assigned salts for each separate hash that you generate. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.; For front-end to back-end connections: Three solutions are possible, although none are complete.
                  
                     The first suggestion involves the use of generated passwords which are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.
                     Next, the passwords used should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.
                     Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay style attacks.",microsoft,Other_Product,*,,,,,,4.3,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N/E:U/RL:O/RC:C,N,L,N,R,U,L,N,N,2,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-26196|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-26196|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-26196,||,0,0,microsoft/edge *,microsoft/edge *,"For outbound authentication: store passwords outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible.; For inbound authentication: Rather than hard-code a default username and password for first time logins, utilize a ""first login"" mode that requires the user to enter a unique strong password.; Perform access control checks and limit which entities can access the feature that requires the hard-coded password. For example, a feature might only be enabled through the system console instead of through a network connection.; For inbound authentication: apply strong one-way hashes to your passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When receiving an incoming password during authentication, take the hash of the password and compare it to the hash that you have saved.
                  Use randomly assigned salts for each separate hash that you generate. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.; For front-end to back-end connections: Three solutions are possible, although none are complete.
                  
                     The first suggestion involves the use of generated passwords which are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals.
                     Next, the passwords used should be limited at the back end to only performing actions valid for the front end, as opposed to having full access.
                     Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay style attacks.",Hardcoded Credentials,Medium,Hardcoded Credentials,Privilege Escalation,
CVE-2024-29050,,,,0,0,0,0,,,,,,,CWE-295,Improper Certificate Validation,Base,"Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.; If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.",Microsoft,Windows 11 version 21H2,10.0.0,,,,,,8.4,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C,L,L,N,N,U,H,H,H,80,3,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-29050|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-29050|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-29050,||,0,0,Microsoft/Windows 11 version 21H2 10.0.0,Microsoft/Windows 11 version 21H2 10.0.0,"Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.; If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.",Certificate Validation,High,Certificate Validation,Information Disclosure,
CVE-2022-20960,"A vulnerability in Cisco AsyncOS Software for Cisco Email Security Appliance (ESA) could allow an unauthenticated remote attacker to cause a denial of service (DoS) condition on an affected device.
 This vulnerability is due to improper handling of certain TLS connections that are processed by an affected device. An attacker could exploit this vulnerability by establishing a large number of concurrent TLS connections to an affected device. A successful exploit could allow the attacker to cause the device to drop new TLS email messages that come from the associated email servers. Exploitation of this vulnerability does not cause the affected device to unexpectedly reload. The device will recover autonomously within a few hours of when the attack is halted or mitigated.",,,0,0,0,0,,,,,,,CWE-295,Improper Certificate Validation,Base,"Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.; If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.",Cisco,Other_Product,11.1.0-128,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,28,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-esa-dos-gdghHmbV|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-esa-dos-gdghHmbV|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-esa-dos-gdghHmbV,||,0,0,Cisco/Cisco Secure Email 11.1.0-128,Cisco/Cisco Secure Email 11.1.0-128,"Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.; If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.",Certificate Validation,High,Certificate Validation,Remote Code Execution,
CVE-2024-20385,"A vulnerability in the SSL/TLS implementation of Cisco Nexus Dashboard Orchestrator (NDO) could allow an unauthenticated, remote attacker to intercept sensitive information from an affected device.&nbsp;

This vulnerability exists because the Cisco NDO Validate Peer Certificate site management feature validates the certificates for Cisco Application Policy Infrastructure Controller (APIC), Cisco Cloud Network Controller (CNC), and Cisco Nexus Dashboard only when a new site is added or an existing one is reregistered. An attacker could exploit this vulnerability by using machine-in-the-middle techniques to intercept the traffic between the affected device and Cisco NDO and then using a crafted certificate to impersonate the affected device. A successful exploit could allow the attacker to learn sensitive information during communications between these devices.",,,0,0,0,0,,,,,,,CWE-295,Improper Certificate Validation,Base,"Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.; If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.",Cisco,Other_Product,3.7(2f),,,,,,5.9,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N,N,H,N,N,U,H,N,N,23,2,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ndo-tlsvld-FdUF3cpw|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-ndo-tlsvld-FdUF3cpw,|,0,0,Cisco/Cisco Nexus Dashboard Orchestrator 3.7(2f),Cisco/Cisco Nexus Dashboard Orchestrator 3.7(2f),"Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.; If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.",Certificate Validation,Medium,Certificate Validation,Denial of Service (DoS),
CVE-2023-28321,"An improper certificate validation vulnerability exists in curl <v8.1.0 in the way it supports matching of wildcard patterns when listed as ""Subject Alternative Name"" in TLS server certificates. curl can be built to use its own name matching function for TLS rather than one provided by a TLS library. This private wildcard matching function would match IDN (International Domain Name) hosts incorrectly and could as a result accept patterns that otherwise should mismatch. IDN hostnames are converted to puny code before used for certificate checks. Puny coded names always start with `xn--` and should not be allowed to pattern match, but the wildcard check in curl could still check for `x*`, which would match even though the IDN name most likely contained nothing even resembling an `x`.",,,0,0,0,0,,,,,,,CWE-295,Improper Certificate Validation,Base,"Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.; If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.",debian,debian_linux,10,,,,,,5.9,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N,N,H,N,N,U,N,H,N,8,36,http://seclists.org/fulldisclosure/2023/Jul/47|http://seclists.org/fulldisclosure/2023/Jul/47|http://seclists.org/fulldisclosure/2023/Jul/48|http://seclists.org/fulldisclosure/2023/Jul/48|http://seclists.org/fulldisclosure/2023/Jul/52|http://seclists.org/fulldisclosure/2023/Jul/52|https://hackerone.com/reports/1950627|https://hackerone.com/reports/1950627|https://lists.debian.org/debian-lts-announce/2023/10/msg00016.html|https://lists.debian.org/debian-lts-announce/2023/10/msg00016.html|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/F4I75RDGX5ULSSCBE5BF3P5I5SFO7ULQ/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/F4I75RDGX5ULSSCBE5BF3P5I5SFO7ULQ/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/Z2LIWHWKOVH24COGGBCVOWDXXIUPKOMK/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/Z2LIWHWKOVH24COGGBCVOWDXXIUPKOMK/|https://security.gentoo.org/glsa/202310-12|https://security.gentoo.org/glsa/202310-12|https://security.netapp.com/advisory/ntap-20230609-0009/|https://security.netapp.com/advisory/ntap-20230609-0009/|https://support.apple.com/kb/HT213843|https://support.apple.com/kb/HT213843|https://support.apple.com/kb/HT213844|https://support.apple.com/kb/HT213844|https://support.apple.com/kb/HT213845|https://support.apple.com/kb/HT213845|https://hackerone.com/reports/1950627|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/F4I75RDGX5ULSSCBE5BF3P5I5SFO7ULQ/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/Z2LIWHWKOVH24COGGBCVOWDXXIUPKOMK/|https://security.netapp.com/advisory/ntap-20230609-0009/|https://support.apple.com/kb/HT213843|https://support.apple.com/kb/HT213844|https://support.apple.com/kb/HT213845|http://seclists.org/fulldisclosure/2023/Jul/52|http://seclists.org/fulldisclosure/2023/Jul/48|http://seclists.org/fulldisclosure/2023/Jul/47|https://security.gentoo.org/glsa/202310-12|https://lists.debian.org/debian-lts-announce/2023/10/msg00016.html,|||||||||||||||||||||||||||||||||||,0,0,debian/debian_linux 10.0,debian/debian_linux 10.0,"Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.; If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.",Certificate Validation,Medium,Certificate Validation,Privilege Escalation,
CVE-2024-43550,,,,0,0,0,0,,,,,,,CWE-295,Improper Certificate Validation,Base,"Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.; If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.",Microsoft,Windows Server 2016,10.0.14393.0,,,,,,7.4,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N/E:U/RL:O/RC:C,N,H,N,N,U,H,H,N,35,2,https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-43550|https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-43550,|,0,0,Microsoft/Windows Server 2016 10.0.14393.0,Microsoft/Windows Server 2016 10.0.14393.0,"Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.; If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.",Certificate Validation,High,Certificate Validation,Information Disclosure,
CVE-2023-20264,"A vulnerability in the implementation of Security Assertion Markup Language (SAML) 2.0 single sign-on (SSO) for remote access VPN in Cisco Adaptive Security Appliance (ASA) Software and Cisco Firepower Threat Defense (FTD) Software could allow an unauthenticated, remote attacker to intercept the SAML assertion of a user who is authenticating to a remote access VPN session. This vulnerability is due to insufficient validation of the login URL. An attacker could exploit this vulnerability by persuading a user to access a site that is under the control of the attacker, allowing the attacker to modify the login URL. A successful exploit could allow the attacker to intercept a successful SAML assertion and use that assertion to establish a remote access VPN session toward the affected device with the identity and permissions of the hijacked user, resulting in access to the protected network.",,,0,0,0,0,,,,,,,CWE-601,URL Redirection to Untrusted Site ('Open Redirect'),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  Use a list of approved URLs or domains to be used for redirection.; Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""/login.asp"" and ID 2 could map to ""http://www.example.com/"". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.; Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.
                  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",Cisco,Cisco Adaptive Security Appliance (ASA) Software,9.18.3,,,,,,6.1,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N,N,L,N,R,C,L,L,N,15,3,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-saml-hijack-ttuQfyz|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-saml-hijack-ttuQfyz|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asaftd-saml-hijack-ttuQfyz,||,0,0,Cisco/Cisco Adaptive Security Appliance (ASA) Software 9.18.3,Cisco/Cisco Adaptive Security Appliance (ASA) Software 9.18.3,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  Use a list of approved URLs or domains to be used for redirection.; Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""/login.asp"" and ID 2 could map to ""http://www.example.com/"". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.; Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.
                  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",Open Redirect,Medium,Open Redirect,Remote Code Execution,
CVE-2023-46624,"URL Redirection to Untrusted Site ('Open Redirect') vulnerability in Parcel Pro.This issue affects Parcel Pro: from n/a through 1.6.11.

",,,0,0,0,0,,,,,,,CWE-601,URL Redirection to Untrusted Site ('Open Redirect'),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  Use a list of approved URLs or domains to be used for redirection.; Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""/login.asp"" and ID 2 could map to ""http://www.example.com/"". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.; Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.
                  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",Other_Vendor,Other_Product,*,,,,,,4.7,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:N/A:N,N,L,N,R,C,L,N,N,2,3,https://patchstack.com/database/vulnerability/woo-parcel-pro/wordpress-parcel-pro-plugin-1-6-3-open-redirection-vulnerability?_s_id=cve|https://patchstack.com/database/vulnerability/woo-parcel-pro/wordpress-parcel-pro-plugin-1-6-3-open-redirection-vulnerability?_s_id=cve|https://patchstack.com/database/vulnerability/woo-parcel-pro/wordpress-parcel-pro-plugin-1-6-3-open-redirection-vulnerability?_s_id=cve,||,0,0,parcelpro/parcel_pro *,parcelpro/parcel_pro *,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  Use a list of approved URLs or domains to be used for redirection.; Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""/login.asp"" and ID 2 could map to ""http://www.example.com/"". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.; Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.
                  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",Open Redirect,Medium,Open Redirect,Denial of Service (DoS),
CVE-2023-47548,"URL Redirection to Untrusted Site ('Open Redirect') vulnerability in SoftLab Integrate Google Drive – Browse, Upload, Download, Embed, Play, Share, Gallery, and Manage Your Google Drive Files Into Your WordPress Site.This issue affects Integrate Google Drive – Browse, Upload, Download, Embed, Play, Share, Gallery, and Manage Your Google Drive Files Into Your WordPress Site: from n/a through 1.3.2.

",,,0,0,0,0,,,,,,,CWE-601,URL Redirection to Untrusted Site ('Open Redirect'),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  Use a list of approved URLs or domains to be used for redirection.; Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""/login.asp"" and ID 2 could map to ""http://www.example.com/"". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.; Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.
                  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",Other_Vendor,Other_Product,*,,,,,,4.7,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:N/A:N,N,L,N,R,C,L,N,N,2,3,https://patchstack.com/database/vulnerability/integrate-google-drive/wordpress-integrate-google-drive-plugin-1-3-0-open-redirection-vulnerability?_s_id=cve|https://patchstack.com/database/vulnerability/integrate-google-drive/wordpress-integrate-google-drive-plugin-1-3-0-open-redirection-vulnerability?_s_id=cve|https://patchstack.com/database/vulnerability/integrate-google-drive/wordpress-integrate-google-drive-plugin-1-3-0-open-redirection-vulnerability?_s_id=cve,||,0,0,softlabbd/integrate_google_drive *,softlabbd/integrate_google_drive *,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  Use a list of approved URLs or domains to be used for redirection.; Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""/login.asp"" and ID 2 could map to ""http://www.example.com/"". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.; Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.
                  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",Open Redirect,Medium,Open Redirect,Privilege Escalation,
CVE-2023-41699,"URL Redirection to Untrusted Site ('Open Redirect') vulnerability in Payara Platform Payara Server, Micro and Embedded (Servlet Implementation modules) allows Redirect Access to Libraries.This issue affects Payara Server, Micro and Embedded: from 5.0.0 before 5.57.0, from 4.1.2.191 before 4.1.2.191.46, from 6.0.0 before 6.8.0, from 6.2023.1 before 6.2023.11.

",,,0,0,0,0,,,,,,,CWE-601,URL Redirection to Untrusted Site ('Open Redirect'),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  Use a list of approved URLs or domains to be used for redirection.; Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""/login.asp"" and ID 2 could map to ""http://www.example.com/"". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.; Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.
                  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",Other_Vendor,Other_Product,*,,,,,,6.1,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N,N,L,N,R,C,L,L,N,5,6,https://docs.payara.fish/community/docs/Release%20Notes/Release%20Notes%206.2023.11.html|https://docs.payara.fish/community/docs/Release%20Notes/Release%20Notes%206.2023.11.html|https://docs.payara.fish/enterprise/docs/Release%20Notes/Release%20Notes%206.8.0.html|https://docs.payara.fish/enterprise/docs/Release%20Notes/Release%20Notes%206.8.0.html|https://docs.payara.fish/enterprise/docs/Release%20Notes/Release%20Notes%206.8.0.html|https://docs.payara.fish/community/docs/Release%20Notes/Release%20Notes%206.2023.11.html,|||||,0,0,payara/payara *,payara/payara *,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  Use a list of approved URLs or domains to be used for redirection.; Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""/login.asp"" and ID 2 could map to ""http://www.example.com/"". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.; Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.
                  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",Open Redirect,Medium,Open Redirect,Information Disclosure,
CVE-2022-0697,Open Redirect in GitHub repository archivy/archivy prior to 1.7.0.,,,0,0,0,0,,,,,,,CWE-601,URL Redirection to Untrusted Site ('Open Redirect'),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  Use a list of approved URLs or domains to be used for redirection.; Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""/login.asp"" and ID 2 could map to ""http://www.example.com/"". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.; Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.
                  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",Other_Vendor,Other_Product,*,,,,,,3.4,,,CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:N/I:L/A:N,N,H,N,R,C,N,L,N,2,6,https://github.com/archivy/archivy/commit/2d8cb29853190d42572b36deb61127e68d6be574|https://github.com/archivy/archivy/commit/2d8cb29853190d42572b36deb61127e68d6be574|https://huntr.dev/bounties/2d0301a2-10ff-48f4-a346-5a0e8707835b|https://huntr.dev/bounties/2d0301a2-10ff-48f4-a346-5a0e8707835b|https://huntr.dev/bounties/2d0301a2-10ff-48f4-a346-5a0e8707835b|https://github.com/archivy/archivy/commit/2d8cb29853190d42572b36deb61127e68d6be574,|||||,0,0,archivy_project/archivy *,archivy_project/archivy *,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.
                  Use a list of approved URLs or domains to be used for redirection.; Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving the current site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems (CWE-79) when generating the disclaimer page.; When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.
                  For example, ID 1 could map to ""/login.asp"" and ID 2 could map to ""http://www.example.com/"". Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.; Ensure that no externally-supplied requests are honored by requiring that all redirect requests include a unique nonce generated by the application [REF-483]. Be sure that the nonce is not predictable (CWE-330).; Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.
                  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.; Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.",Open Redirect,Low,Open Redirect,Remote Code Execution,
CVE-2021-2351,"Vulnerability in the Advanced Networking Option component of Oracle Database Server. Supported versions that are affected are 12.1.0.2, 12.2.0.1 and 19c. Difficult to exploit vulnerability allows unauthenticated attacker with network access via Oracle Net to compromise Advanced Networking Option. Successful attacks require human interaction from a person other than the attacker and while the vulnerability is in Advanced Networking Option, attacks may significantly impact additional products. Successful attacks of this vulnerability can result in takeover of Advanced Networking Option. Note: The July 2021 Critical Patch Update introduces a number of Native Network Encryption changes to deal with vulnerability CVE-2021-2351 and prevent the use of weaker ciphers. Customers should review: ""Changes in Native Network Encryption with the July 2021 Critical Patch Update"" (Doc ID 2791571.1). CVSS 3.1 Base Score 8.3 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H).",,,0,0,0,0,,,,,,,CWE-327,Use of a Broken or Risky Cryptographic Algorithm,Class,"When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis.
                  For example, US government systems require FIPS 140-2 certification [REF-1192].
                  Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak.
                  Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]; Ensure that the design allows one cryptographic algorithm to be replaced with another in the next generation or version. Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. With hardware, design the product at the Intellectual Property (IP) level so that one cryptographic algorithm can be replaced with another in the next generation of the hardware product.; Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",oracle,Other_Product,7.4.1,,,,,,8.3,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H,N,H,N,R,C,H,H,H,478,30,http://packetstormsecurity.com/files/165255/Oracle-Database-Protection-Mechanism-Bypass.html|http://packetstormsecurity.com/files/165255/Oracle-Database-Protection-Mechanism-Bypass.html|http://packetstormsecurity.com/files/165258/Oracle-Database-Weak-NNE-Integrity-Key-Derivation.html|http://packetstormsecurity.com/files/165258/Oracle-Database-Weak-NNE-Integrity-Key-Derivation.html|http://seclists.org/fulldisclosure/2021/Dec/19|http://seclists.org/fulldisclosure/2021/Dec/19|http://seclists.org/fulldisclosure/2021/Dec/20|http://seclists.org/fulldisclosure/2021/Dec/20|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpujan2022.html|https://www.oracle.com/security-alerts/cpujan2022.html|https://www.oracle.com/security-alerts/cpujan2023.html|https://www.oracle.com/security-alerts/cpujan2023.html|https://www.oracle.com/security-alerts/cpujul2021.html|https://www.oracle.com/security-alerts/cpujul2021.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpuoct2021.html|https://www.oracle.com/security-alerts/cpuoct2021.html|https://www.oracle.com/security-alerts/cpujul2021.html|https://www.oracle.com/security-alerts/cpuoct2021.html|http://seclists.org/fulldisclosure/2021/Dec/19|http://seclists.org/fulldisclosure/2021/Dec/20|https://www.oracle.com/security-alerts/cpujan2022.html|http://packetstormsecurity.com/files/165258/Oracle-Database-Weak-NNE-Integrity-Key-Derivation.html|http://packetstormsecurity.com/files/165255/Oracle-Database-Protection-Mechanism-Bypass.html|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujan2023.html,|||||||||||||||||||||||||||||,0,0,oracle/communications_design_studio 7.4.1,oracle/communications_design_studio 7.4.1,"When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis.
                  For example, US government systems require FIPS 140-2 certification [REF-1192].
                  Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak.
                  Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]; Ensure that the design allows one cryptographic algorithm to be replaced with another in the next generation or version. Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. With hardware, design the product at the Intellectual Property (IP) level so that one cryptographic algorithm can be replaced with another in the next generation of the hardware product.; Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Broken/Risky Crypto,High,Broken/Risky Crypto,Denial of Service (DoS),
CVE-2021-31562,"The SSL/TLS configuration of Fresenius Kabi Agilia Link + version 3.0 has serious deficiencies that may allow an attacker to compromise SSL/TLS sessions in different ways. An attacker may be able to eavesdrop on transferred data, manipulate data allegedly secured by SSL/TLS, and impersonate an entity to gain access to sensitive information.",,,0,0,0,0,,,,,,,CWE-327,Use of a Broken or Risky Cryptographic Algorithm,Class,"When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis.
                  For example, US government systems require FIPS 140-2 certification [REF-1192].
                  Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak.
                  Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]; Ensure that the design allows one cryptographic algorithm to be replaced with another in the next generation or version. Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. With hardware, design the product at the Intellectual Property (IP) level so that one cryptographic algorithm can be replaced with another in the next generation of the hardware product.; Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Other_Vendor,Other_Product,1,,,,,,6.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N,N,L,N,N,U,L,L,N,5,3,https://www.cisa.gov/uscert/ics/advisories/icsma-21-355-01|https://www.cisa.gov/uscert/ics/advisories/icsma-21-355-01|https://www.cisa.gov/uscert/ics/advisories/icsma-21-355-01,||,0,0,fresenius-kabi/vigilant_mastermed 1.0,fresenius-kabi/vigilant_mastermed 1.0,"When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis.
                  For example, US government systems require FIPS 140-2 certification [REF-1192].
                  Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak.
                  Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]; Ensure that the design allows one cryptographic algorithm to be replaced with another in the next generation or version. Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. With hardware, design the product at the Intellectual Property (IP) level so that one cryptographic algorithm can be replaced with another in the next generation of the hardware product.; Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Broken/Risky Crypto,Medium,Broken/Risky Crypto,Privilege Escalation,
CVE-2021-2351,"Vulnerability in the Advanced Networking Option component of Oracle Database Server. Supported versions that are affected are 12.1.0.2, 12.2.0.1 and 19c. Difficult to exploit vulnerability allows unauthenticated attacker with network access via Oracle Net to compromise Advanced Networking Option. Successful attacks require human interaction from a person other than the attacker and while the vulnerability is in Advanced Networking Option, attacks may significantly impact additional products. Successful attacks of this vulnerability can result in takeover of Advanced Networking Option. Note: The July 2021 Critical Patch Update introduces a number of Native Network Encryption changes to deal with vulnerability CVE-2021-2351 and prevent the use of weaker ciphers. Customers should review: ""Changes in Native Network Encryption with the July 2021 Critical Patch Update"" (Doc ID 2791571.1). CVSS 3.1 Base Score 8.3 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H).",,,0,0,0,0,,,,,,,CWE-327,Use of a Broken or Risky Cryptographic Algorithm,Class,"When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis.
                  For example, US government systems require FIPS 140-2 certification [REF-1192].
                  Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak.
                  Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]; Ensure that the design allows one cryptographic algorithm to be replaced with another in the next generation or version. Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. With hardware, design the product at the Intellectual Property (IP) level so that one cryptographic algorithm can be replaced with another in the next generation of the hardware product.; Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",oracle,Other_Product,5.2.3,,,,,,8.3,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H,N,H,N,R,C,H,H,H,478,30,http://packetstormsecurity.com/files/165255/Oracle-Database-Protection-Mechanism-Bypass.html|http://packetstormsecurity.com/files/165255/Oracle-Database-Protection-Mechanism-Bypass.html|http://packetstormsecurity.com/files/165258/Oracle-Database-Weak-NNE-Integrity-Key-Derivation.html|http://packetstormsecurity.com/files/165258/Oracle-Database-Weak-NNE-Integrity-Key-Derivation.html|http://seclists.org/fulldisclosure/2021/Dec/19|http://seclists.org/fulldisclosure/2021/Dec/19|http://seclists.org/fulldisclosure/2021/Dec/20|http://seclists.org/fulldisclosure/2021/Dec/20|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpujan2022.html|https://www.oracle.com/security-alerts/cpujan2022.html|https://www.oracle.com/security-alerts/cpujan2023.html|https://www.oracle.com/security-alerts/cpujan2023.html|https://www.oracle.com/security-alerts/cpujul2021.html|https://www.oracle.com/security-alerts/cpujul2021.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpuoct2021.html|https://www.oracle.com/security-alerts/cpuoct2021.html|https://www.oracle.com/security-alerts/cpujul2021.html|https://www.oracle.com/security-alerts/cpuoct2021.html|http://seclists.org/fulldisclosure/2021/Dec/19|http://seclists.org/fulldisclosure/2021/Dec/20|https://www.oracle.com/security-alerts/cpujan2022.html|http://packetstormsecurity.com/files/165258/Oracle-Database-Weak-NNE-Integrity-Key-Derivation.html|http://packetstormsecurity.com/files/165255/Oracle-Database-Protection-Mechanism-Bypass.html|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujan2023.html,|||||||||||||||||||||||||||||,0,0,oracle/thesaurus_management_system 5.2.3,oracle/thesaurus_management_system 5.2.3,"When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis.
                  For example, US government systems require FIPS 140-2 certification [REF-1192].
                  Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak.
                  Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]; Ensure that the design allows one cryptographic algorithm to be replaced with another in the next generation or version. Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. With hardware, design the product at the Intellectual Property (IP) level so that one cryptographic algorithm can be replaced with another in the next generation of the hardware product.; Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Broken/Risky Crypto,High,Broken/Risky Crypto,Information Disclosure,
CVE-2022-20805,"A vulnerability in the automatic decryption process in Cisco Umbrella Secure Web Gateway (SWG) could allow an authenticated, adjacent attacker to bypass the SSL decryption and content filtering policies on an affected system. This vulnerability is due to how the decryption function uses the TLS Sever Name Indication (SNI) extension of an HTTP request to discover the destination domain and determine if the request needs to be decrypted. An attacker could exploit this vulnerability by sending a crafted request over TLS from a client to an unknown or controlled URL. A successful exploit could allow an attacker to bypass the decryption process of Cisco Umbrella SWG and allow malicious content to be downloaded to a host on a protected network. There are workarounds that address this vulnerability.",,,0,0,0,0,,,,,,,CWE-327,Use of a Broken or Risky Cryptographic Algorithm,Class,"When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis.
                  For example, US government systems require FIPS 140-2 certification [REF-1192].
                  Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak.
                  Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]; Ensure that the design allows one cryptographic algorithm to be replaced with another in the next generation or version. Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. With hardware, design the product at the Intellectual Property (IP) level so that one cryptographic algorithm can be replaced with another in the next generation of the hardware product.; Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Cisco,Other_Product,,,,,,,4.1,,,CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:C/C:N/I:L/A:N,A,L,L,N,C,N,L,N,4,3,https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-uswg-fdbps-xtTRKpp6|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-uswg-fdbps-xtTRKpp6|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-uswg-fdbps-xtTRKpp6,||,0,0,Cisco/Cisco Umbrella Insights Virtual Appliance n/a,Cisco/Cisco Umbrella Insights Virtual Appliance n/a,"When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis.
                  For example, US government systems require FIPS 140-2 certification [REF-1192].
                  Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak.
                  Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]; Ensure that the design allows one cryptographic algorithm to be replaced with another in the next generation or version. Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. With hardware, design the product at the Intellectual Property (IP) level so that one cryptographic algorithm can be replaced with another in the next generation of the hardware product.; Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.; Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.
                  Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Broken/Risky Crypto,Medium,Broken/Risky Crypto,Remote Code Execution,
CVE-2023-44318,Affected devices use a hardcoded key to obfuscate the configuration backup that an administrator can export from the device. This could allow an authenticated attacker with administrative privileges or an attacker that obtains a configuration backup to extract configuration information from the exported file.,,,0,0,0,0,,,,,,,CWE-321,Use of Hard-coded Cryptographic Key,Variant,Prevention schemes mirror that of hard-coded password storage.,Siemens,Other_Product,0,,,,,,4.9,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N,N,L,H,N,U,H,N,N,104,15,https://cert-portal.siemens.com/productcert/html/ssa-180704.html|https://cert-portal.siemens.com/productcert/html/ssa-180704.html|https://cert-portal.siemens.com/productcert/html/ssa-353002.html|https://cert-portal.siemens.com/productcert/html/ssa-353002.html|https://cert-portal.siemens.com/productcert/html/ssa-690517.html|https://cert-portal.siemens.com/productcert/html/ssa-690517.html|https://cert-portal.siemens.com/productcert/pdf/ssa-180704.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-180704.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-699386.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-699386.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-699386.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-180704.pdf|https://cert-portal.siemens.com/productcert/html/ssa-180704.html|https://cert-portal.siemens.com/productcert/html/ssa-353002.html|https://cert-portal.siemens.com/productcert/html/ssa-690517.html,||||||||||||||,0,0,Siemens/SCALANCE WAM766-1 EEC (US) 0,Siemens/SCALANCE WAM766-1 EEC (US) 0,Prevention schemes mirror that of hard-coded password storage.,Broken/Risky Crypto,Medium,Broken/Risky Crypto,Denial of Service (DoS),
CVE-2022-43570,"In Splunk Enterprise versions below 8.1.12, 8.2.9, and 9.0.2, an authenticated user can perform an extensible markup language (XML) external entity (XXE) injection via a custom View. The XXE injection causes Splunk Web to embed incorrect documents into an error.
",,,0,0,0,0,,,,,,,CWE-611,Improper Restriction of XML External Entity Reference,Base,Many XML parsers and validators can be configured to disable external entity expansion.,Other_Vendor,Other_Product,8.2,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,N,L,L,N,U,H,H,H,5,3,https://www.splunk.com/en_us/product-security/announcements/svd-2022-1110.html|https://www.splunk.com/en_us/product-security/announcements/svd-2022-1110.html|https://www.splunk.com/en_us/product-security/announcements/svd-2022-1110.html,||,0,0,Splunk/Splunk Enterprise 8.2,Splunk/Splunk Enterprise 8.2,Many XML parsers and validators can be configured to disable external entity expansion.,XXE,High,XXE,Privilege Escalation,
CVE-2023-5136,An incorrect permission assignment in the TopoGrafix DataPlugin for GPX could result in information disclosure.  An attacker could exploit this vulnerability by getting a user to open a specially crafted data file.,,,0,0,0,0,,,,,,,CWE-611,Improper Restriction of XML External Entity Reference,Base,Many XML parsers and validators can be configured to disable external entity expansion.,Other_Vendor,Other_Product,2019,,,,,,5.5,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N,L,L,N,R,U,H,N,N,60,3,https://www.ni.com/en/support/documentation/supplemental/23/incorrect-permission-assignment-in-the-topografix-dataplug-for-gpx.html|https://www.ni.com/en/support/documentation/supplemental/23/incorrect-permission-assignment-in-the-topografix-dataplug-for-gpx.html|https://www.ni.com/en/support/documentation/supplemental/23/incorrect-permission-assignment-in-the-topografix-dataplug-for-gpx.html,||,0,0,ni/flexlogger 2019,ni/flexlogger 2019,Many XML parsers and validators can be configured to disable external entity expansion.,XXE,Medium,XXE,Information Disclosure,
CVE-2021-4295,A vulnerability classified as problematic was found in ONC code-validator-api up to 1.0.30. This vulnerability affects the function vocabularyValidationConfigurations of the file src/main/java/org/sitenv/vocabularies/configuration/CodeValidatorApiConfiguration.java of the component XML Handler. The manipulation leads to xml external entity reference. Upgrading to version 1.0.31 is able to address this issue. The name of the patch is fbd8ea121755a2d3d116b13f235bc8b61d8449af. It is recommended to upgrade the affected component. VDB-217018 is the identifier assigned to this vulnerability.,,,0,0,0,0,,,,,,,CWE-611,Improper Restriction of XML External Entity Reference,Base,Many XML parsers and validators can be configured to disable external entity expansion.,Other_Vendor,Other_Product,1.0.20,,,,,,5.5,,,CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L,A,L,L,N,U,L,L,L,32,15,https://github.com/onc-healthit/code-validator-api/commit/fbd8ea121755a2d3d116b13f235bc8b61d8449af|https://github.com/onc-healthit/code-validator-api/commit/fbd8ea121755a2d3d116b13f235bc8b61d8449af|https://github.com/onc-healthit/code-validator-api/pull/97|https://github.com/onc-healthit/code-validator-api/pull/97|https://github.com/onc-healthit/code-validator-api/releases/tag/1.0.31|https://github.com/onc-healthit/code-validator-api/releases/tag/1.0.31|https://vuldb.com/?ctiid.217018|https://vuldb.com/?ctiid.217018|https://vuldb.com/?id.217018|https://vuldb.com/?id.217018|https://vuldb.com/?id.217018|https://vuldb.com/?ctiid.217018|https://github.com/onc-healthit/code-validator-api/pull/97|https://github.com/onc-healthit/code-validator-api/commit/fbd8ea121755a2d3d116b13f235bc8b61d8449af|https://github.com/onc-healthit/code-validator-api/releases/tag/1.0.31,||||||||||||||,0,0,ONC/code-validator-api 1.0.20,ONC/code-validator-api 1.0.20,Many XML parsers and validators can be configured to disable external entity expansion.,XXE,Medium,XXE,Remote Code Execution,
CVE-2021-42646,"XML External Entity (XXE) vulnerability in the file based service provider creation feature of the Management Console in WSO2 API Manager 2.6.0, 3.0.0, 3.1.0, 3.2.0, and 4.0.0; and WSO2 IS as Key Manager 5.7.0, 5.9.0, and 5.10.0; and WSO2 Identity Server 5.7.0, 5.8.0, 5.9.0, 5.10.0, and 5.11.0. Allows attackers to gain read access to sensitive information or cause a denial of service via crafted GET requests.",,,0,0,0,0,,,,,,,CWE-611,Improper Restriction of XML External Entity Reference,Base,Many XML parsers and validators can be configured to disable external entity expansion.,Other_Vendor,Other_Product,,,,,,,9.1,3.9,5.2,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H,N,L,N,N,U,H,N,H,14,12,http://packetstormsecurity.com/files/167465/WSO2-Management-Console-XML-Injection.html|http://packetstormsecurity.com/files/167465/WSO2-Management-Console-XML-Injection.html|http://seclists.org/fulldisclosure/2022/Jun/7|http://seclists.org/fulldisclosure/2022/Jun/7|https://github.com/wso2/carbon-identity-framework/pull/3472|https://github.com/wso2/carbon-identity-framework/pull/3472|https://security.docs.wso2.com/en/latest/security-announcements/security-advisories/2021/WSO2-2021-1289/|https://security.docs.wso2.com/en/latest/security-announcements/security-advisories/2021/WSO2-2021-1289/|https://github.com/wso2/carbon-identity-framework/pull/3472|http://seclists.org/fulldisclosure/2022/Jun/7|http://packetstormsecurity.com/files/167465/WSO2-Management-Console-XML-Injection.html|https://security.docs.wso2.com/en/latest/security-announcements/security-advisories/2021/WSO2-2021-1289/,|||||||||||,0,0,n/a/n/a n/a,n/a/n/a n/a,Many XML parsers and validators can be configured to disable external entity expansion.,XXE,Critical,XXE,Denial of Service (DoS),
CVE-2023-41369,"The Create Single Payment application of SAP S/4HANA - versions 100, 101, 102, 103, 104, 105, 106, 107, 108, allows an attacker to upload the XML file as an attachment. When clicked on the XML file in the attachment section, the file gets opened in the browser to cause the entity loops to slow down the browser.

",,,0,0,0,0,,,,,,,CWE-611,Improper Restriction of XML External Entity Reference,Base,Many XML parsers and validators can be configured to disable external entity expansion.,sap,Other_Product,107,,,,,,3.5,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:L,N,L,L,R,U,N,N,L,18,6,https://me.sap.com/notes/3369680|https://me.sap.com/notes/3369680|https://www.sap.com/documents/2022/02/fa865ea4-167e-0010-bca6-c68f7e60039b.html|https://www.sap.com/documents/2022/02/fa865ea4-167e-0010-bca6-c68f7e60039b.html|https://me.sap.com/notes/3369680|https://www.sap.com/documents/2022/02/fa865ea4-167e-0010-bca6-c68f7e60039b.html,|||||,0,0,sap/s\/4_hana 107,sap/s\/4_hana 107,Many XML parsers and validators can be configured to disable external entity expansion.,XXE,Low,XXE,Privilege Escalation,
CVE-2021-20322,"A flaw in the processing of received ICMP errors (ICMP fragment needed and ICMP redirect) in the Linux kernel functionality was found to allow the ability to quickly scan open UDP ports. This flaw allows an off-path remote user to effectively bypass the source port UDP randomization. The highest threat from this vulnerability is to confidentiality and possibly integrity, because software that relies on UDP source port randomization are indirectly affected as well.",,,0,0,0,0,,,,,,,CWE-330,Use of Insufficiently Random Values,Class,"Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a ""random enough"" number.; Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (""Approved Random Number Generators"").; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",oracle,Other_Product,22.2.0,,,,,,7.4,2.2,5.2,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N,N,H,N,N,U,H,H,N,12,27,https://bugzilla.redhat.com/show_bug.cgi?id=2014230|https://bugzilla.redhat.com/show_bug.cgi?id=2014230|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.15-rc6&id=4785305c05b25a242e5314cc821f54ade4c18810|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.15-rc6&id=4785305c05b25a242e5314cc821f54ade4c18810|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.15-rc6&id=6457378fe796815c973f631a1904e147d6ee33b1|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.15-rc6&id=6457378fe796815c973f631a1904e147d6ee33b1|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/route.c?h=v5.15-rc6&id=67d6d681e15b578c1725bad8ad079e05d1c48a8e|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/route.c?h=v5.15-rc6&id=67d6d681e15b578c1725bad8ad079e05d1c48a8e|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv6/route.c?h=v5.15-rc6&id=a00df2caffed3883c341d5685f830434312e4a43|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv6/route.c?h=v5.15-rc6&id=a00df2caffed3883c341d5685f830434312e4a43|https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html|https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html|https://security.netapp.com/advisory/ntap-20220303-0002/|https://security.netapp.com/advisory/ntap-20220303-0002/|https://www.debian.org/security/2022/dsa-5096|https://www.debian.org/security/2022/dsa-5096|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://bugzilla.redhat.com/show_bug.cgi?id=2014230|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.15-rc6&id=4785305c05b25a242e5314cc821f54ade4c18810|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.15-rc6&id=6457378fe796815c973f631a1904e147d6ee33b1|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/route.c?h=v5.15-rc6&id=67d6d681e15b578c1725bad8ad079e05d1c48a8e|https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv6/route.c?h=v5.15-rc6&id=a00df2caffed3883c341d5685f830434312e4a43|https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html|https://www.debian.org/security/2022/dsa-5096|https://www.oracle.com/security-alerts/cpujul2022.html|https://security.netapp.com/advisory/ntap-20220303-0002/,||||||||||||||||||||||||||,0,0,oracle/communications_cloud_native_core_policy 22.2.0,oracle/communications_cloud_native_core_policy 22.2.0,"Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a ""random enough"" number.; Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (""Approved Random Number Generators"").; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Weak Random,High,Weak Random,Information Disclosure,
CVE-2021-28099,"In Netflix OSS Hollow, since the Files.exists(parent) is run before creating the directories, an attacker can pre-create these directories with wide permissions. Additionally, since an insecure source of randomness is used, the file names to be created can be deterministically calculated.",,,0,0,0,0,,,,,,,CWE-330,Use of Insufficiently Random Values,Class,"Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a ""random enough"" number.; Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (""Approved Random Number Generators"").; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Other_Vendor,Other_Product,All versions,,,,,,4.4,1.8,2.5,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N,L,L,L,N,U,L,L,N,2,3,https://github.com/Netflix/security-bulletins/blob/master/advisories/nflx-2021-001.md|https://github.com/Netflix/security-bulletins/blob/master/advisories/nflx-2021-001.md|https://github.com/Netflix/security-bulletins/blob/master/advisories/nflx-2021-001.md,||,0,0,n/a/Netflix OSS Hollow All versions,n/a/Netflix OSS Hollow All versions,"Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a ""random enough"" number.; Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (""Approved Random Number Generators"").; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Weak Random,Medium,Weak Random,Remote Code Execution,
CVE-2022-29930,SHA1 implementation in JetBrains Ktor Native 2.0.0 was returning the same value. The issue was fixed in Ktor version 2.0.1.,,,0,0,0,0,,,,,,,CWE-330,Use of Insufficiently Random Values,Class,"Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a ""random enough"" number.; Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (""Approved Random Number Generators"").; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Other_Vendor,Other_Product,2.0.0,,,,,,8.7,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:N,N,L,H,N,C,H,H,N,6,6,https://github.com/ktorio/ktor/pull/2966|https://github.com/ktorio/ktor/pull/2966|https://www.jetbrains.com/privacy-security/issues-fixed/|https://www.jetbrains.com/privacy-security/issues-fixed/|https://www.jetbrains.com/privacy-security/issues-fixed/|https://github.com/ktorio/ktor/pull/2966,|||||,0,0,JetBrains/Ktor 2.0.0,JetBrains/Ktor 2.0.0,"Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a ""random enough"" number.; Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (""Approved Random Number Generators"").; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Weak Random,High,Weak Random,Denial of Service (DoS),
CVE-2024-20331,"A vulnerability in the session authentication functionality of the Remote Access SSL VPN feature of Cisco Adaptive Security Appliance (ASA) Software and Cisco Firepower Threat Defense (FTD) Software could allow an unauthenticated, remote attacker to prevent users from authenticating.

This vulnerability is due to insufficient entropy in the authentication process. An attacker could exploit this vulnerability by determining the handle of an authenticating user and using it to terminate their authentication session. A successful exploit could allow the attacker to force a user to restart the authentication process, preventing a legitimate user from establishing remote access VPN sessions.",,,0,0,0,0,,,,,,,CWE-330,Use of Insufficiently Random Values,Class,"Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a ""random enough"" number.; Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (""Approved Random Number Generators"").; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Cisco,Cisco Adaptive Security Appliance (ASA) Software,9.16.2.11,,,,,,6.8,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:N/A:H,N,H,N,N,C,N,N,H,1088,6,https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asa-vpn-nyH3fhp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-fmc-xss-M446vbEO|https://sec.cloudapps.cisco.com/security/center/viewErp.x?alertId=ERP-75300|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-asa-vpn-nyH3fhp|https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-fmc-xss-M446vbEO|https://sec.cloudapps.cisco.com/security/center/viewErp.x?alertId=ERP-75300,|||||,0,0,Cisco/Cisco Adaptive Security Appliance (ASA) Software 9.16.2.11,Cisco/Cisco Adaptive Security Appliance (ASA) Software 9.16.2.11,"Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a ""random enough"" number.; Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (""Approved Random Number Generators"").; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Weak Random,Medium,Weak Random,Privilege Escalation,
CVE-2022-22517,"An unauthenticated, remote attacker can disrupt existing communication channels between CODESYS products by guessing a valid channel ID and injecting packets. This results in the communication channel to be closed.",,,0,0,0,0,,,,,,,CWE-330,Use of Insufficiently Random Values,Class,"Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a ""random enough"" number.; Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (""Approved Random Number Generators"").; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Other_Vendor,Other_Product,*,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,N,L,N,N,U,N,N,H,86,3,https://customers.codesys.com/index.php?eID=dumpFile&t=f&f=17091&token=c450f8bbbd838c647d102f359356386c6ea5aeca&download=|https://customers.codesys.com/index.php?eID=dumpFile&t=f&f=17091&token=c450f8bbbd838c647d102f359356386c6ea5aeca&download=|https://customers.codesys.com/index.php?eID=dumpFile&t=f&f=17091&token=c450f8bbbd838c647d102f359356386c6ea5aeca&download=,||,0,0,codesys/remote_target_visu_toolkit *,codesys/remote_target_visu_toolkit *,"Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a ""random enough"" number.; Consider a PRNG that re-seeds itself as needed from high quality pseudo-random output sources, such as hardware devices.; Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.; Use products or modules that conform to FIPS 140-2 [REF-267] to avoid obvious entropy problems. Consult FIPS 140-2 Annex C (""Approved Random Number Generators"").; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.",Weak Random,High,Weak Random,Information Disclosure,
CVE-2023-47745,"IBM MQ Operator 2.0.0 LTS, 2.0.18 LTS, 3.0.0 CD, 3.0.1 CD, 2.4.0 through 2.4.7, 2.3.0 through 2.3.3, 2.2.0 through 2.2.2, and 2.3.0 through 2.3.3 stores or transmits user credentials in plain clear text which can be read by a local user using a trace command.  IBM X-Force ID:  272638.",,,0,0,0,0,,,,,,,CWE-319,Cleartext Transmission of Sensitive Information,Base,"Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.; When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.; When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.; Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.",IBM,Other_Product,2.2.0,,,,,,6.2,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,L,L,N,N,U,H,N,N,10,6,https://exchange.xforce.ibmcloud.com/vulnerabilities/272638|https://exchange.xforce.ibmcloud.com/vulnerabilities/272638|https://www.ibm.com/support/pages/node/7126571|https://www.ibm.com/support/pages/node/7126571|https://www.ibm.com/support/pages/node/7126571|https://exchange.xforce.ibmcloud.com/vulnerabilities/272638,|||||,0,0,IBM/MQ Operator 2.2.0,IBM/MQ Operator 2.2.0,"Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.; When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.; When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.; Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.",Cleartext Transmission,Medium,Cleartext Transmission,Remote Code Execution,
CVE-2024-8059,IPMI credentials may be captured in XCC audit log entries when the account username length is 16 characters.,,,0,0,0,0,,,,,,,CWE-319,Cleartext Transmission of Sensitive Information,Base,"Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.; When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.; When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.; Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.",Other_Vendor,Other_Product,0,,,,,,4.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N,N,L,L,N,U,L,N,N,140,2,https://support.lenovo.com/us/en/product_security/LEN-172051|https://support.lenovo.com/us/en/product_security/LEN-172051,|,0,0,Lenovo/SD530 V3 (ThinkSystem) XCC 0,Lenovo/SD530 V3 (ThinkSystem) XCC 0,"Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.; When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.; When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.; Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.",Cleartext Transmission,Medium,Cleartext Transmission,Denial of Service (DoS),
CVE-2024-8059,IPMI credentials may be captured in XCC audit log entries when the account username length is 16 characters.,,,0,0,0,0,,,,,,,CWE-319,Cleartext Transmission of Sensitive Information,Base,"Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.; When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.; When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.; Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.",Other_Vendor,Other_Product,0,,,,,,4.3,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N,N,L,L,N,U,L,N,N,140,2,https://support.lenovo.com/us/en/product_security/LEN-172051|https://support.lenovo.com/us/en/product_security/LEN-172051,|,0,0,Lenovo/VX7520 (ThinkAgile) XCC 0,Lenovo/VX7520 (ThinkAgile) XCC 0,"Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.; When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.; When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.; Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.",Cleartext Transmission,Medium,Cleartext Transmission,Privilege Escalation,
CVE-2025-3329,A vulnerability classified as problematic has been found in Consumer Comanda Mobile up to 14.9.3.2/15.0.0.8. This affects an unknown part of the component Restaurant Order Handler. The manipulation of the argument Login/Password leads to cleartext transmission of sensitive information. The attack can only be initiated within the local network. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used.,,,0,0,0,0,,,,,,,CWE-319,Cleartext Transmission of Sensitive Information,Base,"Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.; When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.; When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.; Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.",Other_Vendor,Other_Product,15.0.0.5,,,,,,3.1,,,CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N,A,H,N,N,U,L,N,N,26,10,https://medium.com/@davimouar/from-order-to-exploit-a-deep-dive-into-restaurant-network-security-64aeaf3a6f64|https://medium.com/@davimouar/from-order-to-exploit-a-deep-dive-into-restaurant-network-security-64aeaf3a6f64|https://vuldb.com/?ctiid.303543|https://vuldb.com/?id.303543|https://vuldb.com/?submit.551790|https://vuldb.com/?submit.551790|https://vuldb.com/?id.303543|https://vuldb.com/?ctiid.303543|https://vuldb.com/?submit.551790|https://medium.com/@davimouar/from-order-to-exploit-a-deep-dive-into-restaurant-network-security-64aeaf3a6f64,|||||||||,0,0,Consumer/Comanda Mobile 15.0.0.5,Consumer/Comanda Mobile 15.0.0.5,"Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.; When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.; When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.; Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.",Cleartext Transmission,Low,Cleartext Transmission,Information Disclosure,
CVE-2022-44411,"Web Based Quiz System v1.0 transmits user passwords in plaintext during the authentication process, allowing attackers to obtain users' passwords via a bruteforce attack.",,,0,0,0,0,,,,,,,CWE-319,Cleartext Transmission of Sensitive Information,Base,"Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.; When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.; When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.; Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.",Other_Vendor,Other_Product,1,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,N,L,N,N,U,H,N,N,2,3,https://shimo.im/docs/5xkGMZx0ZeUmpx3X|https://shimo.im/docs/5xkGMZx0ZeUmpx3X|https://shimo.im/docs/5xkGMZx0ZeUmpx3X,||,0,0,web_based_quiz_system_project/web_based_quiz_system 1.0,web_based_quiz_system_project/web_based_quiz_system 1.0,"Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.; When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.; When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.; Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.; Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.",Cleartext Transmission,High,Cleartext Transmission,Remote Code Execution,
CVE-2023-47364,The leakage of channel access token in nagaoka taxi Line 13.6.1 allows remote attackers to send malicious notifications to victims,,,0,0,0,0,,,,,,,CWE-326,Inadequate Encryption Strength,Class,Use an encryption scheme that is currently considered to be strong by experts in the field.,Other_Vendor,Other_Product,,,,,,,6.5,3.9,2.5,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N,N,L,N,N,U,L,L,N,2,3,https://github.com/syz913/CVE-reports/blob/main/nagaoka%20taxi.md|https://github.com/syz913/CVE-reports/blob/main/nagaoka%20taxi.md|https://github.com/syz913/CVE-reports/blob/main/nagaoka%20taxi.md,||,0,0,n/a/n/a n/a,n/a/n/a n/a,Use an encryption scheme that is currently considered to be strong by experts in the field.,Inadequate Encryption Strength,Medium,Inadequate Encryption Strength,Denial of Service (DoS),
CVE-2021-40341,"DES cipher, which has inadequate encryption strength, is used Hitachi Energy FOXMAN-UN to encrypt user credentials used to access the Network Elements. Successful exploitation allows sensitive information to be decrypted easily. This issue affects 



  *  FOXMAN-UN product: FOXMAN-UN R16A, FOXMAN-UN R15B, FOXMAN-UN R15A, FOXMAN-UN R14B, FOXMAN-UN R14A, FOXMAN-UN R11B, FOXMAN-UN R11A, FOXMAN-UN R10C, FOXMAN-UN R9C; 
  *  UNEM product: UNEM R16A, UNEM R15B, UNEM R15A, UNEM R14B, UNEM R14A, UNEM R11B, UNEM R11A, UNEM R10C, UNEM R9C.




List of CPEs: 
  *  cpe:2.3:a:hitachienergy:foxman-un:R16A:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:foxman-un:R15B:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:foxman-un:R15A:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:foxman-un:R14B:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:foxman-un:R14A:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:foxman-un:R11B:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:foxman-un:R11A:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:foxman-un:R10C:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:foxman-un:R9C:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:unem:R16A:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:unem:R15B:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:unem:R15A:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:unem:R14B:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:unem:R14A:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:unem:R11B:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:unem:R11A:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:unem:R10C:*:*:*:*:*:*:*
  *  cpe:2.3:a:hitachienergy:unem:R9C:*:*:*:*:*:*:*



",,,0,0,0,0,,,,,,,CWE-326,Inadequate Encryption Strength,Class,Use an encryption scheme that is currently considered to be strong by experts in the field.,Other_Vendor,Other_Product,r15b,,,,,,7.1,,,CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N,L,L,N,N,C,H,N,N,36,6,https://search.abb.com/library/Download.aspx?DocumentID=8DBD000083&LanguageCode=en&DocumentPartId=&Action=Launch|https://search.abb.com/library/Download.aspx?DocumentID=8DBD000083&LanguageCode=en&DocumentPartId=&Action=Launch|https://search.abb.com/library/Download.aspx?DocumentID=8DBD000084&LanguageCode=en&DocumentPartId=&Action=Launch|https://search.abb.com/library/Download.aspx?DocumentID=8DBD000084&LanguageCode=en&DocumentPartId=&Action=Launch|https://search.abb.com/library/Download.aspx?DocumentID=8DBD000083&LanguageCode=en&DocumentPartId=&Action=Launch|https://search.abb.com/library/Download.aspx?DocumentID=8DBD000084&LanguageCode=en&DocumentPartId=&Action=Launch,|||||,0,0,hitachienergy/unem r15b,hitachienergy/unem r15b,Use an encryption scheme that is currently considered to be strong by experts in the field.,Inadequate Encryption Strength,High,Inadequate Encryption Strength,Privilege Escalation,
CVE-2021-37209,"A vulnerability has been identified in RUGGEDCOM i800 (All versions < V4.3.8), RUGGEDCOM i801 (All versions < V4.3.8), RUGGEDCOM i802 (All versions < V4.3.8), RUGGEDCOM i803 (All versions < V4.3.8), RUGGEDCOM M2100 (All versions < V4.3.8), RUGGEDCOM M2200 (All versions < V4.3.8), RUGGEDCOM M969 (All versions < V4.3.8), RUGGEDCOM RMC30 (All versions < V4.3.8), RUGGEDCOM RMC8388 V4.X (All versions < V4.3.8), RUGGEDCOM RMC8388 V5.X (All versions < V5.7.0), RUGGEDCOM RP110 (All versions < V4.3.8), RUGGEDCOM RS1600 (All versions < V4.3.8), RUGGEDCOM RS1600F (All versions < V4.3.8), RUGGEDCOM RS1600T (All versions < V4.3.8), RUGGEDCOM RS400 (All versions < V4.3.8), RUGGEDCOM RS401 (All versions < V4.3.8), RUGGEDCOM RS416 (All versions < V4.3.8), RUGGEDCOM RS416P (All versions < V4.3.8), RUGGEDCOM RS416Pv2 V4.X (All versions < V4.3.8), RUGGEDCOM RS416Pv2 V5.X (All versions < V5.7.0), RUGGEDCOM RS416v2 V4.X (All versions < V4.3.8), RUGGEDCOM RS416v2 V5.X (All versions < V5.7.0), RUGGEDCOM RS8000 (All versions < V4.3.8), RUGGEDCOM RS8000A (All versions < V4.3.8), RUGGEDCOM RS8000H (All versions < V4.3.8), RUGGEDCOM RS8000T (All versions < V4.3.8), RUGGEDCOM RS900 (All versions < V4.3.8), RUGGEDCOM RS900 (32M) V4.X (All versions < V4.3.8), RUGGEDCOM RS900 (32M) V5.X (All versions < V5.7.0), RUGGEDCOM RS900G (All versions < V4.3.8), RUGGEDCOM RS900G (32M) V4.X (All versions < V4.3.8), RUGGEDCOM RS900G (32M) V5.X (All versions < V5.7.0), RUGGEDCOM RS900GP (All versions < V4.3.8), RUGGEDCOM RS900L (All versions < V4.3.8), RUGGEDCOM RS900M-GETS-C01 (All versions < V4.3.8), RUGGEDCOM RS900M-GETS-XX (All versions < V4.3.8), RUGGEDCOM RS900M-STND-C01 (All versions < V4.3.8), RUGGEDCOM RS900M-STND-XX (All versions < V4.3.8), RUGGEDCOM RS900W (All versions < V4.3.8), RUGGEDCOM RS910 (All versions < V4.3.8), RUGGEDCOM RS910L (All versions < V4.3.8), RUGGEDCOM RS910W (All versions < V4.3.8), RUGGEDCOM RS920L (All versions < V4.3.8), RUGGEDCOM RS920W (All versions < V4.3.8), RUGGEDCOM RS930L (All versions < V4.3.8), RUGGEDCOM RS930W (All versions < V4.3.8), RUGGEDCOM RS940G (All versions < V4.3.8), RUGGEDCOM RS969 (All versions < V4.3.8), RUGGEDCOM RSG2100 (All versions < V4.3.8), RUGGEDCOM RSG2100 (32M) V4.X (All versions < V4.3.8), RUGGEDCOM RSG2100 (32M) V5.X (All versions < V5.7.0), RUGGEDCOM RSG2100P (All versions < V4.3.8), RUGGEDCOM RSG2200 (All versions < V4.3.8), RUGGEDCOM RSG2288 V4.X (All versions < V4.3.8), RUGGEDCOM RSG2288 V5.X (All versions < V5.7.0), RUGGEDCOM RSG2300 V4.X (All versions < V4.3.8), RUGGEDCOM RSG2300 V5.X (All versions < V5.7.0), RUGGEDCOM RSG2300P V4.X (All versions < V4.3.8), RUGGEDCOM RSG2300P V5.X (All versions < V5.7.0), RUGGEDCOM RSG2488 V4.X (All versions < V4.3.8), RUGGEDCOM RSG2488 V5.X (All versions < V5.7.0), RUGGEDCOM RSG907R (All versions < V5.7.0), RUGGEDCOM RSG908C (All versions < V5.7.0), RUGGEDCOM RSG909R (All versions < V5.7.0), RUGGEDCOM RSG910C (All versions < V5.7.0), RUGGEDCOM RSG920P V4.X (All versions < V4.3.8), RUGGEDCOM RSG920P V5.X (All versions < V5.7.0), RUGGEDCOM RSL910 (All versions < V5.7.0), RUGGEDCOM RST2228 (All versions < V5.7.0), RUGGEDCOM RST2228P (All versions < V5.7.0), RUGGEDCOM RST916C (All versions < V5.7.0), RUGGEDCOM RST916P (All versions < V5.7.0). The SSH server on affected devices is configured to offer weak ciphers by default.

This could allow an unauthorized attacker in a man-in-the-middle position to read and modify any data passed over the connection between legitimate clients and the affected device.",,,0,0,0,0,,,,,,,CWE-326,Inadequate Encryption Strength,Class,Use an encryption scheme that is currently considered to be strong by experts in the field.,Siemens,Other_Product,All versions < V4.3.8,,,,,,6.7,,,CVSS:3.1/AV:A/AC:H/PR:N/UI:R/S:U/C:L/I:H/A:H/E:P/RL:U/RC:C,A,H,N,R,U,L,H,H,72,3,https://cert-portal.siemens.com/productcert/pdf/ssa-764417.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-764417.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-764417.pdf,||,0,0,Siemens/RUGGEDCOM RMC30 All versions < V4.3.8,Siemens/RUGGEDCOM RMC30 All versions < V4.3.8,Use an encryption scheme that is currently considered to be strong by experts in the field.,Inadequate Encryption Strength,Medium,Inadequate Encryption Strength,Information Disclosure,
CVE-2021-38984,"IBM Tivoli Key Lifecycle Manager 3.0, 3.0.1, 4.0, and 4.1 uses weaker than expected cryptographic algorithms that could allow an attacker to decrypt highly sensitive information. IBM X-Force ID: 212793.",,,0,0,0,0,,,,,,,CWE-326,Inadequate Encryption Strength,Class,Use an encryption scheme that is currently considered to be strong by experts in the field.,IBM,Other_Product,4.1,,,,,,3.7,,,CVSS:3.0/UI:N/C:L/AV:N/PR:N/I:N/S:U/A:N/AC:H/E:U/RL:O/RC:C,N,H,N,N,U,L,N,N,12,6,https://exchange.xforce.ibmcloud.com/vulnerabilities/212793|https://exchange.xforce.ibmcloud.com/vulnerabilities/212793|https://www.ibm.com/support/pages/node/6516032|https://www.ibm.com/support/pages/node/6516032|https://www.ibm.com/support/pages/node/6516032|https://exchange.xforce.ibmcloud.com/vulnerabilities/212793,|||||,0,0,IBM/Security Key Lifecycle Manager 4.1,IBM/Security Key Lifecycle Manager 4.1,Use an encryption scheme that is currently considered to be strong by experts in the field.,Inadequate Encryption Strength,Low,Inadequate Encryption Strength,Remote Code Execution,
CVE-2022-29161,"XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. The XWiki Crypto API will generate X509 certificates signed by default using SHA1 with RSA, which is not considered safe anymore for use in certificate signatures, due to the risk of collisions with SHA1. The problem has been patched in XWiki version 13.10.6, 14.3.1 and 14.4-rc-1. Since then, the Crypto API will generate X509 certificates signed by default using SHA256 with RSA. Administrators are advised to upgrade their XWiki installation to one of the patched versions. If the upgrade is not possible, it is possible to patch the module xwiki-platform-crypto in a local installation by applying the change exposed in 26728f3 and re-compiling the module.",,,0,0,0,0,,,,,,,CWE-326,Inadequate Encryption Strength,Class,Use an encryption scheme that is currently considered to be strong by experts in the field.,Other_Vendor,Other_Product,*,,,,,,5.4,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N,N,H,N,N,C,L,L,N,8,9,https://github.com/xwiki/xwiki-platform/commit/26728f3f23658288683667a5182a916c7ecefc52|https://github.com/xwiki/xwiki-platform/commit/26728f3f23658288683667a5182a916c7ecefc52|https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-h8v5-p258-pqf4|https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-h8v5-p258-pqf4|https://jira.xwiki.org/browse/XWIKI-19676|https://jira.xwiki.org/browse/XWIKI-19676|https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-h8v5-p258-pqf4|https://github.com/xwiki/xwiki-platform/commit/26728f3f23658288683667a5182a916c7ecefc52|https://jira.xwiki.org/browse/XWIKI-19676,||||||||,0,0,xwiki/xwiki *,xwiki/xwiki *,Use an encryption scheme that is currently considered to be strong by experts in the field.,Inadequate Encryption Strength,Medium,Inadequate Encryption Strength,Denial of Service (DoS),
CVE-2024-24823,"Graylog is a free and open log management platform. Starting in version 4.3.0 and prior to versions 5.1.11 and 5.2.4, reauthenticating with an existing session cookie would re-use that session id, even if for different user credentials. In this case, the pre-existing session could be used to gain elevated access to an existing Graylog login session, provided the malicious user could successfully inject their session cookie into someone else's browser. The complexity of such an attack is high, because it requires presenting a spoofed login screen and injection of a session cookie into an existing browser, potentially through a cross-site scripting attack. No such attack has been discovered. Graylog 5.1.11 and 5.2.4, and any versions of the 6.0 development branch, contain patches to not re-use sessions under any circumstances. Some workarounds are available. Using short session expiration and explicit log outs of unused sessions can help limiting the attack vector. Unpatched this vulnerability exists, but is relatively hard to exploit. A proxy could be leveraged to clear the `authentication` cookie for the Graylog server URL for the `/api/system/sessions` endpoint, as that is the only one vulnerable.",,,0,0,0,0,,,,,,,CWE-384,Session Fixation,Compound,"Invalidate any existing session identifiers prior to authorizing a new user session.; For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.",Other_Vendor,Other_Product,">= 5.2.0, < 5.2.4",,,,,,5.7,,,CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:H/I:H/A:N,N,H,H,R,U,H,H,N,3,9,https://github.com/Graylog2/graylog2-server/commit/1596b749db86368ba476662f23a0f0c5ec2b5097|https://github.com/Graylog2/graylog2-server/commit/1596b749db86368ba476662f23a0f0c5ec2b5097|https://github.com/Graylog2/graylog2-server/commit/b93a66353f35a94a4e8f3f75ac4f5cdc5a2d4a6a|https://github.com/Graylog2/graylog2-server/commit/b93a66353f35a94a4e8f3f75ac4f5cdc5a2d4a6a|https://github.com/Graylog2/graylog2-server/security/advisories/GHSA-3xf8-g8gr-g7rh|https://github.com/Graylog2/graylog2-server/security/advisories/GHSA-3xf8-g8gr-g7rh|https://github.com/Graylog2/graylog2-server/security/advisories/GHSA-3xf8-g8gr-g7rh|https://github.com/Graylog2/graylog2-server/commit/1596b749db86368ba476662f23a0f0c5ec2b5097|https://github.com/Graylog2/graylog2-server/commit/b93a66353f35a94a4e8f3f75ac4f5cdc5a2d4a6a,||||||||,0,0,"Graylog2/graylog2-server >= 5.2.0, < 5.2.4","Graylog2/graylog2-server >= 5.2.0, < 5.2.4","Invalidate any existing session identifiers prior to authorizing a new user session.; For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.",Session Fixation,Medium,Session Fixation,Privilege Escalation,
CVE-2021-42761,"A condition for session fixation vulnerability [CWE-384] in the session management of FortiWeb versions 6.4 all versions, 6.3.0 through 6.3.16, 6.2.0 through 6.2.6, 6.1.0 through 6.1.2, 6.0.0 through 6.0.7, 5.9.0 through 5.9.1 may allow a remote, unauthenticated attacker to infer the session identifier of other users and possibly usurp their session.",,,0,0,0,0,,,,,,,CWE-384,Session Fixation,Compound,"Invalidate any existing session identifiers prior to authorizing a new user session.; For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.",Fortinet,Other_Product,6.4.0,,,,,,8.5,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H/E:P/RL:U/RC:C,N,H,N,N,C,H,H,H,11,3,https://fortiguard.com/psirt/FG-IR-21-214|https://fortiguard.com/psirt/FG-IR-21-214|https://fortiguard.com/psirt/FG-IR-21-214,||,0,0,Fortinet/FortiWeb 6.4.0,Fortinet/FortiWeb 6.4.0,"Invalidate any existing session identifiers prior to authorizing a new user session.; For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.",Session Fixation,High,Session Fixation,Information Disclosure,
CVE-2024-23193,E-Mails exported as PDF were stored in a cache that did not consider specific session information for the related user account. Users of the same service node could access other users E-Mails in case they were exported as PDF for a brief moment until caches were cleared. Successful exploitation requires good timing and modification of multiple request parameters. Please deploy the provided updates and patch releases. The cache for PDF exports now takes user session information into consideration when performing authorization decisions. No publicly available exploits are known.,,,0,0,0,0,,,,,,,CWE-384,Session Fixation,Compound,"Invalidate any existing session identifiers prior to authorizing a new user session.; For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.",Other_Vendor,Other_Product,0,,,,,,5.3,,,CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N,N,H,L,N,U,H,N,N,4,9,http://seclists.org/fulldisclosure/2024/May/3|http://seclists.org/fulldisclosure/2024/May/3|https://documentation.open-xchange.com/appsuite/releases/8.22/|https://documentation.open-xchange.com/appsuite/releases/8.22/|https://documentation.open-xchange.com/appsuite/security/advisories/csaf/2024/oxas-adv-2024-0002.json|https://documentation.open-xchange.com/appsuite/security/advisories/csaf/2024/oxas-adv-2024-0002.json|https://documentation.open-xchange.com/appsuite/releases/8.22/|https://documentation.open-xchange.com/appsuite/security/advisories/csaf/2024/oxas-adv-2024-0002.json|http://seclists.org/fulldisclosure/2024/May/3,||||||||,0,0,Open-Xchange GmbH/OX App Suite 0,Open-Xchange GmbH/OX App Suite 0,"Invalidate any existing session identifiers prior to authorizing a new user session.; For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.",Session Fixation,Medium,Session Fixation,Remote Code Execution,
CVE-2022-31888,Session Fixation vulnerability in in function login in class.auth.php in osTicket through 1.16.2.,,,0,0,0,0,,,,,,,CWE-384,Session Fixation,Compound,"Invalidate any existing session identifiers prior to authorizing a new user session.; For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.",Other_Vendor,Other_Product,*,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,N,L,N,R,U,H,H,H,2,9,https://checkmarx.com/blog/securing-open-source-solutions-a-study-of-osticket-vulnerabilities/|https://checkmarx.com/blog/securing-open-source-solutions-a-study-of-osticket-vulnerabilities/|https://github.com/osTicket/osTicket/commit/85a76f403a3a116176d0798f39a4c430181d8364|https://github.com/osTicket/osTicket/commit/85a76f403a3a116176d0798f39a4c430181d8364|https://github.com/osTicket/osTicket/releases/tag/v1.16.3|https://github.com/osTicket/osTicket/releases/tag/v1.16.3|https://github.com/osTicket/osTicket/releases/tag/v1.16.3|https://github.com/osTicket/osTicket/commit/85a76f403a3a116176d0798f39a4c430181d8364|https://checkmarx.com/blog/securing-open-source-solutions-a-study-of-osticket-vulnerabilities/,||||||||,0,0,enhancesoft/osticket *,enhancesoft/osticket *,"Invalidate any existing session identifiers prior to authorizing a new user session.; For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.",Session Fixation,High,Session Fixation,Denial of Service (DoS),
CVE-2021-2351,"Vulnerability in the Advanced Networking Option component of Oracle Database Server. Supported versions that are affected are 12.1.0.2, 12.2.0.1 and 19c. Difficult to exploit vulnerability allows unauthenticated attacker with network access via Oracle Net to compromise Advanced Networking Option. Successful attacks require human interaction from a person other than the attacker and while the vulnerability is in Advanced Networking Option, attacks may significantly impact additional products. Successful attacks of this vulnerability can result in takeover of Advanced Networking Option. Note: The July 2021 Critical Patch Update introduces a number of Native Network Encryption changes to deal with vulnerability CVE-2021-2351 and prevent the use of weaker ciphers. Customers should review: ""Changes in Native Network Encryption with the July 2021 Critical Patch Update"" (Doc ID 2791571.1). CVSS 3.1 Base Score 8.3 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H).",,,0,0,0,0,,,,,,,CWE-384,Session Fixation,Compound,"Invalidate any existing session identifiers prior to authorizing a new user session.; For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.",oracle,Other_Product,*,,,,,,8.3,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H,N,H,N,R,C,H,H,H,478,30,http://packetstormsecurity.com/files/165255/Oracle-Database-Protection-Mechanism-Bypass.html|http://packetstormsecurity.com/files/165255/Oracle-Database-Protection-Mechanism-Bypass.html|http://packetstormsecurity.com/files/165258/Oracle-Database-Weak-NNE-Integrity-Key-Derivation.html|http://packetstormsecurity.com/files/165258/Oracle-Database-Weak-NNE-Integrity-Key-Derivation.html|http://seclists.org/fulldisclosure/2021/Dec/19|http://seclists.org/fulldisclosure/2021/Dec/19|http://seclists.org/fulldisclosure/2021/Dec/20|http://seclists.org/fulldisclosure/2021/Dec/20|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpujan2022.html|https://www.oracle.com/security-alerts/cpujan2022.html|https://www.oracle.com/security-alerts/cpujan2023.html|https://www.oracle.com/security-alerts/cpujan2023.html|https://www.oracle.com/security-alerts/cpujul2021.html|https://www.oracle.com/security-alerts/cpujul2021.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpuoct2021.html|https://www.oracle.com/security-alerts/cpuoct2021.html|https://www.oracle.com/security-alerts/cpujul2021.html|https://www.oracle.com/security-alerts/cpuoct2021.html|http://seclists.org/fulldisclosure/2021/Dec/19|http://seclists.org/fulldisclosure/2021/Dec/20|https://www.oracle.com/security-alerts/cpujan2022.html|http://packetstormsecurity.com/files/165258/Oracle-Database-Weak-NNE-Integrity-Key-Derivation.html|http://packetstormsecurity.com/files/165255/Oracle-Database-Protection-Mechanism-Bypass.html|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujan2023.html,|||||||||||||||||||||||||||||,0,0,oracle/policy_automation *,oracle/policy_automation *,"Invalidate any existing session identifiers prior to authorizing a new user session.; For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.",Session Fixation,High,Session Fixation,Privilege Escalation,
CVE-2021-45046,"It was found that the fix to address CVE-2021-44228 in Apache Log4j 2.15.0 was incomplete in certain non-default configurations. This could allows attackers with control over Thread Context Map (MDC) input data when the logging configuration uses a non-default Pattern Layout with either a Context Lookup (for example, $${ctx:loginId}) or a Thread Context Map pattern (%X, %mdc, or %MDC) to craft malicious input data using a JNDI Lookup pattern resulting in an information leak and remote code execution in some environments and local code execution in all environments. Log4j 2.16.0 (Java 8) and 2.12.2 (Java 7) fix this issue by removing support for message lookup patterns and disabling JNDI functionality by default.",,,0,0,0,0,,,,,,,CWE-917,Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection'),Base,"Avoid adding user-controlled data into an expression interpreter when possible.; If user-controlled data must be added to an expression interpreter, one or more of the following should be performed:
                     
                        Validate that the user input will not evaluate as an expression
                        Encode the user input in a way that ensures it is not evaluated as an expression; The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to ""true"".",siemens,Other_Product,3.8,,,,,,9,,,CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H,N,H,N,N,C,H,H,H,72,63,http://www.openwall.com/lists/oss-security/2021/12/14/4|http://www.openwall.com/lists/oss-security/2021/12/15/3|http://www.openwall.com/lists/oss-security/2021/12/18/1|https://cert-portal.siemens.com/productcert/pdf/ssa-397453.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-479842.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-661247.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-714170.pdf|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/EOKPQGV24RRBBI4TBZUDQMM4MEH7MXCY/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SIG7FZULMNK2XF6FZRU4VWYDQXNMUGAJ/|https://logging.apache.org/log4j/2.x/security.html|https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2021-0032|https://security.gentoo.org/glsa/202310-16|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-apache-log4j-qRuKNEbd|https://www.cve.org/CVERecord?id=CVE-2021-44228|https://www.debian.org/security/2021/dsa-5022|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00646.html|https://www.kb.cert.org/vuls/id/930724|https://www.oracle.com/security-alerts/alert-cve-2021-44228.html|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpujan2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|http://www.openwall.com/lists/oss-security/2021/12/14/4|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujan2022.html|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/alert-cve-2021-44228.html|https://www.kb.cert.org/vuls/id/930724|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00646.html|https://www.debian.org/security/2021/dsa-5022|https://www.cve.org/CVERecord?id=CVE-2021-44228|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-apache-log4j-qRuKNEbd|https://security.gentoo.org/glsa/202310-16|https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2021-0032|https://logging.apache.org/log4j/2.x/security.html|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SIG7FZULMNK2XF6FZRU4VWYDQXNMUGAJ/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/EOKPQGV24RRBBI4TBZUDQMM4MEH7MXCY/|https://cert-portal.siemens.com/productcert/pdf/ssa-714170.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-661247.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-479842.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-397453.pdf|http://www.openwall.com/lists/oss-security/2021/12/18/1|http://www.openwall.com/lists/oss-security/2021/12/15/3|https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2021-0032|https://www.oracle.com/security-alerts/alert-cve-2021-44228.html|https://www.cve.org/CVERecord?id=CVE-2021-44228|http://www.openwall.com/lists/oss-security/2021/12/14/4|https://logging.apache.org/log4j/2.x/security.html|https://www.kb.cert.org/vuls/id/930724|https://cert-portal.siemens.com/productcert/pdf/ssa-661247.pdf|https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00646.html|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-apache-log4j-qRuKNEbd|http://www.openwall.com/lists/oss-security/2021/12/15/3|https://cert-portal.siemens.com/productcert/pdf/ssa-714170.pdf|https://www.debian.org/security/2021/dsa-5022|http://www.openwall.com/lists/oss-security/2021/12/18/1|https://cert-portal.siemens.com/productcert/pdf/ssa-397453.pdf|https://cert-portal.siemens.com/productcert/pdf/ssa-479842.pdf|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/EOKPQGV24RRBBI4TBZUDQMM4MEH7MXCY/|https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SIG7FZULMNK2XF6FZRU4VWYDQXNMUGAJ/|https://www.oracle.com/security-alerts/cpujan2022.html|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://security.gentoo.org/glsa/202310-16,||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||,0,0,siemens/energyip_prepay 3.8,siemens/energyip_prepay 3.8,"Avoid adding user-controlled data into an expression interpreter when possible.; If user-controlled data must be added to an expression interpreter, one or more of the following should be performed:
                     
                        Validate that the user input will not evaluate as an expression
                        Encode the user input in a way that ensures it is not evaluated as an expression; The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to ""true"".",Expression Language Injection,Critical,Expression Language Injection,Information Disclosure,
CVE-2023-42658,"
Archive command in Chef InSpec prior to 4.56.58 and 5.22.29 allow local command execution via maliciously crafted profile.",,,0,0,0,0,,,,,,,CWE-917,Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection'),Base,"Avoid adding user-controlled data into an expression interpreter when possible.; If user-controlled data must be added to an expression interpreter, one or more of the following should be performed:
                     
                        Validate that the user input will not evaluate as an expression
                        Encode the user input in a way that ensures it is not evaluated as an expression; The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to ""true"".",Other_Vendor,Other_Product,4.0.0,,,,,,8.8,,,CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H,L,L,L,N,C,H,H,H,6,9,https://community.progress.com/s/article/Product-Alert-Bulletin-October-2023-CHEF-Inspec-CVE-2023-42658|https://community.progress.com/s/article/Product-Alert-Bulletin-October-2023-CHEF-Inspec-CVE-2023-42658|https://docs.chef.io/inspec/cli/|https://docs.chef.io/inspec/cli/|https://docs.chef.io/release_notes_inspec/|https://docs.chef.io/release_notes_inspec/|https://docs.chef.io/release_notes_inspec/|https://docs.chef.io/inspec/cli/|https://community.progress.com/s/article/Product-Alert-Bulletin-October-2023-CHEF-Inspec-CVE-2023-42658,||||||||,0,0,Progress Software Corporation/Chef InSpec 4.0.0,Progress Software Corporation/Chef InSpec 4.0.0,"Avoid adding user-controlled data into an expression interpreter when possible.; If user-controlled data must be added to an expression interpreter, one or more of the following should be performed:
                     
                        Validate that the user input will not evaluate as an expression
                        Encode the user input in a way that ensures it is not evaluated as an expression; The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to ""true"".",Expression Language Injection,High,Expression Language Injection,Remote Code Execution,
CVE-2024-9672,A reflected cross-site scripting (XSS) vulnerability exists in PaperCut NG/MF. This issue can be used to execute specially created JavaScript payloads in the browser. A user must click on a malicious link for this issue to occur.,,,0,0,0,0,,,,,,,CWE-917,Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection'),Base,"Avoid adding user-controlled data into an expression interpreter when possible.; If user-controlled data must be added to an expression interpreter, one or more of the following should be performed:
                     
                        Validate that the user input will not evaluate as an expression
                        Encode the user input in a way that ensures it is not evaluated as an expression; The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to ""true"".",Other_Vendor,Other_Product,*,,,,,,5.4,2.3,2.7,CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N,N,L,L,R,C,L,L,N,6,2,https://www.papercut.com/kb/Main/security-bulletin-december-2024/|https://www.papercut.com/kb/Main/security-bulletin-december-2024/,|,0,0,papercut/papercut_mf *,papercut/papercut_mf *,"Avoid adding user-controlled data into an expression interpreter when possible.; If user-controlled data must be added to an expression interpreter, one or more of the following should be performed:
                     
                        Validate that the user input will not evaluate as an expression
                        Encode the user input in a way that ensures it is not evaluated as an expression; The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to ""true"".",Expression Language Injection,Medium,Expression Language Injection,Denial of Service (DoS),
CVE-2021-26084,"In affected versions of Confluence Server and Data Center, an OGNL injection vulnerability exists that would allow an unauthenticated attacker to execute arbitrary code on a Confluence Server or Data Center instance. The affected versions are before version 6.13.23, from version 6.14.0 before 7.4.11, from version 7.5.0 before 7.11.6, and from version 7.12.0 before 7.12.5.",,,0,0,0,0,,,,,,,CWE-917,Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection'),Base,"Avoid adding user-controlled data into an expression interpreter when possible.; If user-controlled data must be added to an expression interpreter, one or more of the following should be performed:
                     
                        Validate that the user input will not evaluate as an expression
                        Encode the user input in a way that ensures it is not evaluated as an expression; The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to ""true"".",Other_Vendor,Other_Product,7.12.0,,,,,,9.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,N,L,N,N,U,H,H,H,10,6,http://packetstormsecurity.com/files/167449/Atlassian-Confluence-Namespace-OGNL-Injection.html|http://packetstormsecurity.com/files/167449/Atlassian-Confluence-Namespace-OGNL-Injection.html|https://jira.atlassian.com/browse/CONFSERVER-67940|https://jira.atlassian.com/browse/CONFSERVER-67940|https://jira.atlassian.com/browse/CONFSERVER-67940|http://packetstormsecurity.com/files/167449/Atlassian-Confluence-Namespace-OGNL-Injection.html,|||||,0,0,Atlassian/Confluence Data Center 7.12.0,Atlassian/Confluence Data Center 7.12.0,"Avoid adding user-controlled data into an expression interpreter when possible.; If user-controlled data must be added to an expression interpreter, one or more of the following should be performed:
                     
                        Validate that the user input will not evaluate as an expression
                        Encode the user input in a way that ensures it is not evaluated as an expression; The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to ""true"".",Expression Language Injection,Critical,Expression Language Injection,Privilege Escalation,
CVE-2022-22963,"In Spring Cloud Function versions 3.1.6, 3.2.2 and older unsupported versions, when using routing functionality it is possible for a user to provide a specially crafted SpEL as a routing-expression that may result in remote code execution and access to local resources.",,,0,0,0,0,,,,,,,CWE-917,Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection'),Base,"Avoid adding user-controlled data into an expression interpreter when possible.; If user-controlled data must be added to an expression interpreter, one or more of the following should be performed:
                     
                        Validate that the user input will not evaluate as an expression
                        Encode the user input in a way that ensures it is not evaluated as an expression; The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to ""true"".",oracle,Other_Product,22.1.0,,,,,,9.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,N,L,N,N,U,H,H,H,94,18,http://packetstormsecurity.com/files/173430/Spring-Cloud-3.2.2-Remote-Command-Execution.html|http://packetstormsecurity.com/files/173430/Spring-Cloud-3.2.2-Remote-Command-Execution.html|https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2022-0005|https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2022-0005|https://tanzu.vmware.com/security/cve-2022-22963|https://tanzu.vmware.com/security/cve-2022-22963|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-java-spring-scf-rce-DQrHhJxH|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-java-spring-scf-rce-DQrHhJxH|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpuapr2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://www.oracle.com/security-alerts/cpujul2022.html|https://tanzu.vmware.com/security/cve-2022-22963|https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-java-spring-scf-rce-DQrHhJxH|https://www.oracle.com/security-alerts/cpuapr2022.html|https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2022-0005|https://www.oracle.com/security-alerts/cpujul2022.html|http://packetstormsecurity.com/files/173430/Spring-Cloud-3.2.2-Remote-Command-Execution.html,|||||||||||||||||,0,0,oracle/communications_cloud_native_core_network_slice_selection_function 22.1.0,oracle/communications_cloud_native_core_network_slice_selection_function 22.1.0,"Avoid adding user-controlled data into an expression interpreter when possible.; If user-controlled data must be added to an expression interpreter, one or more of the following should be performed:
                     
                        Validate that the user input will not evaluate as an expression
                        Encode the user input in a way that ensures it is not evaluated as an expression; The framework or tooling might allow the developer to disable or deactivate the processing of EL expressions, such as setting the isELIgnored attribute for a JSP page to ""true"".",Expression Language Injection,Critical,Expression Language Injection,Information Disclosure,
CVE-2022-22244,"An XPath Injection vulnerability in the J-Web component of Juniper Networks Junos OS allows an unauthenticated attacker sending a crafted POST to reach the XPath channel, which may allow chaining to other unspecified vulnerabilities, leading to a partial loss of confidentiality. This issue affects Juniper Networks Junos OS: all versions prior to 19.1R3-S9; 19.2 versions prior to 19.2R3-S6; 19.3 versions prior to 19.3R3-S7; 19.4 versions prior to 19.4R3-S9; 20.1 versions prior to 20.1R3-S5; 20.2 versions prior to 20.2R3-S5; 20.3 versions prior to 20.3R3-S5; 20.4 versions prior to 20.4R3-S4; 21.1 versions prior to 21.1R3-S3; 21.2 versions prior to 21.2R3-S1; 21.3 versions prior to 21.3R3; 21.4 versions prior to 21.4R1-S2, 21.4R2; 22.1 versions prior to 22.1R1-S1, 22.1R2.",,,0,0,0,0,,,,,,,CWE-91,XML Injection (aka Blind XPath Injection),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.",juniper,junos,22.1,,,,,,5.3,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N,N,L,N,N,U,L,N,N,27,3,https://kb.juniper.net/JSA69899|https://kb.juniper.net/JSA69899|https://kb.juniper.net/JSA69899,||,0,0,juniper/junos 22.1,juniper/junos 22.1,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.",XML Injection,Medium,XML Injection,Remote Code Execution,
CVE-2024-53674,An XML external entity injection (XXE) vulnerability in HPE Insight Remote Support may allow remote users to disclose information in certain cases.,,,0,0,0,0,,,,,,,CWE-91,XML Injection (aka Blind XPath Injection),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.",Other_Vendor,Other_Product,0,,,,,,7.3,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L,N,L,N,N,U,L,L,L,4,2,https://support.hpe.com/hpesc/public/docDisplay?docLocale=en_US&docId=hpesbgn04731en_us|https://support.hpe.com/hpesc/public/docDisplay?docLocale=en_US&docId=hpesbgn04731en_us,|,0,0,Hewlett Packard Enterprise (HPE)/HPE Insight Remote Support 0,Hewlett Packard Enterprise (HPE)/HPE Insight Remote Support 0,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.",XML Injection,High,XML Injection,Denial of Service (DoS),
CVE-2022-34253,"Adobe Commerce versions 2.4.3-p2 (and earlier), 2.3.7-p3 (and earlier) and 2.4.4 (and earlier) are affected by an XML Injection vulnerability in the Widgets Module. An attacker with admin privileges can trigger a specially crafted script to achieve remote code execution. Exploitation of this issue does not require user interaction.",,,0,0,0,0,,,,,,,CWE-91,XML Injection (aka Blind XPath Injection),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.",adobe,commerce,2.4.3,,,,,,9.1,,,CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H,N,L,H,N,C,H,H,H,9,3,https://helpx.adobe.com/security/products/magento/apsb22-38.html|https://helpx.adobe.com/security/products/magento/apsb22-38.html|https://helpx.adobe.com/security/products/magento/apsb22-38.html,||,0,0,adobe/commerce 2.4.3,adobe/commerce 2.4.3,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.",XML Injection,Critical,XML Injection,Privilege Escalation,
CVE-2023-38207,"Adobe Commerce versions 2.4.6-p1 (and earlier), 2.4.5-p3 (and earlier) and 2.4.4-p4 (and earlier) are affected by a XML Injection (aka Blind XPath Injection) vulnerability that could lead in minor arbitrary file system read. Exploitation of this issue does not require user interaction.",,,0,0,0,0,,,,,,,CWE-91,XML Injection (aka Blind XPath Injection),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.",adobe,commerce,2.4.6,,,,,,7.5,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,N,L,N,N,U,H,N,N,5,3,https://helpx.adobe.com/security/products/magento/apsb23-42.html|https://helpx.adobe.com/security/products/magento/apsb23-42.html|https://helpx.adobe.com/security/products/magento/apsb23-42.html,||,0,0,adobe/commerce 2.4.6,adobe/commerce 2.4.6,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.",XML Injection,High,XML Injection,Information Disclosure,
CVE-2021-2322,"Vulnerability in OpenGrok (component: Web App). Versions that are affected are 1.6.7 and prior. Easily exploitable vulnerability allows low privileged attacker with network access via HTTPS to compromise OpenGrok. Successful attacks of this vulnerability can result in takeover of OpenGrok. CVSS 3.1 Base Score 8.8 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H).",,,0,0,0,0,,,,,,,CWE-91,XML Injection (aka Blind XPath Injection),Base,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.",Oracle Corporation,Other_Product,1.6.7 and prior,,,,,,8.8,,,CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,N,L,L,N,U,H,H,H,2,3,https://www.oracle.com/security-alerts/oracle-open-source-cves-outside-other-oracle-public-documents.html|https://www.oracle.com/security-alerts/oracle-open-source-cves-outside-other-oracle-public-documents.html|https://www.oracle.com/security-alerts/oracle-open-source-cves-outside-other-oracle-public-documents.html,||,0,0,Oracle Corporation/OpenGrok 1.6.7 and prior,Oracle Corporation/OpenGrok 1.6.7 and prior,"Assume all input is malicious. Use an ""accept known good"" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.
                  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, ""boat"" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as ""red"" or ""blue.""
                  Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.",XML Injection,High,XML Injection,Remote Code Execution,
CVE-2021-21253,"OnlineVotingSystem is an open source project hosted on GitHub. OnlineVotingSystem before version 1.1.2 hashes user passwords without a salt, which is vulnerable to dictionary attacks. Therefore there is a threat of security breach in the voting system. Without a salt, it is much easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables to crack passwords. This problem is fixed and published in version 1.1.2. A long randomly generated salt is added to the password hash function to better protect passwords stored in the voting system.",,,0,0,0,0,,,,,,,CWE-759,Use of a One-Way Hash without a Salt,Variant,"Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (""stretching"") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.
                  Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.
                  Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.; If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Other_Vendor,Other_Product,*,,,,,,5.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:N,N,L,N,N,C,L,N,N,4,6,https://github.com/dbijaya/OnlineVotingSystem/commit/0181cb0272857696c8eb3e44fcf6cb014ff90f09|https://github.com/dbijaya/OnlineVotingSystem/commit/0181cb0272857696c8eb3e44fcf6cb014ff90f09|https://github.com/dbijaya/OnlineVotingSystem/security/advisories/GHSA-wwg8-372v-v332|https://github.com/dbijaya/OnlineVotingSystem/security/advisories/GHSA-wwg8-372v-v332|https://github.com/dbijaya/OnlineVotingSystem/security/advisories/GHSA-wwg8-372v-v332|https://github.com/dbijaya/OnlineVotingSystem/commit/0181cb0272857696c8eb3e44fcf6cb014ff90f09,|||||,0,0,onlinevotingsystem_project/onlinevotingsystem *,onlinevotingsystem_project/onlinevotingsystem *,"Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (""stretching"") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.
                  Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.
                  Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.; If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Weak Salt,Medium,Weak Salt,Denial of Service (DoS),
CVE-2021-21253,"OnlineVotingSystem is an open source project hosted on GitHub. OnlineVotingSystem before version 1.1.2 hashes user passwords without a salt, which is vulnerable to dictionary attacks. Therefore there is a threat of security breach in the voting system. Without a salt, it is much easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables to crack passwords. This problem is fixed and published in version 1.1.2. A long randomly generated salt is added to the password hash function to better protect passwords stored in the voting system.",,,0,0,0,0,,,,,,,CWE-759,Use of a One-Way Hash without a Salt,Variant,"Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (""stretching"") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.
                  Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.
                  Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.; If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Other_Vendor,Other_Product,< 1.1.2,,,,,,5.8,,,CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:N,N,L,N,N,C,L,N,N,4,6,https://github.com/dbijaya/OnlineVotingSystem/commit/0181cb0272857696c8eb3e44fcf6cb014ff90f09|https://github.com/dbijaya/OnlineVotingSystem/commit/0181cb0272857696c8eb3e44fcf6cb014ff90f09|https://github.com/dbijaya/OnlineVotingSystem/security/advisories/GHSA-wwg8-372v-v332|https://github.com/dbijaya/OnlineVotingSystem/security/advisories/GHSA-wwg8-372v-v332|https://github.com/dbijaya/OnlineVotingSystem/security/advisories/GHSA-wwg8-372v-v332|https://github.com/dbijaya/OnlineVotingSystem/commit/0181cb0272857696c8eb3e44fcf6cb014ff90f09,|||||,0,0,dbijaya/OnlineVotingSystem < 1.1.2,dbijaya/OnlineVotingSystem < 1.1.2,"Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (""stretching"") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.
                  Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.
                  Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.; If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Weak Salt,Medium,Weak Salt,Privilege Escalation,
CVE-2024-8453,"Certain switch models from PLANET Technology use an insecure hashing function to hash user passwords without being salted. Remote attackers with administrator privileges can read configuration files to obtain the hash values, and potentially crack them to retrieve the plaintext passwords.",,,0,0,0,0,,,,,,,CWE-759,Use of a One-Way Hash without a Salt,Variant,"Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (""stretching"") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.
                  Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.
                  Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.; If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Other_Vendor,Other_Product,0,,,,,,4.9,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N,N,L,H,N,U,H,N,N,4,4,https://www.twcert.org.tw/tw/cp-132-8055-2c361-1.html|https://www.twcert.org.tw/en/cp-139-8056-09688-2.html|https://www.twcert.org.tw/tw/cp-132-8055-2c361-1.html|https://www.twcert.org.tw/en/cp-139-8056-09688-2.html,|||,0,0,PLANET Technology/GS-4210-24P2S hardware 3.0 0,PLANET Technology/GS-4210-24P2S hardware 3.0 0,"Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (""stretching"") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.
                  Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.
                  Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.; If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Weak Salt,Medium,Weak Salt,Information Disclosure,
CVE-2023-33838,"IBM Security Verify Governance 10.0.2 Identity Manager 

uses a one-way cryptographic hash against an input that should not be reversible, such as a password, but the product does not also use a salt as part of the input.",,,0,0,0,0,,,,,,,CWE-759,Use of a One-Way Hash without a Salt,Variant,"Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (""stretching"") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.
                  Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.
                  Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.; If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",ibm,Other_Product,10.0.2,,,,,,4.4,,,CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:N,N,H,H,N,U,H,N,N,2,2,https://www.ibm.com/support/pages/node/7172200|https://www.ibm.com/support/pages/node/7172200,|,0,0,ibm/security_verify_governance 10.0.2,ibm/security_verify_governance 10.0.2,"Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (""stretching"") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.
                  Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.
                  Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.; If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Weak Salt,Medium,Weak Salt,Remote Code Execution,
CVE-2024-8453,"Certain switch models from PLANET Technology use an insecure hashing function to hash user passwords without being salted. Remote attackers with administrator privileges can read configuration files to obtain the hash values, and potentially crack them to retrieve the plaintext passwords.",,,0,0,0,0,,,,,,,CWE-759,Use of a One-Way Hash without a Salt,Variant,"Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (""stretching"") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.
                  Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.
                  Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.; If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Other_Vendor,Other_Product,0,,,,,,4.9,,,CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N,N,L,H,N,U,H,N,N,4,4,https://www.twcert.org.tw/tw/cp-132-8055-2c361-1.html|https://www.twcert.org.tw/en/cp-139-8056-09688-2.html|https://www.twcert.org.tw/tw/cp-132-8055-2c361-1.html|https://www.twcert.org.tw/en/cp-139-8056-09688-2.html,|||,0,0,PLANET Technology/GS-4210-24PL4C hardware 2.0 0,PLANET Technology/GS-4210-24PL4C hardware 2.0 0,"Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (""stretching"") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.
                  Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.
                  Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.; If a technique that requires extra computational effort can not be implemented, then for each password that is processed, generate a new random salt using a strong random number generator with unpredictable seeds. Add the salt to the plaintext password before hashing it. When storing the hash, also store the salt. Do not use the same salt for every password.; When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.",Weak Salt,Medium,Weak Salt,Denial of Service (DoS),
